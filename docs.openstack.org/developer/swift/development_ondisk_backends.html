<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Pluggable On-Disk Back-end APIs &mdash; swift 2.12.1.dev102 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.12.1.dev102',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="swift 2.12.1.dev102 documentation" href="index.html" />
    <link rel="next" title="Instructions for a Multiple Server Swift Installation" href="howto_installmultinode.html" />
    <link rel="prev" title="Middleware and Metadata" href="development_middleware.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pluggable-on-disk-back-end-apis">
<h1>Pluggable On-Disk Back-end APIs<a class="headerlink" href="#pluggable-on-disk-back-end-apis" title="Permalink to this headline">¶</a></h1>
<p>The internal REST API used between the proxy server and the account, container
and object server is almost identical to public Swift REST API, but with a few
internal extensions (for example, update an account with a new container).</p>
<p>The pluggable back-end APIs for the three REST API servers (account,
container, object) abstracts the needs for servicing the various REST APIs
from the details of how data is laid out and stored on-disk.</p>
<p>The APIs are documented in the reference implementations for all three
servers. For historical reasons, the object server backend reference
implementation module is named <cite>diskfile</cite>, while the account and container
server backend reference implementation modules are named appropriately.</p>
<p>This API is still under development and not yet finalized.</p>
<div class="section" id="back-end-api-for-account-server-rest-apis">
<h2>Back-end API for Account Server REST APIs<a class="headerlink" href="#back-end-api-for-account-server-rest-apis" title="Permalink to this headline">¶</a></h2>
<p>Pluggable Back-end for Account Server</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.account.backend.</code><code class="descname">AccountBroker</code><span class="sig-paren">(</span><em>db_file</em>, <em>timeout=25</em>, <em>logger=None</em>, <em>account=None</em>, <em>container=None</em>, <em>pending_timeout=None</em>, <em>stale_reads_ok=False</em><span class="sig-paren">)</span></dt>
<dd><p>Encapsulates working with an account database.</p>
<dl class="method">
<dt>
<code class="descname">create_account_stat_table</code><span class="sig-paren">(</span><em>conn</em>, <em>put_timestamp</em><span class="sig-paren">)</span></dt>
<dd><p>Create account_stat table which is specific to the account DB.
Not a part of Pluggable Back-ends, internal to the baseline code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conn</strong> &#8211; DB connection object</li>
<li><strong>put_timestamp</strong> &#8211; put timestamp</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_container_table</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span></dt>
<dd><p>Create container table which is specific to the account DB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conn</strong> &#8211; DB connection object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_policy_stat_table</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span></dt>
<dd><p>Create policy_stat table which is specific to the account DB.
Not a part of Pluggable Back-ends, internal to the baseline code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conn</strong> &#8211; DB connection object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check if the account DB is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the database has no active containers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get global data for the account.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with keys: account, created_at, put_timestamp,
delete_timestamp, status_changed_at, container_count,
object_count, bytes_used, hash, id</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_policy_stats</code><span class="sig-paren">(</span><em>do_migrations=False</em><span class="sig-paren">)</span></dt>
<dd><p>Get global policy stats for the account.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>do_migrations</strong> &#8211; boolean, if True the policy stat dicts will
always include the &#8216;container_count&#8217; key;
otherwise it may be omitted on legacy databases
until they are migrated.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict of policy stats where the key is the policy index and
the value is a dictionary like {&#8216;object_count&#8217;: M,
&#8216;bytes_used&#8217;: N, &#8216;container_count&#8217;: L}</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">is_status_deleted</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Only returns true if the status field is set to DELETED.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">list_containers_iter</code><span class="sig-paren">(</span><em>limit</em>, <em>marker</em>, <em>end_marker</em>, <em>prefix</em>, <em>delimiter</em>, <em>reverse=False</em><span class="sig-paren">)</span></dt>
<dd><p>Get a list of containers sorted by name starting at marker onward, up
to limit entries. Entries will begin with the prefix and will not have
the delimiter after the prefix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>limit</strong> &#8211; maximum number of entries to get</li>
<li><strong>marker</strong> &#8211; marker query</li>
<li><strong>end_marker</strong> &#8211; end marker query</li>
<li><strong>prefix</strong> &#8211; prefix query</li>
<li><strong>delimiter</strong> &#8211; delimiter for query</li>
<li><strong>reverse</strong> &#8211; reverse the result order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of tuples of (name, object_count, bytes_used,
put_timestamp, 0)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">merge_items</code><span class="sig-paren">(</span><em>item_list</em>, <em>source=None</em><span class="sig-paren">)</span></dt>
<dd><p>Merge items into the container table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item_list</strong> &#8211; list of dictionaries of {&#8216;name&#8217;, &#8216;put_timestamp&#8217;,
&#8216;delete_timestamp&#8217;, &#8216;object_count&#8217;, &#8216;bytes_used&#8217;,
&#8216;deleted&#8217;, &#8216;storage_policy_index&#8217;}</li>
<li><strong>source</strong> &#8211; if defined, update incoming_sync with the source</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put_container</code><span class="sig-paren">(</span><em>name</em>, <em>put_timestamp</em>, <em>delete_timestamp</em>, <em>object_count</em>, <em>bytes_used</em>, <em>storage_policy_index</em><span class="sig-paren">)</span></dt>
<dd><p>Create a container with the given attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of the container to create</li>
<li><strong>put_timestamp</strong> &#8211; put_timestamp of the container to create</li>
<li><strong>delete_timestamp</strong> &#8211; delete_timestamp of the container to create</li>
<li><strong>object_count</strong> &#8211; number of objects in the container</li>
<li><strong>bytes_used</strong> &#8211; number of bytes used by the container</li>
<li><strong>storage_policy_index</strong> &#8211; the storage policy for this container</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="back-end-api-for-container-server-rest-apis">
<h2>Back-end API for Container Server REST APIs<a class="headerlink" href="#back-end-api-for-container-server-rest-apis" title="Permalink to this headline">¶</a></h2>
<p>Pluggable Back-ends for Container Server</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.container.backend.</code><code class="descname">ContainerBroker</code><span class="sig-paren">(</span><em>db_file</em>, <em>timeout=25</em>, <em>logger=None</em>, <em>account=None</em>, <em>container=None</em>, <em>pending_timeout=None</em>, <em>stale_reads_ok=False</em><span class="sig-paren">)</span></dt>
<dd><p>Encapsulates working with a container database.</p>
<dl class="method">
<dt>
<code class="descname">create_container_info_table</code><span class="sig-paren">(</span><em>conn</em>, <em>put_timestamp</em>, <em>storage_policy_index</em><span class="sig-paren">)</span></dt>
<dd><p>Create the container_info table which is specific to the container DB.
Not a part of Pluggable Back-ends, internal to the baseline code.
Also creates the container_stat view.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conn</strong> &#8211; DB connection object</li>
<li><strong>put_timestamp</strong> &#8211; put timestamp</li>
<li><strong>storage_policy_index</strong> &#8211; storage policy index</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_object_table</code><span class="sig-paren">(</span><em>conn</em><span class="sig-paren">)</span></dt>
<dd><p>Create the object table which is specific to the container DB.
Not a part of Pluggable Back-ends, internal to the baseline code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conn</strong> &#8211; DB connection object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_policy_stat_table</code><span class="sig-paren">(</span><em>conn</em>, <em>storage_policy_index=0</em><span class="sig-paren">)</span></dt>
<dd><p>Create policy_stat table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conn</strong> &#8211; DB connection object</li>
<li><strong>storage_policy_index</strong> &#8211; the policy_index the container is
being created with</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_object</code><span class="sig-paren">(</span><em>name</em>, <em>timestamp</em>, <em>storage_policy_index=0</em><span class="sig-paren">)</span></dt>
<dd><p>Mark an object deleted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; object name to be deleted</li>
<li><strong>timestamp</strong> &#8211; timestamp when the object was marked as deleted</li>
<li><strong>storage_policy_index</strong> &#8211; the storage policy index for the object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Check if container DB is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the database has no active objects, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get global data for the container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dict with keys: account, container, created_at,
put_timestamp, delete_timestamp, status_changed_at,
object_count, bytes_used, reported_put_timestamp,
reported_delete_timestamp, reported_object_count,
reported_bytes_used, hash, id, x_container_sync_point1,
x_container_sync_point2, and storage_policy_index.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_info_is_deleted</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get the is_deleted status and info for the container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple, in the form (info, is_deleted) info is a dict as
returned by get_info and is_deleted is a boolean.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_misplaced_since</code><span class="sig-paren">(</span><em>start</em>, <em>count</em><span class="sig-paren">)</span></dt>
<dd><p>Get a list of objects which are in a storage policy different
from the container&#8217;s storage policy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; last reconciler sync point</li>
<li><strong>count</strong> &#8211; maximum number of entries to get</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of dicts with keys: name, created_at, size,
content_type, etag, storage_policy_index</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">list_objects_iter</code><span class="sig-paren">(</span><em>limit</em>, <em>marker</em>, <em>end_marker</em>, <em>prefix</em>, <em>delimiter</em>, <em>path=None</em>, <em>storage_policy_index=0</em>, <em>reverse=False</em><span class="sig-paren">)</span></dt>
<dd><p>Get a list of objects sorted by name starting at marker onward, up
to limit entries.  Entries will begin with the prefix and will not
have the delimiter after the prefix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>limit</strong> &#8211; maximum number of entries to get</li>
<li><strong>marker</strong> &#8211; marker query</li>
<li><strong>end_marker</strong> &#8211; end marker query</li>
<li><strong>prefix</strong> &#8211; prefix query</li>
<li><strong>delimiter</strong> &#8211; delimiter for query</li>
<li><strong>path</strong> &#8211; if defined, will set the prefix and delimiter based on
the path</li>
<li><strong>storage_policy_index</strong> &#8211; storage policy index for query</li>
<li><strong>reverse</strong> &#8211; reverse the result order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of tuples of (name, created_at, size, content_type,
etag)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">merge_items</code><span class="sig-paren">(</span><em>item_list</em>, <em>source=None</em><span class="sig-paren">)</span></dt>
<dd><p>Merge items into the object table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>item_list</strong> &#8211; list of dictionaries of {&#8216;name&#8217;, &#8216;created_at&#8217;,
&#8216;size&#8217;, &#8216;content_type&#8217;, &#8216;etag&#8217;, &#8216;deleted&#8217;,
&#8216;storage_policy_index&#8217;, &#8216;ctype_timestamp&#8217;,
&#8216;meta_timestamp&#8217;}</li>
<li><strong>source</strong> &#8211; if defined, update incoming_sync with the source</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put_object</code><span class="sig-paren">(</span><em>name</em>, <em>timestamp</em>, <em>size</em>, <em>content_type</em>, <em>etag</em>, <em>deleted=0</em>, <em>storage_policy_index=0</em>, <em>ctype_timestamp=None</em>, <em>meta_timestamp=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates an object in the DB with its metadata.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; object name to be created</li>
<li><strong>timestamp</strong> &#8211; timestamp of when the object was created</li>
<li><strong>size</strong> &#8211; object size</li>
<li><strong>content_type</strong> &#8211; object content-type</li>
<li><strong>etag</strong> &#8211; object etag</li>
<li><strong>deleted</strong> &#8211; if True, marks the object as deleted and sets the
deleted_at timestamp to timestamp</li>
<li><strong>storage_policy_index</strong> &#8211; the storage policy index for the object</li>
<li><strong>ctype_timestamp</strong> &#8211; timestamp of when content_type was last
updated</li>
<li><strong>meta_timestamp</strong> &#8211; timestamp of when metadata was last updated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">reported</code><span class="sig-paren">(</span><em>put_timestamp</em>, <em>delete_timestamp</em>, <em>object_count</em>, <em>bytes_used</em><span class="sig-paren">)</span></dt>
<dd><p>Update reported stats, available with container&#8217;s <cite>get_info</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>put_timestamp</strong> &#8211; put_timestamp to update</li>
<li><strong>delete_timestamp</strong> &#8211; delete_timestamp to update</li>
<li><strong>object_count</strong> &#8211; object_count to update</li>
<li><strong>bytes_used</strong> &#8211; bytes_used to update</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_storage_policy_index</code><span class="sig-paren">(</span><em>policy_index</em>, <em>timestamp=None</em><span class="sig-paren">)</span></dt>
<dd><p>Update the container_stat policy_index and status_changed_at.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.container.backend.</code><code class="descname">update_new_item_from_existing</code><span class="sig-paren">(</span><em>new_item</em>, <em>existing</em><span class="sig-paren">)</span></dt>
<dd><p>Compare the data and meta related timestamps of a new object item with
the timestamps of an existing object record, and update the new item
with data and/or meta related attributes from the existing record if
their timestamps are newer.</p>
<p>The multiple timestamps are encoded into a single string for storing
in the &#8216;created_at&#8217; column of the objects db table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_item</strong> &#8211; A dict of object update attributes</li>
<li><strong>existing</strong> &#8211; A dict of existing object attributes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if any attributes of the new item dict were found to be
newer than the existing and therefore not updated, otherwise
False implying that the updated item is equal to the existing.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="back-end-api-for-object-server-rest-apis">
<h2>Back-end API for Object Server REST APIs<a class="headerlink" href="#back-end-api-for-object-server-rest-apis" title="Permalink to this headline">¶</a></h2>
<p>Disk File Interface for the Swift Object Server</p>
<p>The <cite>DiskFile</cite>, <cite>DiskFileWriter</cite> and <cite>DiskFileReader</cite> classes combined define
the on-disk abstraction layer for supporting the object server REST API
interfaces (excluding <cite>REPLICATE</cite>). Other implementations wishing to provide
an alternative backend for the object server must implement the three
classes. An example alternative implementation can be found in the
<cite>mem_server.py</cite> and <cite>mem_diskfile.py</cite> modules along size this one.</p>
<p>The <cite>DiskFileManager</cite> is a reference implemenation specific class and is not
part of the backend API.</p>
<p>The remaining methods in this module are considered implementation specific and
are also not considered part of the backend API.</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">AuditLocation</code><span class="sig-paren">(</span><em>path</em>, <em>device</em>, <em>partition</em>, <em>policy</em><span class="sig-paren">)</span></dt>
<dd><p>Represents an object location to be audited.</p>
<p>Other than being a bucket of data, the only useful thing this does is
stringify to a filesystem path so the auditor&#8217;s logs look okay.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFile</code><span class="sig-paren">(</span><em>mgr</em>, <em>device_path</em>, <em>partition</em>, <em>account=None</em>, <em>container=None</em>, <em>obj=None</em>, <em>_datadir=None</em>, <em>policy=None</em>, <em>use_splice=False</em>, <em>pipe_size=None</em>, <em>use_linkat=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Manage object files.</p>
<p>This specific implementation manages object files on a disk formatted with
a POSIX-compliant file system that supports extended attributes as
metadata on a file or directory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
<p class="last">The following path format is used for data file locations:
&lt;devices_path/&lt;device_dir&gt;/&lt;datadir&gt;/&lt;partdir&gt;/&lt;suffixdir&gt;/&lt;hashdir&gt;/
&lt;datafile&gt;.&lt;ext&gt;</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mgr</strong> &#8211; associated DiskFileManager instance</li>
<li><strong>device_path</strong> &#8211; path to the target device or drive</li>
<li><strong>partition</strong> &#8211; partition on the device in which the object lives</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>_datadir</strong> &#8211; override the full datadir otherwise constructed here</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
<li><strong>use_splice</strong> &#8211; if true, use zero-copy splice() to send data</li>
<li><strong>pipe_size</strong> &#8211; size of pipe buffer used in zero-copy operations</li>
<li><strong>use_linkat</strong> &#8211; if True, use open() with linkat() to create obj file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">create</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></dt>
<dd><p>Context manager to create a file. We create a temporary file first, and
then return a DiskFileWriter object to encapsulate the state.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is not required to perform on-disk
preallocations even if the parameter is specified. But if it does
and it fails, it must raise a <cite>DiskFileNoSpace</cite> exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; optional initial size of file to explicitly allocate on
disk</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNoSpace</strong> &#8211; if a size is specified and allocation fails</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span></dt>
<dd><p>Delete the object.</p>
<p>This implementation creates a tombstone file using the given
timestamp, and removes any older versions of the object file. Any
file that has an older timestamp than timestamp will be deleted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is free to use or ignore the timestamp
parameter.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timestamp</strong> &#8211; timestamp to compare with each file</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>create()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">durable_timestamp</code></dt>
<dd><p>Provides the timestamp of the newest data file found in the object
directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Timestamp instance, or None if no data file was found.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the open() method has not been previously
called on this instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_datafile_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Provide the datafile metadata for a previously opened object as a
dictionary. This is metadata that was included when the object was
first PUT, and does not include metadata set by any subsequent POST.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s datafile metadata dictionary</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Provide the metadata for a previously opened object as a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s metadata dictionary</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_metafile_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Provide the metafile metadata for a previously opened object as a
dictionary. This is metadata that was written by a POST and does not
include any persistent metadata that was set by the original PUT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s .meta file metadata dictionary, or None if there is
no .meta file</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Open the object.</p>
<p>This implementation opens the data file representing the object, reads
the associated metadata in the extended attributes, additionally
combining metadata from fast-POST <cite>.meta</cite> files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is allowed to raise any of the following
exceptions, but is only required to raise <cite>DiskFileNotExist</cite> when
the object representation does not exist.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>DiskFileCollision</strong> &#8211; on name mis-match with metadata</li>
<li><strong>DiskFileNotExist</strong> &#8211; if the object does not exist</li>
<li><strong>DiskFileDeleted</strong> &#8211; if the object was previously deleted</li>
<li><strong>DiskFileQuarantined</strong> &#8211; if while reading metadata of the file
some data did pass cross checks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">itself for use as a context manager</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">read_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the metadata for an object without requiring the caller to open
the object first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">metadata dictionary for an object</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>open()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">reader</code><span class="sig-paren">(</span><em>keep_cache=False</em>, <em>_quarantine_hook=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>Return a <a class="reference internal" href="misc.html#swift.common.swob.Response" title="swift.common.swob.Response"><code class="xref py py-class docutils literal"><span class="pre">swift.common.swob.Response</span></code></a> class compatible
&#8220;<cite>app_iter</cite>&#8221; object as defined by
<a class="reference internal" href="object.html#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a>.</p>
<p>For this implementation, the responsibility of closing the open file
is passed to the <a class="reference internal" href="object.html#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>keep_cache</strong> &#8211; caller&#8217;s preference for keeping data read in the
OS buffer cache</li>
<li><strong>_quarantine_hook</strong> &#8211; 1-arg callable called when obj quarantined;
the arg is the reason for quarantine.
Default is to ignore it.
Not needed by the REST layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <a class="reference internal" href="object.html#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">write_metadata</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span></dt>
<dd><p>Write a block of metadata to an object without requiring the caller to
create the object first. Supports fast-POST behavior semantics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with the
object</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>create()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileManager</code><span class="sig-paren">(</span><em>conf</em>, <em>logger</em><span class="sig-paren">)</span></dt>
<dd><p>Management class for devices, providing common place for shared parameters
and methods not provided by the DiskFile class (which primarily services
the object server REST API layer).</p>
<p>The <cite>get_diskfile()</cite> method is how this implementation creates a <cite>DiskFile</cite>
object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is reference implementation specific and not part of the
pluggable on-disk backend API.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO(portante): Not sure what the right name to recommend here, as
&#8220;manager&#8221; seemed generic enough, though suggestions are welcome.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conf</strong> &#8211; caller provided configuration object</li>
<li><strong>logger</strong> &#8211; caller provided logger</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">cleanup_ondisk_files</code><span class="sig-paren">(</span><em>hsh_path</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Clean up on-disk files that are obsolete and gather the set of valid
on-disk files for an object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hsh_path</strong> &#8211; object hash path</li>
<li><strong>frag_index</strong> &#8211; if set, search for a specific fragment index .data
file, otherwise accept the first valid .data file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict that may contain: valid on disk files keyed by their
filename extension; a list of obsolete files stored under the
key &#8216;obsolete&#8217;; a list of files remaining in the directory,
reverse sorted, stored under the key &#8216;files&#8217;.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">construct_dev_path</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span></dt>
<dd><p>Construct the path to a device without checking if it is mounted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; name of target device</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">full path to the device</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_dev_path</code><span class="sig-paren">(</span><em>device</em>, <em>mount_check=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return the path to a device, first checking to see if either it
is a proper mount point, or at least a directory depending on
the mount_check configuration option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>mount_check</strong> &#8211; whether or not to check mountedness of device.
Defaults to bool(self.mount_check).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">full path to the device, None if the path to the device is
not a proper mount point or directory.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_diskfile</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>policy</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a BaseDiskFile instance for an object based on the object&#8217;s
partition, path parts and policy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition on device in which the object lives</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_diskfile_from_audit_location</code><span class="sig-paren">(</span><em>audit_location</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a BaseDiskFile instance for an object at the given
AuditLocation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>audit_location</strong> &#8211; object location to be audited</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_diskfile_from_hash</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>object_hash</em>, <em>policy</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Returns a DiskFile instance for an object at the given
object_hash. Just in case someone thinks of refactoring, be
sure DiskFileDeleted is <em>not</em> raised, but the DiskFile
instance representing the tombstoned object is returned
instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition on the device in which the object lives</li>
<li><strong>object_hash</strong> &#8211; the hash of an object path</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>DiskFileNotExist</strong> &#8211; if the object does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an instance of BaseDiskFile</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_hashes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>suffixes</em>, <em>policy</em><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>suffixes</strong> &#8211; a list of suffix directories to be recalculated</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dictionary that maps suffix directories</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_ondisk_files</code><span class="sig-paren">(</span><em>files</em>, <em>datadir</em>, <em>verify=True</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Given a simple list of files names, determine the files that constitute
a valid fileset i.e. a set of files that defines the state of an
object, and determine the files that are obsolete and could be deleted.
Note that some files may fall into neither category.</p>
<p>If a file is considered part of a valid fileset then its info dict will
be added to the results dict, keyed by &lt;extension&gt;_info. Any files that
are no longer required will have their info dicts added to a list
stored under the key &#8216;obsolete&#8217;.</p>
<p>The results dict will always contain entries with keys &#8216;ts_file&#8217;,
&#8216;data_file&#8217; and &#8216;meta_file&#8217;. Their values will be the fully qualified
path to a file of the corresponding type if there is such a file in the
valid fileset, or None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>files</strong> &#8211; a list of file names.</li>
<li><strong>datadir</strong> &#8211; directory name files are from.</li>
<li><strong>verify</strong> &#8211; if True verify that the ondisk file contract has not
been violated, otherwise do not verify.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>a dict that will contain keys:</dt>
<dd><p class="first last">ts_file   -&gt; path to a .ts file or None
data_file -&gt; path to a .data file or None
meta_file -&gt; path to a .meta file or None
ctype_file -&gt; path to a .meta file or None</p>
</dd>
<dt>and may contain keys:</dt>
<dd><p class="first">ts_info   -&gt; a file info dict for a .ts file
data_info -&gt; a file info dict for a .data file
meta_info -&gt; a file info dict for a .meta file
ctype_info -&gt; a file info dict for a .meta file which</p>
<blockquote>
<div><p>contains the content-type value</p>
</div></blockquote>
<dl class="docutils">
<dt>unexpected -&gt; a list of file paths for unexpected</dt>
<dd><p class="first last">files</p>
</dd>
<dt>possible_reclaim -&gt; a list of file info dicts for possible</dt>
<dd><p class="first last">reclaimable files</p>
</dd>
</dl>
<p class="last">obsolete  -&gt; a list of file info dicts for obsolete files</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_on_disk_filename</code><span class="sig-paren">(</span><em>timestamp</em>, <em>ext=None</em>, <em>ctype_timestamp=None</em>, <em>*a</em>, <em>**kw</em><span class="sig-paren">)</span></dt>
<dd><p>Returns filename for given timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timestamp</strong> &#8211; the object timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li><strong>ext</strong> &#8211; an optional string representing a file extension to be
appended to the returned file name</li>
<li><strong>ctype_timestamp</strong> &#8211; an optional content-type timestamp, an instance
of <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a file name</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">object_audit_location_generator</code><span class="sig-paren">(</span><em>device_dirs=None</em>, <em>auditor_type='ALL'</em><span class="sig-paren">)</span></dt>
<dd><p>Yield an AuditLocation for all objects stored under device_dirs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device_dirs</strong> &#8211; directory of target device</li>
<li><strong>auditor_type</strong> &#8211; either ALL or ZBF</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">parse_on_disk_filename</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span></dt>
<dd><p>Parse an on disk file name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the file name including extension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a dict, with keys for timestamp, ext and ctype_timestamp:<ul class="simple">
<li>timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li>ctype_timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a> or
None for .meta files, otherwise None</li>
<li>ext is a string, the file extension including the leading dot or
the empty string if the filename has no extension.</li>
</ul>
<p>Subclasses may override this method to add further keys to the
returned dict.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; if any part of the filename is not able to be
validated.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">pickle_async_update</code><span class="sig-paren">(</span><em>device</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>data</em>, <em>timestamp</em>, <em>policy</em><span class="sig-paren">)</span></dt>
<dd><p>Write data describing a container update notification to a pickle file
in the async_pending directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>data</strong> &#8211; update data to be written to pickle file</li>
<li><strong>timestamp</strong> &#8211; a Timestamp</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">replication_lock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span></dt>
<dd><p>A context manager that will lock on the device given, if
configured to do so.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; name of target device</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ReplicationLockTimeout</strong> &#8211; If the lock on the device
cannot be granted within the configured timeout.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">yield_hashes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>policy</em>, <em>suffixes=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Yields tuples of (full_path, hash_only, timestamps) for object
information stored for the given device, partition, and
(optionally) suffixes. If suffixes is None, all stored
suffixes will be searched for object hashes. Note that if
suffixes is not None but empty, such as [], then nothing will
be yielded.</p>
<p>timestamps is a dict which may contain items mapping:</p>
<ul>
<li><p class="first">ts_data -&gt; timestamp of data or tombstone file,</p>
</li>
<li><p class="first">ts_meta -&gt; timestamp of meta file, if one exists</p>
</li>
<li><dl class="first docutils">
<dt>ts_ctype -&gt; timestamp of meta file containing most recent</dt>
<dd><p class="first last">content-type value, if one exists</p>
</dd>
</dl>
</li>
</ul>
<p>where timestamps are instances of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
<li><strong>suffixes</strong> &#8211; optional list of suffix directories to be searched</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">yield_suffixes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>policy</em><span class="sig-paren">)</span></dt>
<dd><p>Yields tuples of (full_path, suffix_only) for suffixes stored
on the given device and partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileReader</code><span class="sig-paren">(</span><em>fp</em>, <em>data_file</em>, <em>obj_size</em>, <em>etag</em>, <em>disk_chunk_size</em>, <em>keep_cache_size</em>, <em>device_path</em>, <em>logger</em>, <em>quarantine_hook</em>, <em>use_splice</em>, <em>pipe_size</em>, <em>diskfile</em>, <em>keep_cache=False</em><span class="sig-paren">)</span></dt>
<dd><p>Encapsulation of the WSGI read context for servicing GET REST API
requests. Serves as the context manager object for the
<a class="reference internal" href="object.html#swift.obj.diskfile.DiskFile" title="swift.obj.diskfile.DiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFile</span></code></a> class&#8217;s
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.reader()</span></code> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The quarantining behavior of this method is considered implementation
specific, and is not required of the API.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fp</strong> &#8211; open file object pointer reference</li>
<li><strong>data_file</strong> &#8211; on-disk data file name for the object</li>
<li><strong>obj_size</strong> &#8211; verified on-disk size of the object</li>
<li><strong>etag</strong> &#8211; expected metadata etag value for entire file</li>
<li><strong>disk_chunk_size</strong> &#8211; size of reads from disk in bytes</li>
<li><strong>keep_cache_size</strong> &#8211; maximum object size that will be kept in cache</li>
<li><strong>device_path</strong> &#8211; on-disk device path, used when quarantining an obj</li>
<li><strong>logger</strong> &#8211; logger caller wants this object to use</li>
<li><strong>quarantine_hook</strong> &#8211; 1-arg callable called w/reason when quarantined</li>
<li><strong>use_splice</strong> &#8211; if true, use zero-copy splice() to send data</li>
<li><strong>pipe_size</strong> &#8211; size of pipe buffer used in zero-copy operations</li>
<li><strong>diskfile</strong> &#8211; the diskfile creating this DiskFileReader instance</li>
<li><strong>keep_cache</strong> &#8211; should resulting reads be kept in the buffer cache</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">app_iter_range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an iterator over the data file for range (start, stop)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">app_iter_ranges</code><span class="sig-paren">(</span><em>ranges</em>, <em>content_type</em>, <em>boundary</em>, <em>size</em><span class="sig-paren">)</span></dt>
<dd><p>Returns an iterator over the data file for a set of ranges</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Close the open file handle if present.</p>
<p>For this specific implementation, this method will handle quarantining
the file if necessary.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">zero_copy_send</code><span class="sig-paren">(</span><em>wsockfd</em><span class="sig-paren">)</span></dt>
<dd><p>Does some magic with splice() and tee() to move stuff from disk to
network without ever touching userspace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wsockfd</strong> &#8211; file descriptor (integer) of the socket out which to
send data</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileWriter</code><span class="sig-paren">(</span><em>name</em>, <em>datadir</em>, <em>fd</em>, <em>tmppath</em>, <em>bytes_per_sync</em>, <em>diskfile</em><span class="sig-paren">)</span></dt>
<dd><p>Encapsulation of the write context for servicing PUT REST API
requests. Serves as the context manager object for the
<a class="reference internal" href="object.html#swift.obj.diskfile.DiskFile" title="swift.obj.diskfile.DiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFile</span></code></a> class&#8217;s
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.create()</span></code> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is the responsibility of the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.create()</span></code> method context manager to
close the open file descriptor.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of object from REST API</li>
<li><strong>datadir</strong> &#8211; on-disk directory object will end up in on
<a class="reference internal" href="object.html#swift.obj.diskfile.DiskFileWriter.put" title="swift.obj.diskfile.DiskFileWriter.put"><code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFileWriter.put()</span></code></a></li>
<li><strong>fd</strong> &#8211; open file descriptor of temporary file to receive data</li>
<li><strong>tmppath</strong> &#8211; full path name of the opened file descriptor</li>
<li><strong>bytes_per_sync</strong> &#8211; number bytes written between sync calls</li>
<li><strong>diskfile</strong> &#8211; the diskfile creating this DiskFileWriter instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">commit</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span></dt>
<dd><p>Perform any operations necessary to mark the object as durable. For
replication policy type this is a no-op.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timestamp</strong> &#8211; object put timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span></dt>
<dd><p>Finalize writing the file on disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with the
object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">write</code><span class="sig-paren">(</span><em>chunk</em><span class="sig-paren">)</span></dt>
<dd><p>Write a chunk of data to disk. All invocations of this method must
come before invoking the :func:</p>
<p>For this implementation, the data is written into a temporary file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunk</strong> &#8211; the chunk of data to write as a string object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the total number of bytes written to an object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">consolidate_hashes</code><span class="sig-paren">(</span><em>partition_dir</em><span class="sig-paren">)</span></dt>
<dd><p>Take what&#8217;s in hashes.pkl and hashes.invalid, combine them, write the
result back to hashes.pkl, and clear out hashes.invalid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>suffix_dir</strong> &#8211; absolute path to partition dir containing hashes.pkl
and hashes.invalid</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the hashes, or None if there&#8217;s no hashes.pkl.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">extract_policy</code><span class="sig-paren">(</span><em>obj_path</em><span class="sig-paren">)</span></dt>
<dd><p>Extracts the policy for an object (based on the name of the objects
directory) given the device-relative path to the object. Returns None in
the event that the path is malformed in some way.</p>
<p>The device-relative path is everything after the mount point; for example:</p>
<dl class="docutils">
<dt>/srv/node/d42/objects-5/30/179/</dt>
<dd>485dc017205a81df3af616d917c90179/1401811134.873649.data</dd>
</dl>
<p>would have device-relative path:</p>
<p>objects-5/30/179/485dc017205a81df3af616d917c90179/1401811134.873649.data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj_path</strong> &#8211; device-relative path of an object, or the full path</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a <a class="reference internal" href="misc.html#swift.common.storage_policy.BaseStoragePolicy" title="swift.common.storage_policy.BaseStoragePolicy"><code class="xref py py-class docutils literal"><span class="pre">BaseStoragePolicy</span></code></a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">invalidate_hash</code><span class="sig-paren">(</span><em>suffix_dir</em><span class="sig-paren">)</span></dt>
<dd><p>Invalidates the hash for a suffix_dir in the partition&#8217;s hashes file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>suffix_dir</strong> &#8211; absolute path to suffix dir whose hash needs
invalidating</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">object_audit_location_generator</code><span class="sig-paren">(</span><em>devices</em>, <em>mount_check=True</em>, <em>logger=None</em>, <em>device_dirs=None</em>, <em>auditor_type='ALL'</em><span class="sig-paren">)</span></dt>
<dd><p>Given a devices path (e.g. &#8220;/srv/node&#8221;), yield an AuditLocation for all
objects stored under that directory if device_dirs isn&#8217;t set.  If
device_dirs is set, only yield AuditLocation for the objects under the
entries in device_dirs. The AuditLocation only knows the path to the hash
directory, not to the .data file therein (if any). This is to avoid a
double listdir(hash_dir); the DiskFile object will always do one, so
we don&#8217;t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>devices</strong> &#8211; parent directory of the devices to be audited</li>
<li><strong>mount_check</strong> &#8211; flag to check if a mount check should be performed
on devices</li>
<li><strong>logger</strong> &#8211; a logger object</li>
<li><strong>device_dirs</strong> &#8211; a list of directories under devices to traverse</li>
<li><strong>auditor_type</strong> &#8211; either ALL or ZBF</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">quarantine_renamer</code><span class="sig-paren">(</span><em>device_path</em>, <em>corrupted_file_path</em><span class="sig-paren">)</span></dt>
<dd><p>In the case that a file is corrupted, move it to a quarantined
area to allow replication to fix it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params device_path:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">The path to the device the corrupted file is on.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params corrupted_file_path:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">The path to the file you want quarantined.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">path (str) of directory the file was moved to</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>OSError</strong> &#8211; re-raises non errno.EEXIST / errno.ENOTEMPTY
exceptions from rename</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">read_hashes</code><span class="sig-paren">(</span><em>partition_dir</em><span class="sig-paren">)</span></dt>
<dd><p>Read the existing hashes.pkl</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dict, the suffix hashes (if any), the key &#8216;valid&#8217; will be False
if hashes.pkl is corrupt, cannot be read or does not exist</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">read_metadata</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span></dt>
<dd><p>Helper function to read the pickled metadata from an object file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fd</strong> &#8211; file descriptor or filename to load the metadata from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary of metadata</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">strip_self</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span></dt>
<dd><p>Wrapper to attach module level functions to base class.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">write_hashes</code><span class="sig-paren">(</span><em>partition_dir</em>, <em>hashes</em><span class="sig-paren">)</span></dt>
<dd><p>Write hashes to hashes.pkl</p>
<p>The updated key is added to hashes before it is written.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">write_metadata</code><span class="sig-paren">(</span><em>fd</em>, <em>metadata</em>, <em>xattr_size=65536</em><span class="sig-paren">)</span></dt>
<dd><p>Helper function to write pickled metadata for an object file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fd</strong> &#8211; file descriptor or filename to write the metadata</li>
<li><strong>metadata</strong> &#8211; metadata to write</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Pluggable On-Disk Back-end APIs</a><ul>
<li><a class="reference internal" href="#back-end-api-for-account-server-rest-apis">Back-end API for Account Server REST APIs</a></li>
<li><a class="reference internal" href="#back-end-api-for-container-server-rest-apis">Back-end API for Container Server REST APIs</a></li>
<li><a class="reference internal" href="#back-end-api-for-object-server-rest-apis">Back-end API for Object Server REST APIs</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="development_middleware.html"
                                  title="previous chapter">Middleware and Metadata</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="howto_installmultinode.html"
                                  title="next chapter">Instructions for a Multiple Server Swift Installation</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/swift
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/development_ondisk_backends.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="howto_installmultinode.html" title="Instructions for a Multiple Server Swift Installation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="development_middleware.html" title="Middleware and Metadata"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">swift 2.12.1.dev102 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, OpenStack Foundation.
      Last updated on &#39;Tue Feb 14 07:57:22 2017, commit 7cb6882&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/swift");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>