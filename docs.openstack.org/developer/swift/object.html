<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Object &mdash; swift 2.12.1.dev102 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.12.1.dev102',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="swift 2.12.1.dev102 documentation" href="index.html" />
    <link rel="next" title="Misc" href="misc.html" />
    <link rel="prev" title="Account DB and Container DB" href="db.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="object">
<span id="id1"></span><h1>Object<a class="headerlink" href="#object" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-swift.obj.auditor">
<span id="id2"></span><span id="object-auditor"></span><h2>Object Auditor<a class="headerlink" href="#module-swift.obj.auditor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swift.obj.auditor.AuditorWorker">
<em class="property">class </em><code class="descclassname">swift.obj.auditor.</code><code class="descname">AuditorWorker</code><span class="sig-paren">(</span><em>conf</em>, <em>logger</em>, <em>rcache</em>, <em>devices</em>, <em>zero_byte_only_at_fps=0</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Walk through file system to audit objects</p>
<dl class="method">
<dt id="swift.obj.auditor.AuditorWorker.audit_all_objects">
<code class="descname">audit_all_objects</code><span class="sig-paren">(</span><em>mode='once'</em>, <em>device_dirs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker.audit_all_objects" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.AuditorWorker.create_recon_nested_dict">
<code class="descname">create_recon_nested_dict</code><span class="sig-paren">(</span><em>top_level_key</em>, <em>device_list</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker.create_recon_nested_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.AuditorWorker.failsafe_object_audit">
<code class="descname">failsafe_object_audit</code><span class="sig-paren">(</span><em>location</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker.failsafe_object_audit" title="Permalink to this definition">¶</a></dt>
<dd><p>Entrypoint to object_audit, with a failsafe generic exception handler.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.AuditorWorker.object_audit">
<code class="descname">object_audit</code><span class="sig-paren">(</span><em>location</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker.object_audit" title="Permalink to this definition">¶</a></dt>
<dd><p>Audits the given object location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>location</strong> &#8211; an audit location
(from diskfile.object_audit_location_generator)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.AuditorWorker.record_stats">
<code class="descname">record_stats</code><span class="sig-paren">(</span><em>obj_size</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.AuditorWorker.record_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on config&#8217;s object_size_stats will keep track of how many objects
fall into the specified ranges. For example with the following:</p>
<p>object_size_stats = 10, 100, 1024</p>
<p>and your system has 3 objects of sizes: 5, 20, and 10000 bytes the log
will look like: {&#8220;10&#8221;: 1, &#8220;100&#8221;: 1, &#8220;1024&#8221;: 0, &#8220;OVER&#8221;: 1}</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.auditor.ObjectAuditor">
<em class="property">class </em><code class="descclassname">swift.obj.auditor.</code><code class="descname">ObjectAuditor</code><span class="sig-paren">(</span><em>conf</em>, <em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">swift.common.daemon.Daemon</span></code></p>
<p>Audit objects.</p>
<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.audit_loop">
<code class="descname">audit_loop</code><span class="sig-paren">(</span><em>parent</em>, <em>zbo_fps</em>, <em>override_devices=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.audit_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel audit loop</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.clear_recon_cache">
<code class="descname">clear_recon_cache</code><span class="sig-paren">(</span><em>auditor_type</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.clear_recon_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear recon cache entries</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.fork_child">
<code class="descname">fork_child</code><span class="sig-paren">(</span><em>zero_byte_fps=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.fork_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Child execution</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.run_audit">
<code class="descname">run_audit</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.run_audit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the object audit</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.run_forever">
<code class="descname">run_forever</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.run_forever" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the object audit until stopped.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.auditor.ObjectAuditor.run_once">
<code class="descname">run_once</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.auditor.ObjectAuditor.run_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the object audit once</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-swift.obj.diskfile">
<span id="object-backend"></span><span id="object-diskfile"></span><h2>Object Backend<a class="headerlink" href="#module-swift.obj.diskfile" title="Permalink to this headline">¶</a></h2>
<p>Disk File Interface for the Swift Object Server</p>
<p>The <cite>DiskFile</cite>, <cite>DiskFileWriter</cite> and <cite>DiskFileReader</cite> classes combined define
the on-disk abstraction layer for supporting the object server REST API
interfaces (excluding <cite>REPLICATE</cite>). Other implementations wishing to provide
an alternative backend for the object server must implement the three
classes. An example alternative implementation can be found in the
<cite>mem_server.py</cite> and <cite>mem_diskfile.py</cite> modules along size this one.</p>
<p>The <cite>DiskFileManager</cite> is a reference implemenation specific class and is not
part of the backend API.</p>
<p>The remaining methods in this module are considered implementation specific and
are also not considered part of the backend API.</p>
<dl class="class">
<dt id="swift.obj.diskfile.AuditLocation">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">AuditLocation</code><span class="sig-paren">(</span><em>path</em>, <em>device</em>, <em>partition</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.AuditLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Represents an object location to be audited.</p>
<p>Other than being a bucket of data, the only useful thing this does is
stringify to a filesystem path so the auditor&#8217;s logs look okay.</p>
</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.BaseDiskFile">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFile</code><span class="sig-paren">(</span><em>mgr</em>, <em>device_path</em>, <em>partition</em>, <em>account=None</em>, <em>container=None</em>, <em>obj=None</em>, <em>_datadir=None</em>, <em>policy=None</em>, <em>use_splice=False</em>, <em>pipe_size=None</em>, <em>use_linkat=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Manage object files.</p>
<p>This specific implementation manages object files on a disk formatted with
a POSIX-compliant file system that supports extended attributes as
metadata on a file or directory.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
<p class="last">The following path format is used for data file locations:
&lt;devices_path/&lt;device_dir&gt;/&lt;datadir&gt;/&lt;partdir&gt;/&lt;suffixdir&gt;/&lt;hashdir&gt;/
&lt;datafile&gt;.&lt;ext&gt;</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mgr</strong> &#8211; associated DiskFileManager instance</li>
<li><strong>device_path</strong> &#8211; path to the target device or drive</li>
<li><strong>partition</strong> &#8211; partition on the device in which the object lives</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>_datadir</strong> &#8211; override the full datadir otherwise constructed here</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
<li><strong>use_splice</strong> &#8211; if true, use zero-copy splice() to send data</li>
<li><strong>pipe_size</strong> &#8211; size of pipe buffer used in zero-copy operations</li>
<li><strong>use_linkat</strong> &#8211; if True, use open() with linkat() to create obj file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.account">
<code class="descname">account</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.account" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.container">
<code class="descname">container</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.container" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.content_length">
<code class="descname">content_length</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.content_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.content_type">
<code class="descname">content_type</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.content_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.content_type_timestamp">
<code class="descname">content_type_timestamp</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.content_type_timestamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.create">
<code class="descname">create</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Context manager to create a file. We create a temporary file first, and
then return a DiskFileWriter object to encapsulate the state.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is not required to perform on-disk
preallocations even if the parameter is specified. But if it does
and it fails, it must raise a <cite>DiskFileNoSpace</cite> exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; optional initial size of file to explicitly allocate on
disk</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNoSpace</strong> &#8211; if a size is specified and allocation fails</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.data_timestamp">
<code class="descname">data_timestamp</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.data_timestamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the object.</p>
<p>This implementation creates a tombstone file using the given
timestamp, and removes any older versions of the object file. Any
file that has an older timestamp than timestamp will be deleted.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is free to use or ignore the timestamp
parameter.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timestamp</strong> &#8211; timestamp to compare with each file</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>create()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.durable_timestamp">
<code class="descname">durable_timestamp</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.durable_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the timestamp of the newest data file found in the object
directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Timestamp instance, or None if no data file was found.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the open() method has not been previously
called on this instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.fragments">
<code class="descname">fragments</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.fragments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="swift.obj.diskfile.BaseDiskFile.from_hash_dir">
<em class="property">classmethod </em><code class="descname">from_hash_dir</code><span class="sig-paren">(</span><em>mgr</em>, <em>hash_dir_path</em>, <em>device_path</em>, <em>partition</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.from_hash_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.get_datafile_metadata">
<code class="descname">get_datafile_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.get_datafile_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the datafile metadata for a previously opened object as a
dictionary. This is metadata that was included when the object was
first PUT, and does not include metadata set by any subsequent POST.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s datafile metadata dictionary</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.get_metadata">
<code class="descname">get_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the metadata for a previously opened object as a dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s metadata dictionary</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.get_metafile_metadata">
<code class="descname">get_metafile_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.get_metafile_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the metafile metadata for a previously opened object as a
dictionary. This is metadata that was written by a POST and does not
include any persistent metadata that was set by the original PUT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object&#8217;s .meta file metadata dictionary, or None if there is
no .meta file</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.open()</span></code> method was not previously
invoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.manager">
<code class="descname">manager</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.obj">
<code class="descname">obj</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.open">
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the object.</p>
<p>This implementation opens the data file representing the object, reads
the associated metadata in the extended attributes, additionally
combining metadata from fast-POST <cite>.meta</cite> files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An implementation is allowed to raise any of the following
exceptions, but is only required to raise <cite>DiskFileNotExist</cite> when
the object representation does not exist.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><strong>DiskFileCollision</strong> &#8211; on name mis-match with metadata</li>
<li><strong>DiskFileNotExist</strong> &#8211; if the object does not exist</li>
<li><strong>DiskFileDeleted</strong> &#8211; if the object was previously deleted</li>
<li><strong>DiskFileQuarantined</strong> &#8211; if while reading metadata of the file
some data did pass cross checks</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">itself for use as a context manager</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.read_metadata">
<code class="descname">read_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.read_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the metadata for an object without requiring the caller to open
the object first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">metadata dictionary for an object</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>open()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.reader">
<code class="descname">reader</code><span class="sig-paren">(</span><em>keep_cache=False</em>, <em>_quarantine_hook=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="misc.html#swift.common.swob.Response" title="swift.common.swob.Response"><code class="xref py py-class docutils literal"><span class="pre">swift.common.swob.Response</span></code></a> class compatible
&#8220;<cite>app_iter</cite>&#8221; object as defined by
<a class="reference internal" href="#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a>.</p>
<p>For this implementation, the responsibility of closing the open file
is passed to the <a class="reference internal" href="#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>keep_cache</strong> &#8211; caller&#8217;s preference for keeping data read in the
OS buffer cache</li>
<li><strong>_quarantine_hook</strong> &#8211; 1-arg callable called when obj quarantined;
the arg is the reason for quarantine.
Default is to ignore it.
Not needed by the REST layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <a class="reference internal" href="#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFileReader</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.reader_cls">
<code class="descname">reader_cls</code><em class="property"> = None</em><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.reader_cls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.timestamp">
<code class="descname">timestamp</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.timestamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFile.write_metadata">
<code class="descname">write_metadata</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.write_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a block of metadata to an object without requiring the caller to
create the object first. Supports fast-POST behavior semantics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with the
object</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; this implementation will raise the same
errors as the <cite>create()</cite> method.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFile.writer_cls">
<code class="descname">writer_cls</code><em class="property"> = None</em><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFile.writer_cls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.BaseDiskFileManager">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileManager</code><span class="sig-paren">(</span><em>conf</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Management class for devices, providing common place for shared parameters
and methods not provided by the DiskFile class (which primarily services
the object server REST API layer).</p>
<p>The <cite>get_diskfile()</cite> method is how this implementation creates a <cite>DiskFile</cite>
object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is reference implementation specific and not part of the
pluggable on-disk backend API.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO(portante): Not sure what the right name to recommend here, as
&#8220;manager&#8221; seemed generic enough, though suggestions are welcome.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conf</strong> &#8211; caller provided configuration object</li>
<li><strong>logger</strong> &#8211; caller provided logger</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.cleanup_ondisk_files">
<code class="descname">cleanup_ondisk_files</code><span class="sig-paren">(</span><em>hsh_path</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.cleanup_ondisk_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up on-disk files that are obsolete and gather the set of valid
on-disk files for an object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hsh_path</strong> &#8211; object hash path</li>
<li><strong>frag_index</strong> &#8211; if set, search for a specific fragment index .data
file, otherwise accept the first valid .data file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dict that may contain: valid on disk files keyed by their
filename extension; a list of obsolete files stored under the
key &#8216;obsolete&#8217;; a list of files remaining in the directory,
reverse sorted, stored under the key &#8216;files&#8217;.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.consolidate_hashes">
<code class="descname">consolidate_hashes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.consolidate_hashes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.construct_dev_path">
<code class="descname">construct_dev_path</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.construct_dev_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the path to a device without checking if it is mounted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; name of target device</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">full path to the device</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFileManager.diskfile_cls">
<code class="descname">diskfile_cls</code><em class="property"> = None</em><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.diskfile_cls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_dev_path">
<code class="descname">get_dev_path</code><span class="sig-paren">(</span><em>device</em>, <em>mount_check=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_dev_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the path to a device, first checking to see if either it
is a proper mount point, or at least a directory depending on
the mount_check configuration option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>mount_check</strong> &#8211; whether or not to check mountedness of device.
Defaults to bool(self.mount_check).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">full path to the device, None if the path to the device is
not a proper mount point or directory.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile">
<code class="descname">get_diskfile</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>policy</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_diskfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a BaseDiskFile instance for an object based on the object&#8217;s
partition, path parts and policy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition on device in which the object lives</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_audit_location">
<code class="descname">get_diskfile_from_audit_location</code><span class="sig-paren">(</span><em>audit_location</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_audit_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a BaseDiskFile instance for an object at the given
AuditLocation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>audit_location</strong> &#8211; object location to be audited</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_hash">
<code class="descname">get_diskfile_from_hash</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>object_hash</em>, <em>policy</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_diskfile_from_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a DiskFile instance for an object at the given
object_hash. Just in case someone thinks of refactoring, be
sure DiskFileDeleted is <em>not</em> raised, but the DiskFile
instance representing the tombstoned object is returned
instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition on the device in which the object lives</li>
<li><strong>object_hash</strong> &#8211; the hash of an object path</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>DiskFileNotExist</strong> &#8211; if the object does not exist</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an instance of BaseDiskFile</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_hashes">
<code class="descname">get_hashes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>suffixes</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_hashes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>suffixes</strong> &#8211; a list of suffix directories to be recalculated</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a dictionary that maps suffix directories</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.get_ondisk_files">
<code class="descname">get_ondisk_files</code><span class="sig-paren">(</span><em>files</em>, <em>datadir</em>, <em>verify=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.get_ondisk_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a simple list of files names, determine the files that constitute
a valid fileset i.e. a set of files that defines the state of an
object, and determine the files that are obsolete and could be deleted.
Note that some files may fall into neither category.</p>
<p>If a file is considered part of a valid fileset then its info dict will
be added to the results dict, keyed by &lt;extension&gt;_info. Any files that
are no longer required will have their info dicts added to a list
stored under the key &#8216;obsolete&#8217;.</p>
<p>The results dict will always contain entries with keys &#8216;ts_file&#8217;,
&#8216;data_file&#8217; and &#8216;meta_file&#8217;. Their values will be the fully qualified
path to a file of the corresponding type if there is such a file in the
valid fileset, or None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>files</strong> &#8211; a list of file names.</li>
<li><strong>datadir</strong> &#8211; directory name files are from.</li>
<li><strong>verify</strong> &#8211; if True verify that the ondisk file contract has not
been violated, otherwise do not verify.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>a dict that will contain keys:</dt>
<dd><p class="first last">ts_file   -&gt; path to a .ts file or None
data_file -&gt; path to a .data file or None
meta_file -&gt; path to a .meta file or None
ctype_file -&gt; path to a .meta file or None</p>
</dd>
<dt>and may contain keys:</dt>
<dd><p class="first">ts_info   -&gt; a file info dict for a .ts file
data_info -&gt; a file info dict for a .data file
meta_info -&gt; a file info dict for a .meta file
ctype_info -&gt; a file info dict for a .meta file which</p>
<blockquote>
<div><p>contains the content-type value</p>
</div></blockquote>
<dl class="docutils">
<dt>unexpected -&gt; a list of file paths for unexpected</dt>
<dd><p class="first last">files</p>
</dd>
<dt>possible_reclaim -&gt; a list of file info dicts for possible</dt>
<dd><p class="first last">reclaimable files</p>
</dd>
</dl>
<p class="last">obsolete  -&gt; a list of file info dicts for obsolete files</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.invalidate_hash">
<code class="descname">invalidate_hash</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.invalidate_hash" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.make_on_disk_filename">
<code class="descname">make_on_disk_filename</code><span class="sig-paren">(</span><em>timestamp</em>, <em>ext=None</em>, <em>ctype_timestamp=None</em>, <em>*a</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.make_on_disk_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns filename for given timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timestamp</strong> &#8211; the object timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li><strong>ext</strong> &#8211; an optional string representing a file extension to be
appended to the returned file name</li>
<li><strong>ctype_timestamp</strong> &#8211; an optional content-type timestamp, an instance
of <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a file name</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.object_audit_location_generator">
<code class="descname">object_audit_location_generator</code><span class="sig-paren">(</span><em>device_dirs=None</em>, <em>auditor_type='ALL'</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.object_audit_location_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield an AuditLocation for all objects stored under device_dirs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device_dirs</strong> &#8211; directory of target device</li>
<li><strong>auditor_type</strong> &#8211; either ALL or ZBF</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.parse_on_disk_filename">
<code class="descname">parse_on_disk_filename</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.parse_on_disk_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse an on disk file name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the file name including extension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a dict, with keys for timestamp, ext and ctype_timestamp:<ul class="simple">
<li>timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li>ctype_timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a> or
None for .meta files, otherwise None</li>
<li>ext is a string, the file extension including the leading dot or
the empty string if the filename has no extension.</li>
</ul>
<p>Subclasses may override this method to add further keys to the
returned dict.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; if any part of the filename is not able to be
validated.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.pickle_async_update">
<code class="descname">pickle_async_update</code><span class="sig-paren">(</span><em>device</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>data</em>, <em>timestamp</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.pickle_async_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data describing a container update notification to a pickle file
in the async_pending directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name for the object</li>
<li><strong>data</strong> &#8211; update data to be written to pickle file</li>
<li><strong>timestamp</strong> &#8211; a Timestamp</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.quarantine_renamer">
<code class="descname">quarantine_renamer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.quarantine_renamer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.replication_lock">
<code class="descname">replication_lock</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.replication_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>A context manager that will lock on the device given, if
configured to do so.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; name of target device</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ReplicationLockTimeout</strong> &#8211; If the lock on the device
cannot be granted within the configured timeout.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.yield_hashes">
<code class="descname">yield_hashes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>policy</em>, <em>suffixes=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.yield_hashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields tuples of (full_path, hash_only, timestamps) for object
information stored for the given device, partition, and
(optionally) suffixes. If suffixes is None, all stored
suffixes will be searched for object hashes. Note that if
suffixes is not None but empty, such as [], then nothing will
be yielded.</p>
<p>timestamps is a dict which may contain items mapping:</p>
<ul>
<li><p class="first">ts_data -&gt; timestamp of data or tombstone file,</p>
</li>
<li><p class="first">ts_meta -&gt; timestamp of meta file, if one exists</p>
</li>
<li><dl class="first docutils">
<dt>ts_ctype -&gt; timestamp of meta file containing most recent</dt>
<dd><p class="first last">content-type value, if one exists</p>
</dd>
</dl>
</li>
</ul>
<p>where timestamps are instances of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
<li><strong>suffixes</strong> &#8211; optional list of suffix directories to be searched</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileManager.yield_suffixes">
<code class="descname">yield_suffixes</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileManager.yield_suffixes" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields tuples of (full_path, suffix_only) for suffixes stored
on the given device and partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>device</strong> &#8211; name of target device</li>
<li><strong>partition</strong> &#8211; partition name</li>
<li><strong>policy</strong> &#8211; the StoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.BaseDiskFileReader">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileReader</code><span class="sig-paren">(</span><em>fp</em>, <em>data_file</em>, <em>obj_size</em>, <em>etag</em>, <em>disk_chunk_size</em>, <em>keep_cache_size</em>, <em>device_path</em>, <em>logger</em>, <em>quarantine_hook</em>, <em>use_splice</em>, <em>pipe_size</em>, <em>diskfile</em>, <em>keep_cache=False</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Encapsulation of the WSGI read context for servicing GET REST API
requests. Serves as the context manager object for the
<a class="reference internal" href="#swift.obj.diskfile.DiskFile" title="swift.obj.diskfile.DiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFile</span></code></a> class&#8217;s
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.reader()</span></code> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The quarantining behavior of this method is considered implementation
specific, and is not required of the API.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fp</strong> &#8211; open file object pointer reference</li>
<li><strong>data_file</strong> &#8211; on-disk data file name for the object</li>
<li><strong>obj_size</strong> &#8211; verified on-disk size of the object</li>
<li><strong>etag</strong> &#8211; expected metadata etag value for entire file</li>
<li><strong>disk_chunk_size</strong> &#8211; size of reads from disk in bytes</li>
<li><strong>keep_cache_size</strong> &#8211; maximum object size that will be kept in cache</li>
<li><strong>device_path</strong> &#8211; on-disk device path, used when quarantining an obj</li>
<li><strong>logger</strong> &#8211; logger caller wants this object to use</li>
<li><strong>quarantine_hook</strong> &#8211; 1-arg callable called w/reason when quarantined</li>
<li><strong>use_splice</strong> &#8211; if true, use zero-copy splice() to send data</li>
<li><strong>pipe_size</strong> &#8211; size of pipe buffer used in zero-copy operations</li>
<li><strong>diskfile</strong> &#8211; the diskfile creating this DiskFileReader instance</li>
<li><strong>keep_cache</strong> &#8211; should resulting reads be kept in the buffer cache</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileReader.app_iter_range">
<code class="descname">app_iter_range</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.app_iter_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over the data file for range (start, stop)</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileReader.app_iter_ranges">
<code class="descname">app_iter_ranges</code><span class="sig-paren">(</span><em>ranges</em>, <em>content_type</em>, <em>boundary</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.app_iter_ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over the data file for a set of ranges</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileReader.can_zero_copy_send">
<code class="descname">can_zero_copy_send</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.can_zero_copy_send" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileReader.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the open file handle if present.</p>
<p>For this specific implementation, this method will handle quarantining
the file if necessary.</p>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFileReader.manager">
<code class="descname">manager</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileReader.zero_copy_send">
<code class="descname">zero_copy_send</code><span class="sig-paren">(</span><em>wsockfd</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileReader.zero_copy_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Does some magic with splice() and tee() to move stuff from disk to
network without ever touching userspace.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>wsockfd</strong> &#8211; file descriptor (integer) of the socket out which to
send data</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.BaseDiskFileWriter">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">BaseDiskFileWriter</code><span class="sig-paren">(</span><em>name</em>, <em>datadir</em>, <em>fd</em>, <em>tmppath</em>, <em>bytes_per_sync</em>, <em>diskfile</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Encapsulation of the write context for servicing PUT REST API
requests. Serves as the context manager object for the
<a class="reference internal" href="#swift.obj.diskfile.DiskFile" title="swift.obj.diskfile.DiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.DiskFile</span></code></a> class&#8217;s
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.create()</span></code> method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is the responsibility of the
<code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFile.create()</span></code> method context manager to
close the open file descriptor.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The arguments to the constructor are considered implementation
specific. The API does not define the constructor arguments.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; name of object from REST API</li>
<li><strong>datadir</strong> &#8211; on-disk directory object will end up in on
<a class="reference internal" href="#swift.obj.diskfile.DiskFileWriter.put" title="swift.obj.diskfile.DiskFileWriter.put"><code class="xref py py-func docutils literal"><span class="pre">swift.obj.diskfile.DiskFileWriter.put()</span></code></a></li>
<li><strong>fd</strong> &#8211; open file descriptor of temporary file to receive data</li>
<li><strong>tmppath</strong> &#8211; full path name of the opened file descriptor</li>
<li><strong>bytes_per_sync</strong> &#8211; number bytes written between sync calls</li>
<li><strong>diskfile</strong> &#8211; the diskfile creating this DiskFileWriter instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileWriter.commit">
<code class="descname">commit</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any operations necessary to mark the object as durable. For
replication policy type this is a no-op.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timestamp</strong> &#8211; object put timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFileWriter.manager">
<code class="descname">manager</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter.manager" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileWriter.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize writing the file on disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with the
object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.BaseDiskFileWriter.put_succeeded">
<code class="descname">put_succeeded</code><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter.put_succeeded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.BaseDiskFileWriter.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>chunk</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.BaseDiskFileWriter.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a chunk of data to disk. All invocations of this method must
come before invoking the :func:</p>
<p>For this implementation, the data is written into a temporary file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunk</strong> &#8211; the chunk of data to write as a string object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the total number of bytes written to an object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.DiskFile">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">DiskFile</code><span class="sig-paren">(</span><em>mgr</em>, <em>device_path</em>, <em>partition</em>, <em>account=None</em>, <em>container=None</em>, <em>obj=None</em>, <em>_datadir=None</em>, <em>policy=None</em>, <em>use_splice=False</em>, <em>pipe_size=None</em>, <em>use_linkat=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFile" title="swift.obj.diskfile.BaseDiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFile</span></code></a></p>
<dl class="attribute">
<dt id="swift.obj.diskfile.DiskFile.reader_cls">
<code class="descname">reader_cls</code><a class="headerlink" href="#swift.obj.diskfile.DiskFile.reader_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.DiskFileReader" title="swift.obj.diskfile.DiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">DiskFileReader</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.DiskFile.writer_cls">
<code class="descname">writer_cls</code><a class="headerlink" href="#swift.obj.diskfile.DiskFile.writer_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.DiskFileWriter" title="swift.obj.diskfile.DiskFileWriter"><code class="xref py py-class docutils literal"><span class="pre">DiskFileWriter</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.DiskFileManager">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">DiskFileManager</code><span class="sig-paren">(</span><em>conf</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileManager" title="swift.obj.diskfile.BaseDiskFileManager"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileManager</span></code></a></p>
<dl class="attribute">
<dt id="swift.obj.diskfile.DiskFileManager.diskfile_cls">
<code class="descname">diskfile_cls</code><a class="headerlink" href="#swift.obj.diskfile.DiskFileManager.diskfile_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.DiskFile" title="swift.obj.diskfile.DiskFile"><code class="xref py py-class docutils literal"><span class="pre">DiskFile</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.DiskFileReader">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">DiskFileReader</code><span class="sig-paren">(</span><em>fp</em>, <em>data_file</em>, <em>obj_size</em>, <em>etag</em>, <em>disk_chunk_size</em>, <em>keep_cache_size</em>, <em>device_path</em>, <em>logger</em>, <em>quarantine_hook</em>, <em>use_splice</em>, <em>pipe_size</em>, <em>diskfile</em>, <em>keep_cache=False</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileReader" title="swift.obj.diskfile.BaseDiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileReader</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.DiskFileRouter">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">DiskFileRouter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileRouter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="swift.obj.diskfile.DiskFileRouter.policy_type_to_manager_cls">
<code class="descname">policy_type_to_manager_cls</code><em class="property"> = {'erasure_coding': &lt;class 'swift.obj.diskfile.ECDiskFileManager'&gt;, 'replication': &lt;class 'swift.obj.diskfile.DiskFileManager'&gt;}</em><a class="headerlink" href="#swift.obj.diskfile.DiskFileRouter.policy_type_to_manager_cls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="swift.obj.diskfile.DiskFileRouter.register">
<em class="property">classmethod </em><code class="descname">register</code><span class="sig-paren">(</span><em>policy_type</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileRouter.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator for Storage Policy implementations to register
their DiskFile implementation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.DiskFileWriter">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">DiskFileWriter</code><span class="sig-paren">(</span><em>name</em>, <em>datadir</em>, <em>fd</em>, <em>tmppath</em>, <em>bytes_per_sync</em>, <em>diskfile</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileWriter" title="swift.obj.diskfile.BaseDiskFileWriter"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileWriter</span></code></a></p>
<dl class="method">
<dt id="swift.obj.diskfile.DiskFileWriter.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.DiskFileWriter.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize writing the file on disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with the
object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.ECDiskFile">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">ECDiskFile</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFile" title="swift.obj.diskfile.BaseDiskFile"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFile</span></code></a></p>
<dl class="attribute">
<dt id="swift.obj.diskfile.ECDiskFile.durable_timestamp">
<code class="descname">durable_timestamp</code><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile.durable_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the timestamp of the newest durable file found in the object
directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A Timestamp instance, or None if no durable file was found.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileNotOpen</strong> &#8211; if the open() method has not been previously
called on this instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.ECDiskFile.fragments">
<code class="descname">fragments</code><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile.fragments" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides information about all fragments that were found in the object
directory, including fragments without a matching durable file, and
including any fragment chosen to construct the opened diskfile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict mapping &lt;Timestamp instance&gt; -&gt; &lt;list of frag indexes&gt;,
or None if the diskfile has not been opened or no fragments
were found.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFile.purge">
<code class="descname">purge</code><span class="sig-paren">(</span><em>timestamp</em>, <em>frag_index</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile.purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a tombstone file matching the specified timestamp or
datafile matching the specified timestamp and fragment index
from the object directory.</p>
<p>This provides the EC reconstructor/ssync process with a way to
remove a tombstone or fragment from a handoff node after
reverting it to its primary node.</p>
<p>The hash will be invalidated, and if empty or invalid the
hsh_path will be removed on next cleanup_ondisk_files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timestamp</strong> &#8211; the object timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li><strong>frag_index</strong> &#8211; fragment archive index, must be
a whole number or None.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.ECDiskFile.reader_cls">
<code class="descname">reader_cls</code><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile.reader_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.ECDiskFileReader" title="swift.obj.diskfile.ECDiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">ECDiskFileReader</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.diskfile.ECDiskFile.writer_cls">
<code class="descname">writer_cls</code><a class="headerlink" href="#swift.obj.diskfile.ECDiskFile.writer_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.ECDiskFileWriter" title="swift.obj.diskfile.ECDiskFileWriter"><code class="xref py py-class docutils literal"><span class="pre">ECDiskFileWriter</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.ECDiskFileManager">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">ECDiskFileManager</code><span class="sig-paren">(</span><em>conf</em>, <em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileManager" title="swift.obj.diskfile.BaseDiskFileManager"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileManager</span></code></a></p>
<dl class="attribute">
<dt id="swift.obj.diskfile.ECDiskFileManager.diskfile_cls">
<code class="descname">diskfile_cls</code><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileManager.diskfile_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#swift.obj.diskfile.ECDiskFile" title="swift.obj.diskfile.ECDiskFile"><code class="xref py py-class docutils literal"><span class="pre">ECDiskFile</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFileManager.make_on_disk_filename">
<code class="descname">make_on_disk_filename</code><span class="sig-paren">(</span><em>timestamp</em>, <em>ext=None</em>, <em>frag_index=None</em>, <em>ctype_timestamp=None</em>, <em>durable=False</em>, <em>*a</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileManager.make_on_disk_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the EC specific filename for given timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timestamp</strong> &#8211; the object timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li><strong>ext</strong> &#8211; an optional string representing a file extension to be
appended to the returned file name</li>
<li><strong>frag_index</strong> &#8211; a fragment archive index, used with .data extension
only, must be a whole number.</li>
<li><strong>ctype_timestamp</strong> &#8211; an optional content-type timestamp, an instance
of <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li><strong>durable</strong> &#8211; if True then include a durable marker in data filename.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a file name</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>DiskFileError</strong> &#8211; if ext==&#8217;.data&#8217; and the kwarg frag_index is not
a whole number</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFileManager.parse_on_disk_filename">
<code class="descname">parse_on_disk_filename</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileManager.parse_on_disk_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns timestamp(s) and other info extracted from a policy specific
file name. For EC policy the data file name includes a fragment index
and possibly a durable marker, both of which which must be stripped off
to retrieve the timestamp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the file name including extension</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>a dict, with keys for timestamp, frag_index, durable, ext and</dt>
<dd>ctype_timestamp:</dd>
</dl>
<ul class="simple">
<li>timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></li>
<li>frag_index is an int or None</li>
<li>ctype_timestamp is a <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a> or
None for .meta files, otherwise None</li>
<li>ext is a string, the file extension including the leading dot or
the empty string if the filename has no extension</li>
<li>durable is a boolean that is True if the filename is a data file
that includes a durable marker</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; if any part of the filename is not able to be
validated.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFileManager.validate_fragment_index">
<code class="descname">validate_fragment_index</code><span class="sig-paren">(</span><em>frag_index</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileManager.validate_fragment_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return int representation of frag_index, or raise a DiskFileError if
frag_index is not a whole number.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>frag_index</strong> &#8211; a fragment archive index</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.ECDiskFileReader">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">ECDiskFileReader</code><span class="sig-paren">(</span><em>fp</em>, <em>data_file</em>, <em>obj_size</em>, <em>etag</em>, <em>disk_chunk_size</em>, <em>keep_cache_size</em>, <em>device_path</em>, <em>logger</em>, <em>quarantine_hook</em>, <em>use_splice</em>, <em>pipe_size</em>, <em>diskfile</em>, <em>keep_cache=False</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileReader" title="swift.obj.diskfile.BaseDiskFileReader"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileReader</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="swift.obj.diskfile.ECDiskFileWriter">
<em class="property">class </em><code class="descclassname">swift.obj.diskfile.</code><code class="descname">ECDiskFileWriter</code><span class="sig-paren">(</span><em>name</em>, <em>datadir</em>, <em>fd</em>, <em>tmppath</em>, <em>bytes_per_sync</em>, <em>diskfile</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#swift.obj.diskfile.BaseDiskFileWriter" title="swift.obj.diskfile.BaseDiskFileWriter"><code class="xref py py-class docutils literal"><span class="pre">swift.obj.diskfile.BaseDiskFileWriter</span></code></a></p>
<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFileWriter.commit">
<code class="descname">commit</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileWriter.commit" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize put by renaming the object data file to include a durable
marker. We do this for EC policy because it requires a 2-phase put
commit confirmation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timestamp</strong> &#8211; object put timestamp, an instance of
<a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>DiskFileError</strong> &#8211; if the diskfile frag_index has not been set
(either during initialisation or a call to put())</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.diskfile.ECDiskFileWriter.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>metadata</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.ECDiskFileWriter.put" title="Permalink to this definition">¶</a></dt>
<dd><p>The only difference between this method and the replication policy
DiskFileWriter method is adding the frag index to the metadata.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>metadata</strong> &#8211; dictionary of metadata to be associated with object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.clear_auditor_status">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">clear_auditor_status</code><span class="sig-paren">(</span><em>devices</em>, <em>auditor_type='ALL'</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.clear_auditor_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.consolidate_hashes">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">consolidate_hashes</code><span class="sig-paren">(</span><em>partition_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.consolidate_hashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Take what&#8217;s in hashes.pkl and hashes.invalid, combine them, write the
result back to hashes.pkl, and clear out hashes.invalid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>suffix_dir</strong> &#8211; absolute path to partition dir containing hashes.pkl
and hashes.invalid</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the hashes, or None if there&#8217;s no hashes.pkl.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.extract_policy">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">extract_policy</code><span class="sig-paren">(</span><em>obj_path</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.extract_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the policy for an object (based on the name of the objects
directory) given the device-relative path to the object. Returns None in
the event that the path is malformed in some way.</p>
<p>The device-relative path is everything after the mount point; for example:</p>
<dl class="docutils">
<dt>/srv/node/d42/objects-5/30/179/</dt>
<dd>485dc017205a81df3af616d917c90179/1401811134.873649.data</dd>
</dl>
<p>would have device-relative path:</p>
<p>objects-5/30/179/485dc017205a81df3af616d917c90179/1401811134.873649.data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obj_path</strong> &#8211; device-relative path of an object, or the full path</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a <a class="reference internal" href="misc.html#swift.common.storage_policy.BaseStoragePolicy" title="swift.common.storage_policy.BaseStoragePolicy"><code class="xref py py-class docutils literal"><span class="pre">BaseStoragePolicy</span></code></a> or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.get_auditor_status">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">get_auditor_status</code><span class="sig-paren">(</span><em>datadir_path</em>, <em>logger</em>, <em>auditor_type</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.get_auditor_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.invalidate_hash">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">invalidate_hash</code><span class="sig-paren">(</span><em>suffix_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.invalidate_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidates the hash for a suffix_dir in the partition&#8217;s hashes file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>suffix_dir</strong> &#8211; absolute path to suffix dir whose hash needs
invalidating</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.object_audit_location_generator">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">object_audit_location_generator</code><span class="sig-paren">(</span><em>devices</em>, <em>mount_check=True</em>, <em>logger=None</em>, <em>device_dirs=None</em>, <em>auditor_type='ALL'</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.object_audit_location_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a devices path (e.g. &#8220;/srv/node&#8221;), yield an AuditLocation for all
objects stored under that directory if device_dirs isn&#8217;t set.  If
device_dirs is set, only yield AuditLocation for the objects under the
entries in device_dirs. The AuditLocation only knows the path to the hash
directory, not to the .data file therein (if any). This is to avoid a
double listdir(hash_dir); the DiskFile object will always do one, so
we don&#8217;t.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>devices</strong> &#8211; parent directory of the devices to be audited</li>
<li><strong>mount_check</strong> &#8211; flag to check if a mount check should be performed
on devices</li>
<li><strong>logger</strong> &#8211; a logger object</li>
<li><strong>device_dirs</strong> &#8211; a list of directories under devices to traverse</li>
<li><strong>auditor_type</strong> &#8211; either ALL or ZBF</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.quarantine_renamer">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">quarantine_renamer</code><span class="sig-paren">(</span><em>device_path</em>, <em>corrupted_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.quarantine_renamer" title="Permalink to this definition">¶</a></dt>
<dd><p>In the case that a file is corrupted, move it to a quarantined
area to allow replication to fix it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Params device_path:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">The path to the device the corrupted file is on.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params corrupted_file_path:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">The path to the file you want quarantined.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">path (str) of directory the file was moved to</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>OSError</strong> &#8211; re-raises non errno.EEXIST / errno.ENOTEMPTY
exceptions from rename</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.read_hashes">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">read_hashes</code><span class="sig-paren">(</span><em>partition_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.read_hashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the existing hashes.pkl</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dict, the suffix hashes (if any), the key &#8216;valid&#8217; will be False
if hashes.pkl is corrupt, cannot be read or does not exist</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.read_metadata">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">read_metadata</code><span class="sig-paren">(</span><em>fd</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.read_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to read the pickled metadata from an object file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fd</strong> &#8211; file descriptor or filename to load the metadata from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary of metadata</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.strip_self">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">strip_self</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.strip_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to attach module level functions to base class.</p>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.update_auditor_status">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">update_auditor_status</code><span class="sig-paren">(</span><em>datadir_path</em>, <em>logger</em>, <em>partitions</em>, <em>auditor_type</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.update_auditor_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.write_hashes">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">write_hashes</code><span class="sig-paren">(</span><em>partition_dir</em>, <em>hashes</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.write_hashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Write hashes to hashes.pkl</p>
<p>The updated key is added to hashes before it is written.</p>
</dd></dl>

<dl class="function">
<dt id="swift.obj.diskfile.write_metadata">
<code class="descclassname">swift.obj.diskfile.</code><code class="descname">write_metadata</code><span class="sig-paren">(</span><em>fd</em>, <em>metadata</em>, <em>xattr_size=65536</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.diskfile.write_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to write pickled metadata for an object file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fd</strong> &#8211; file descriptor or filename to write the metadata</li>
<li><strong>metadata</strong> &#8211; metadata to write</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-swift.obj.replicator">
<span id="id3"></span><span id="object-replicator"></span><h2>Object Replicator<a class="headerlink" href="#module-swift.obj.replicator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swift.obj.replicator.ObjectReplicator">
<em class="property">class </em><code class="descclassname">swift.obj.replicator.</code><code class="descname">ObjectReplicator</code><span class="sig-paren">(</span><em>conf</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">swift.common.daemon.Daemon</span></code></p>
<p>Replicate objects.</p>
<p>Encapsulates most logic and data needed by the object replication process.
Each call to .replicate() performs one replication pass.  It&#8217;s up to the
caller to do this in a loop.</p>
<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.build_replication_jobs">
<code class="descname">build_replication_jobs</code><span class="sig-paren">(</span><em>policy</em>, <em>ips</em>, <em>override_devices=None</em>, <em>override_partitions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.build_replication_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for collect_jobs to build jobs for replication
using replication style storage policy</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.check_ring">
<code class="descname">check_ring</code><span class="sig-paren">(</span><em>object_ring</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.check_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if the ring has been updated
:param object_ring: the ring to check</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean indicating whether or not the ring has changed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.collect_jobs">
<code class="descname">collect_jobs</code><span class="sig-paren">(</span><em>override_devices=None</em>, <em>override_partitions=None</em>, <em>override_policies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.collect_jobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sorted list of jobs (dictionaries) that specify the
partitions, nodes, etc to be rsynced.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>override_devices</strong> &#8211; if set, only jobs on these devices
will be returned</li>
<li><strong>override_partitions</strong> &#8211; if set, only jobs on these partitions
will be returned</li>
<li><strong>override_policies</strong> &#8211; if set, only jobs in these storage
policies will be returned</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.delete_handoff_objs">
<code class="descname">delete_handoff_objs</code><span class="sig-paren">(</span><em>job</em>, <em>delete_objs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.delete_handoff_objs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.delete_partition">
<code class="descname">delete_partition</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.delete_partition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.detect_lockups">
<code class="descname">detect_lockups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.detect_lockups" title="Permalink to this definition">¶</a></dt>
<dd><p>In testing, the pool.waitall() call very occasionally failed to return.
This is an attempt to make sure the replicator finishes its replication
pass in some eventuality.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.heartbeat">
<code class="descname">heartbeat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.heartbeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop that runs in the background during replication.  It periodically
logs progress.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.kill_coros">
<code class="descname">kill_coros</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.kill_coros" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function that kills all coroutines currently running.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.load_object_ring">
<code class="descname">load_object_ring</code><span class="sig-paren">(</span><em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.load_object_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the policy&#8217;s rings are loaded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>policy</strong> &#8211; the StoragePolicy instance</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">appropriate ring object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.replicate">
<code class="descname">replicate</code><span class="sig-paren">(</span><em>override_devices=None</em>, <em>override_partitions=None</em>, <em>override_policies=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.replicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a replication pass</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.rsync">
<code class="descname">rsync</code><span class="sig-paren">(</span><em>node</em>, <em>job</em>, <em>suffixes</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.rsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses rsync to implement the sync method. This was the first
sync method in Swift.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.run_forever">
<code class="descname">run_forever</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.run_forever" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.run_once">
<code class="descname">run_once</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.ssync">
<code class="descname">ssync</code><span class="sig-paren">(</span><em>node</em>, <em>job</em>, <em>suffixes</em>, <em>remote_check_objs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.ssync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.stats_line">
<code class="descname">stats_line</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.stats_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs various stats for the currently running replication pass.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.sync">
<code class="descname">sync</code><span class="sig-paren">(</span><em>node</em>, <em>job</em>, <em>suffixes</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize local suffix directories from a partition with a remote
node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> &#8211; the &#8220;dev&#8221; entry for the remote node to sync with</li>
<li><strong>job</strong> &#8211; information about the partition being synced</li>
<li><strong>suffixes</strong> &#8211; a list of suffixes which need to be pushed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">boolean and dictionary, boolean indicating success or failure</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.update" title="Permalink to this definition">¶</a></dt>
<dd><p>High-level method that replicates a single partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>job</strong> &#8211; a dict containing info about the partition to be replicated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.replicator.ObjectReplicator.update_deleted">
<code class="descname">update_deleted</code><span class="sig-paren">(</span><em>job</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.replicator.ObjectReplicator.update_deleted" title="Permalink to this definition">¶</a></dt>
<dd><p>High-level method that replicates a single partition that doesn&#8217;t
belong on this node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>job</strong> &#8211; a dict containing info about the partition to be replicated</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-swift.obj.ssync_sender"></span><dl class="class">
<dt id="swift.obj.ssync_sender.Sender">
<em class="property">class </em><code class="descclassname">swift.obj.ssync_sender.</code><code class="descname">Sender</code><span class="sig-paren">(</span><em>daemon</em>, <em>node</em>, <em>job</em>, <em>suffixes</em>, <em>remote_check_objs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Sends SSYNC requests to the object server.</p>
<p>These requests are eventually handled by
<a class="reference internal" href="#module-swift.obj.ssync_receiver" title="swift.obj.ssync_receiver"><code class="xref py py-mod docutils literal"><span class="pre">ssync_receiver</span></code></a> and full documentation about the
process is there.</p>
<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishes a connection and starts an SSYNC request
with the object server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.disconnect">
<code class="descname">disconnect</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes down the connection to the object server once done
with the SSYNC request.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.missing_check">
<code class="descname">missing_check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.missing_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the sender-side of the MISSING_CHECK step of a
SSYNC request.</p>
<p>Full documentation of this can be found at
<a class="reference internal" href="#swift.obj.ssync_receiver.Receiver.missing_check" title="swift.obj.ssync_receiver.Receiver.missing_check"><code class="xref py py-meth docutils literal"><span class="pre">Receiver.missing_check()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.readline">
<code class="descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.readline" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a line from the SSYNC response body.</p>
<p>httplib has no readline and will block on read(x) until x is
read, so we have to do the work ourselves. A bit of this is
taken from Python&#8217;s httplib itself.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.send_delete">
<code class="descname">send_delete</code><span class="sig-paren">(</span><em>url_path</em>, <em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.send_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends a DELETE subrequest with the given information.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.send_post">
<code class="descname">send_post</code><span class="sig-paren">(</span><em>url_path</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.send_post" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.send_put">
<code class="descname">send_put</code><span class="sig-paren">(</span><em>url_path</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.send_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends a PUT subrequest for the url_path using the source df
(DiskFile) and content_length.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_sender.Sender.updates">
<code class="descname">updates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.Sender.updates" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the sender-side of the UPDATES step of an SSYNC
request.</p>
<p>Full documentation of this can be found at
<a class="reference internal" href="#swift.obj.ssync_receiver.Receiver.updates" title="swift.obj.ssync_receiver.Receiver.updates"><code class="xref py py-meth docutils literal"><span class="pre">Receiver.updates()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="swift.obj.ssync_sender.decode_wanted">
<code class="descclassname">swift.obj.ssync_sender.</code><code class="descname">decode_wanted</code><span class="sig-paren">(</span><em>parts</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.decode_wanted" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse missing_check line parts to determine which parts of local
diskfile were wanted by the receiver.</p>
<p>The encoder for parts is
<a class="reference internal" href="#swift.obj.ssync_receiver.encode_wanted" title="swift.obj.ssync_receiver.encode_wanted"><code class="xref py py-func docutils literal"><span class="pre">encode_wanted()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="swift.obj.ssync_sender.encode_missing">
<code class="descclassname">swift.obj.ssync_sender.</code><code class="descname">encode_missing</code><span class="sig-paren">(</span><em>object_hash</em>, <em>ts_data</em>, <em>ts_meta=None</em>, <em>ts_ctype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_sender.encode_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representing the object hash, its data file timestamp
and the delta forwards to its metafile and content-type timestamps, if
non-zero, in the form:
<code class="docutils literal"><span class="pre">&lt;hash&gt;</span> <span class="pre">&lt;ts_data&gt;</span> <span class="pre">[m:&lt;hex</span> <span class="pre">delta</span> <span class="pre">to</span> <span class="pre">ts_meta&gt;[,t:&lt;hex</span> <span class="pre">delta</span> <span class="pre">to</span> <span class="pre">ts_ctype&gt;]]</span></code></p>
<p>The decoder for this line is
<a class="reference internal" href="#swift.obj.ssync_receiver.decode_missing" title="swift.obj.ssync_receiver.decode_missing"><code class="xref py py-func docutils literal"><span class="pre">decode_missing()</span></code></a></p>
</dd></dl>

<span class="target" id="module-swift.obj.ssync_receiver"></span><dl class="class">
<dt id="swift.obj.ssync_receiver.Receiver">
<em class="property">class </em><code class="descclassname">swift.obj.ssync_receiver.</code><code class="descname">Receiver</code><span class="sig-paren">(</span><em>app</em>, <em>request</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.Receiver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Handles incoming SSYNC requests to the object server.</p>
<p>These requests come from the object-replicator daemon that uses
<a class="reference internal" href="#module-swift.obj.ssync_sender" title="swift.obj.ssync_sender"><code class="xref py py-mod docutils literal"><span class="pre">ssync_sender</span></code></a>.</p>
<p>The number of concurrent SSYNC requests is restricted by
use of a replication_semaphore and can be configured with the
object-server.conf [object-server] replication_concurrency
setting.</p>
<p>An SSYNC request is really just an HTTP conduit for
sender/receiver replication communication. The overall
SSYNC request should always succeed, but it will contain
multiple requests within its request and response bodies. This
&#8220;hack&#8221; is done so that replication concurrency can be managed.</p>
<p>The general process inside an SSYNC request is:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Initialize the request: Basic request validation, mount check,
acquire semaphore lock, etc..</li>
<li>Missing check: Sender sends the hashes and timestamps of
the object information it can send, receiver sends back
the hashes it wants (doesn&#8217;t have or has an older
timestamp).</li>
<li>Updates: Sender sends the object information requested.</li>
<li>Close down: Release semaphore lock, etc.</li>
</ol>
</div></blockquote>
<dl class="method">
<dt id="swift.obj.ssync_receiver.Receiver.initialize_request">
<code class="descname">initialize_request</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.Receiver.initialize_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic validation of request and mount check.</p>
<p>This function will be called before attempting to acquire a
replication semaphore lock, so contains only quick checks.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_receiver.Receiver.missing_check">
<code class="descname">missing_check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.Receiver.missing_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the receiver-side of the MISSING_CHECK step of a
SSYNC request.</p>
<p>Receives a list of hashes and timestamps of object
information the sender can provide and responds with a list
of hashes desired, either because they&#8217;re missing or have an
older timestamp locally.</p>
<p>The process is generally:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Sender sends <cite>:MISSING_CHECK: START</cite> and begins
sending <cite>hash timestamp</cite> lines.</p>
</li>
<li><p class="first">Receiver gets <cite>:MISSING_CHECK: START</cite> and begins
reading the <cite>hash timestamp</cite> lines, collecting the
hashes of those it desires.</p>
</li>
<li><p class="first">Sender sends <cite>:MISSING_CHECK: END</cite>.</p>
</li>
<li><p class="first">Receiver gets <cite>:MISSING_CHECK: END</cite>, responds with
<cite>:MISSING_CHECK: START</cite>, followed by the list of
&lt;wanted_hash&gt; specifiers it collected as being wanted
(one per line), <cite>:MISSING_CHECK: END</cite>, and flushes any
buffers.</p>
<p>Each &lt;wanted_hash&gt; specifier has the form &lt;hash&gt;[ &lt;parts&gt;] where
&lt;parts&gt; is a string containing characters &#8216;d&#8217; and/or &#8216;m&#8217;
indicating that only data or meta part of object respectively is
required to be sync&#8217;d.</p>
</li>
<li><p class="first">Sender gets <cite>:MISSING_CHECK: START</cite> and reads the list
of hashes desired by the receiver until reading
<cite>:MISSING_CHECK: END</cite>.</p>
</li>
</ol>
</div></blockquote>
<p>The collection and then response is so the sender doesn&#8217;t
have to read while it writes to ensure network buffers don&#8217;t
fill up and block everything.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.ssync_receiver.Receiver.updates">
<code class="descname">updates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.Receiver.updates" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles the UPDATES step of an SSYNC request.</p>
<p>Receives a set of PUT and DELETE subrequests that will be
routed to the object server itself for processing. These
contain the information requested by the MISSING_CHECK step.</p>
<p>The PUT and DELETE subrequests are formatted pretty much
exactly like regular HTTP requests, excepting the HTTP
version on the first request line.</p>
<p>The process is generally:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Sender sends <cite>:UPDATES: START</cite> and begins sending the
PUT and DELETE subrequests.</li>
<li>Receiver gets <cite>:UPDATES: START</cite> and begins routing the
subrequests to the object server.</li>
<li>Sender sends <cite>:UPDATES: END</cite>.</li>
<li>Receiver gets <cite>:UPDATES: END</cite> and sends <cite>:UPDATES:
START</cite> and <cite>:UPDATES: END</cite> (assuming no errors).</li>
<li>Sender gets <cite>:UPDATES: START</cite> and <cite>:UPDATES: END</cite>.</li>
</ol>
</div></blockquote>
<p>If too many subrequests fail, as configured by
replication_failure_threshold and replication_failure_ratio,
the receiver will hang up the request early so as to not
waste any more time.</p>
<p>At step 4, the receiver will send back an error if there were
any failures (that didn&#8217;t cause a hangup due to the above
thresholds) so the sender knows the whole was not entirely a
success. This is so the sender knows if it can remove an out
of place partition, for example.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="swift.obj.ssync_receiver.decode_missing">
<code class="descclassname">swift.obj.ssync_receiver.</code><code class="descname">decode_missing</code><span class="sig-paren">(</span><em>line</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.decode_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a string of the form generated by
<a class="reference internal" href="#swift.obj.ssync_sender.encode_missing" title="swift.obj.ssync_sender.encode_missing"><code class="xref py py-func docutils literal"><span class="pre">encode_missing()</span></code></a> and return a dict
with keys <code class="docutils literal"><span class="pre">object_hash</span></code>, <code class="docutils literal"><span class="pre">ts_data</span></code>, <code class="docutils literal"><span class="pre">ts_meta</span></code>, <code class="docutils literal"><span class="pre">ts_ctype</span></code>.</p>
<p>The encoder for this line is
<a class="reference internal" href="#swift.obj.ssync_sender.encode_missing" title="swift.obj.ssync_sender.encode_missing"><code class="xref py py-func docutils literal"><span class="pre">encode_missing()</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="swift.obj.ssync_receiver.encode_wanted">
<code class="descclassname">swift.obj.ssync_receiver.</code><code class="descname">encode_wanted</code><span class="sig-paren">(</span><em>remote</em>, <em>local</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.ssync_receiver.encode_wanted" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare a remote and local results and generate a wanted line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remote</strong> &#8211; a dict, with ts_data and ts_meta keys in the form
returned by <a class="reference internal" href="#swift.obj.ssync_receiver.decode_missing" title="swift.obj.ssync_receiver.decode_missing"><code class="xref py py-func docutils literal"><span class="pre">decode_missing()</span></code></a></li>
<li><strong>local</strong> &#8211; a dict, possibly empty, with ts_data and ts_meta keys
in the form returned <code class="xref py py-meth docutils literal"><span class="pre">Receiver._check_local()</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The decoder for this line is
<a class="reference internal" href="#swift.obj.ssync_sender.decode_wanted" title="swift.obj.ssync_sender.decode_wanted"><code class="xref py py-func docutils literal"><span class="pre">decode_wanted()</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-swift.obj.server">
<span id="id4"></span><span id="object-server"></span><h2>Object Server<a class="headerlink" href="#module-swift.obj.server" title="Permalink to this headline">¶</a></h2>
<p>Object Server for Swift</p>
<dl class="class">
<dt id="swift.obj.server.EventletPlungerString">
<em class="property">class </em><code class="descclassname">swift.obj.server.</code><code class="descname">EventletPlungerString</code><a class="headerlink" href="#swift.obj.server.EventletPlungerString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">str</span></code></p>
<p>Eventlet won&#8217;t send headers until it&#8217;s accumulated at least
eventlet.wsgi.MINIMUM_CHUNK_SIZE bytes or the app iter is exhausted. If we
want to send the response body behind Eventlet&#8217;s back, perhaps with some
zero-copy wizardry, then we have to unclog the plumbing in eventlet.wsgi
to force the headers out, so we use an EventletPlungerString to empty out
all of Eventlet&#8217;s buffers.</p>
</dd></dl>

<dl class="class">
<dt id="swift.obj.server.ObjectController">
<em class="property">class </em><code class="descclassname">swift.obj.server.</code><code class="descname">ObjectController</code><span class="sig-paren">(</span><em>conf</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">swift.common.base_storage_server.BaseStorageServer</span></code></p>
<p>Implements the WSGI application for the Swift Object Server.</p>
<dl class="method">
<dt id="swift.obj.server.ObjectController.DELETE">
<code class="descname">DELETE</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.DELETE" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle HTTP DELETE requests for the Swift Object Server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.GET">
<code class="descname">GET</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.GET" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle HTTP GET requests for the Swift Object Server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.HEAD">
<code class="descname">HEAD</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.HEAD" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle HTTP HEAD requests for the Swift Object Server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.POST">
<code class="descname">POST</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.POST" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle HTTP POST requests for the Swift Object Server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.PUT">
<code class="descname">PUT</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.PUT" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle HTTP PUT requests for the Swift Object Server.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.REPLICATE">
<code class="descname">REPLICATE</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.REPLICATE" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle REPLICATE requests for the Swift Object Server.  This is used
by the object replicator to get hashes for directories.</p>
<p>Note that the name REPLICATE is preserved for historical reasons as
this verb really just returns the hashes information for the specified
parameters and is used, for example, by both replication and EC.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.SSYNC">
<code class="descname">SSYNC</code><span class="sig-paren">(</span><em>ctrl</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.SSYNC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.async_update">
<code class="descname">async_update</code><span class="sig-paren">(</span><em>op</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>host</em>, <em>partition</em>, <em>contdevice</em>, <em>headers_out</em>, <em>objdevice</em>, <em>policy</em>, <em>logger_thread_locals=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.async_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends or saves an async update.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> &#8211; operation performed (ex: &#8216;PUT&#8217;, or &#8216;DELETE&#8217;)</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name</li>
<li><strong>host</strong> &#8211; host that the container is on</li>
<li><strong>partition</strong> &#8211; partition that the container is on</li>
<li><strong>contdevice</strong> &#8211; device name that the container is on</li>
<li><strong>headers_out</strong> &#8211; dictionary of headers to send in the container
request</li>
<li><strong>objdevice</strong> &#8211; device name that the object is in</li>
<li><strong>policy</strong> &#8211; the associated BaseStoragePolicy instance</li>
<li><strong>logger_thread_locals</strong> &#8211; The thread local values to be set on the
self.logger to retain transaction
logging information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.container_update">
<code class="descname">container_update</code><span class="sig-paren">(</span><em>op</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>request</em>, <em>headers_out</em>, <em>objdevice</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.container_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the container when objects are updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> &#8211; operation performed (ex: &#8216;PUT&#8217;, or &#8216;DELETE&#8217;)</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name</li>
<li><strong>request</strong> &#8211; the original request object driving the update</li>
<li><strong>headers_out</strong> &#8211; dictionary of headers to send in the container
request(s)</li>
<li><strong>objdevice</strong> &#8211; device name that the object is in</li>
<li><strong>policy</strong> &#8211; the BaseStoragePolicy instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.delete_at_update">
<code class="descname">delete_at_update</code><span class="sig-paren">(</span><em>op</em>, <em>delete_at</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>request</em>, <em>objdevice</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.delete_at_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the expiring objects container when objects are updated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>op</strong> &#8211; operation performed (ex: &#8216;PUT&#8217;, or &#8216;DELETE&#8217;)</li>
<li><strong>delete_at</strong> &#8211; scheduled delete in UNIX seconds, int</li>
<li><strong>account</strong> &#8211; account name for the object</li>
<li><strong>container</strong> &#8211; container name for the object</li>
<li><strong>obj</strong> &#8211; object name</li>
<li><strong>request</strong> &#8211; the original request driving the update</li>
<li><strong>objdevice</strong> &#8211; device name that the object is in</li>
<li><strong>policy</strong> &#8211; the BaseStoragePolicy instance (used for tmp dir)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.get_diskfile">
<code class="descname">get_diskfile</code><span class="sig-paren">(</span><em>device</em>, <em>partition</em>, <em>account</em>, <em>container</em>, <em>obj</em>, <em>policy</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.get_diskfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility method for instantiating a DiskFile object supporting a given
REST API.</p>
<p>An implementation of the object server that wants to use a different
DiskFile class would simply over-ride this method to provide that
behavior.</p>
</dd></dl>

<dl class="attribute">
<dt id="swift.obj.server.ObjectController.server_type">
<code class="descname">server_type</code><em class="property"> = 'object-server'</em><a class="headerlink" href="#swift.obj.server.ObjectController.server_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="swift.obj.server.ObjectController.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>conf</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.ObjectController.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation specific setup. This method is called at the very end
by the constructor to allow a specific implementation to modify
existing attributes or add its own attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conf</strong> &#8211; WSGI configuration parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="swift.obj.server.app_factory">
<code class="descclassname">swift.obj.server.</code><code class="descname">app_factory</code><span class="sig-paren">(</span><em>global_conf</em>, <em>**local_conf</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.app_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>paste.deploy app factory for creating WSGI object server apps</p>
</dd></dl>

<dl class="function">
<dt id="swift.obj.server.drain">
<code class="descclassname">swift.obj.server.</code><code class="descname">drain</code><span class="sig-paren">(</span><em>file_like</em>, <em>read_size</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.drain" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and discard any bytes from file_like.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_like</strong> &#8211; file-like object to read from</li>
<li><strong>read_size</strong> &#8211; how big a chunk to read at a time</li>
<li><strong>timeout</strong> &#8211; how long to wait for a read (use None for no timeout)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ChunkReadTimeout</strong> &#8211; if no chunk was read in time</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.server.global_conf_callback">
<code class="descclassname">swift.obj.server.</code><code class="descname">global_conf_callback</code><span class="sig-paren">(</span><em>preloaded_app_conf</em>, <em>global_conf</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.global_conf_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback for swift.common.wsgi.run_wsgi during the global_conf
creation so that we can add our replication_semaphore, used to
limit the number of concurrent SSYNC_REQUESTS across all
workers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>preloaded_app_conf</strong> &#8211; The preloaded conf for the WSGI app.
This conf instance will go away, so
just read from it, don&#8217;t write.</li>
<li><strong>global_conf</strong> &#8211; The global conf that will eventually be
passed to the app_factory function later.
This conf is created before the worker
subprocesses are forked, so can be useful to
set up semaphores, shared memory, etc.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="swift.obj.server.iter_mime_headers_and_bodies">
<code class="descclassname">swift.obj.server.</code><code class="descname">iter_mime_headers_and_bodies</code><span class="sig-paren">(</span><em>wsgi_input</em>, <em>mime_boundary</em>, <em>read_chunk_size</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.server.iter_mime_headers_and_bodies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-swift.obj.updater">
<span id="id5"></span><span id="object-updater"></span><h2>Object Updater<a class="headerlink" href="#module-swift.obj.updater" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="swift.obj.updater.ObjectUpdater">
<em class="property">class </em><code class="descclassname">swift.obj.updater.</code><code class="descname">ObjectUpdater</code><span class="sig-paren">(</span><em>conf</em>, <em>logger=None</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">swift.common.daemon.Daemon</span></code></p>
<p>Update object information in container listings.</p>
<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.get_container_ring">
<code class="descname">get_container_ring</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.get_container_ring" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the container ring.  Load it, if it hasn&#8217;t been yet.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.object_sweep">
<code class="descname">object_sweep</code><span class="sig-paren">(</span><em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.object_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>If there are async pendings on the device, walk each one and update.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>device</strong> &#8211; path to device</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.object_update">
<code class="descname">object_update</code><span class="sig-paren">(</span><em>node</em>, <em>part</em>, <em>op</em>, <em>obj</em>, <em>headers_out</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.object_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the object update to the container</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>node</strong> &#8211; node dictionary from the container ring</li>
<li><strong>part</strong> &#8211; partition that holds the container</li>
<li><strong>op</strong> &#8211; operation performed (ex: &#8216;PUT&#8217; or &#8216;DELETE&#8217;)</li>
<li><strong>obj</strong> &#8211; object name being updated</li>
<li><strong>headers_out</strong> &#8211; headers to send with the update</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.process_object_update">
<code class="descname">process_object_update</code><span class="sig-paren">(</span><em>update_path</em>, <em>device</em>, <em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.process_object_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the object information to be updated and update.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>update_path</strong> &#8211; path to pickled object update file</li>
<li><strong>device</strong> &#8211; path to device</li>
<li><strong>policy</strong> &#8211; storage policy of object update</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.run_forever">
<code class="descname">run_forever</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.run_forever" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the updater continuously.</p>
</dd></dl>

<dl class="method">
<dt id="swift.obj.updater.ObjectUpdater.run_once">
<code class="descname">run_once</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#swift.obj.updater.ObjectUpdater.run_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the updater once.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="swift.obj.updater.random">
<code class="descclassname">swift.obj.updater.</code><code class="descname">random</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; x in the interval [0, 1).<a class="headerlink" href="#swift.obj.updater.random" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Object</a><ul>
<li><a class="reference internal" href="#module-swift.obj.auditor">Object Auditor</a></li>
<li><a class="reference internal" href="#module-swift.obj.diskfile">Object Backend</a></li>
<li><a class="reference internal" href="#module-swift.obj.replicator">Object Replicator</a></li>
<li><a class="reference internal" href="#module-swift.obj.server">Object Server</a></li>
<li><a class="reference internal" href="#module-swift.obj.updater">Object Updater</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="db.html"
                                  title="previous chapter">Account DB and Container DB</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="misc.html"
                                  title="next chapter">Misc</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/swift
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/object.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="misc.html" title="Misc"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="db.html" title="Account DB and Container DB"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">swift 2.12.1.dev102 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, OpenStack Foundation.
      Last updated on &#39;Tue Feb 14 07:57:22 2017, commit 7cb6882&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/swift");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>