<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Administrator’s Guide &mdash; swift 2.12.1.dev102 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.12.1.dev102',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="swift 2.12.1.dev102 documentation" href="index.html" />
    <link rel="next" title="Dedicated replication network" href="replication_network.html" />
    <link rel="prev" title="Apache Deployment Guide" href="apache_deployment_guide.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="administrator-s-guide">
<h1>Administrator&#8217;s Guide<a class="headerlink" href="#administrator-s-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="defining-storage-policies">
<h2>Defining Storage Policies<a class="headerlink" href="#defining-storage-policies" title="Permalink to this headline">¶</a></h2>
<p>Defining your Storage Policies is very easy to do with Swift.  It is important
that the administrator understand the concepts behind Storage Policies
before actually creating and using them in order to get the most benefit out
of the feature and, more importantly, to avoid having to make unnecessary changes
once a set of policies have been deployed to a cluster.</p>
<p>It is highly recommended that the reader fully read and comprehend
<a class="reference internal" href="overview_policies.html"><em>Storage Policies</em></a> before proceeding with administration of
policies.  Plan carefully and it is suggested that experimentation be
done first on a non-production cluster to be certain that the desired
configuration meets the needs of the users.  See <a class="reference internal" href="overview_policies.html#upgrade-policy"><span>Upgrading and Confirming Functionality</span></a>
before planning the upgrade of your existing deployment.</p>
<p>Following is a high level view of the very few steps it takes to configure
policies once you have decided what you want to do:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Define your policies in <code class="docutils literal"><span class="pre">/etc/swift/swift.conf</span></code></li>
<li>Create the corresponding object rings</li>
<li>Communicate the names of the Storage Policies to cluster users</li>
</ol>
</div></blockquote>
<p>For a specific example that takes you through these steps, please see
<a class="reference internal" href="policies_saio.html"><em>Adding Storage Policies to an Existing SAIO</em></a></p>
</div>
<div class="section" id="managing-the-rings">
<h2>Managing the Rings<a class="headerlink" href="#managing-the-rings" title="Permalink to this headline">¶</a></h2>
<p>You may build the storage rings on any server with the appropriate
version of Swift installed.  Once built or changed (rebalanced), you
must distribute the rings to all the servers in the cluster.  Storage
rings contain information about all the Swift storage partitions and
how they are distributed between the different nodes and disks.</p>
<p>Swift 1.6.0 is the last version to use a Python pickle format.
Subsequent versions use a different serialization format.  <strong>Rings
generated by Swift versions 1.6.0 and earlier may be read by any
version, but rings generated after 1.6.0 may only be read by Swift
versions greater than 1.6.0.</strong>  So when upgrading from version 1.6.0 or
earlier to a version greater than 1.6.0, either upgrade Swift on your
ring building server <strong>last</strong> after all Swift nodes have been successfully
upgraded, or refrain from generating rings until all Swift nodes have
been successfully upgraded.</p>
<p>If you need to downgrade from a version of swift greater than 1.6.0 to
a version less than or equal to 1.6.0, first downgrade your ring-building
server, generate new rings, push them out, then continue with the rest
of the downgrade.</p>
<p>For more information see <a class="reference internal" href="overview_ring.html"><em>The Rings</em></a>.</p>
<p>Removing a device from the ring:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>swift-ring-builder &lt;builder-file&gt; remove &lt;ip_address&gt;/&lt;device_name&gt;
</pre></div>
</div>
<p>Removing a server from the ring:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>swift-ring-builder &lt;builder-file&gt; remove &lt;ip_address&gt;
</pre></div>
</div>
<p>Adding devices to the ring:</p>
<p>See <a class="reference internal" href="deployment_guide.html#ring-preparing"><span>Preparing the Ring</span></a></p>
<p>See what devices for a server are in the ring:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>swift-ring-builder &lt;builder-file&gt; search &lt;ip_address&gt;
</pre></div>
</div>
<p>Once you are done with all changes to the ring, the changes need to be
&#8220;committed&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">swift</span><span class="o">-</span><span class="n">ring</span><span class="o">-</span><span class="n">builder</span> <span class="o">&lt;</span><span class="n">builder</span><span class="o">-</span><span class="nb">file</span><span class="o">&gt;</span> <span class="n">rebalance</span>
</pre></div>
</div>
<p>Once the new rings are built, they should be pushed out to all the servers
in the cluster.</p>
<p>Optionally, if invoked as &#8216;swift-ring-builder-safe&#8217; the directory containing
the specified builder file will be locked (via a .lock file in the parent
directory). This provides a basic safe guard against multiple instances
of the swift-ring-builder (or other utilities that observe this lock) from
attempting to write to or read the builder/ring files while operations are in
progress. This can be useful in environments where ring management has been
automated but the operator still needs to interact with the rings manually.</p>
<p>If the ring builder is not producing the balances that you are
expecting, you can gain visibility into what it&#8217;s doing with the
<code class="docutils literal"><span class="pre">--debug</span></code> flag.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">swift</span><span class="o">-</span><span class="n">ring</span><span class="o">-</span><span class="n">builder</span> <span class="o">&lt;</span><span class="n">builder</span><span class="o">-</span><span class="nb">file</span><span class="o">&gt;</span> <span class="n">rebalance</span> <span class="o">--</span><span class="n">debug</span>
</pre></div>
</div>
<p>This produces a great deal of output that is mostly useful if you are
either (a) attempting to fix the ring builder, or (b) filing a bug
against the ring builder.</p>
<p>You may notice in the rebalance output a &#8216;dispersion&#8217; number. What this
number means is explained in <a class="reference internal" href="overview_ring.html#ring-dispersion"><span>Dispersion</span></a> but in essence
is the percentage of partitions in the ring that have too many replicas
within a particular failure domain. You can ask &#8216;swift-ring-builder&#8217; what
the dispersion is with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">swift</span><span class="o">-</span><span class="n">ring</span><span class="o">-</span><span class="n">builder</span> <span class="o">&lt;</span><span class="n">builder</span><span class="o">-</span><span class="nb">file</span><span class="o">&gt;</span> <span class="n">dispersion</span>
</pre></div>
</div>
<p>This will give you the percentage again, if you want a detailed view of
the dispersion simply add a <code class="docutils literal"><span class="pre">--verbose</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">swift</span><span class="o">-</span><span class="n">ring</span><span class="o">-</span><span class="n">builder</span> <span class="o">&lt;</span><span class="n">builder</span><span class="o">-</span><span class="nb">file</span><span class="o">&gt;</span> <span class="n">dispersion</span> <span class="o">--</span><span class="n">verbose</span>
</pre></div>
</div>
<p>This will not only display the percentage but will also display a dispersion
table that lists partition dispersion by tier. You can use this table to figure
out were you need to add capacity or to help tune an <a class="reference internal" href="overview_ring.html#ring-overload"><span>Overload</span></a> value.</p>
<p>Now let&#8217;s take an example with 1 region, 3 zones and 4 devices. Each device has
the same weight, and the <code class="docutils literal"><span class="pre">dispersion</span> <span class="pre">--verbose</span></code> might show the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>Dispersion is 50.000000, Balance is 0.000000, Overload is 0.00%
Required overload is 33.333333%
Worst tier is 50.000000 (r1z3)
--------------------------------------------------------------------------
Tier                           Parts      %    Max     0     1     2     3
--------------------------------------------------------------------------
r1                               256   0.00      3     0     0     0   256
r1z1                             192   0.00      1    64   192     0     0
r1z1-127.0.0.1                   192   0.00      1    64   192     0     0
r1z1-127.0.0.1/sda               192   0.00      1    64   192     0     0
r1z2                             192   0.00      1    64   192     0     0
r1z2-127.0.0.2                   192   0.00      1    64   192     0     0
r1z2-127.0.0.2/sda               192   0.00      1    64   192     0     0
r1z3                             256  50.00      1     0   128   128     0
r1z3-127.0.0.3                   256  50.00      1     0   128   128     0
r1z3-127.0.0.3/sda               192   0.00      1    64   192     0     0
r1z3-127.0.0.3/sdb               192   0.00      1    64   192     0     0
</pre></div>
</div>
<p>The first line reports that there are 256 partitions with 3 copies in region 1;
and this is an expected output in this case (single region with 3 replicas) as
reported by the &#8220;Max&#8221; value.</p>
<p>However, there is some imbalance in the cluster, more precisely in zone 3. The
&#8220;Max&#8221; reports a maximum of 1 copy in this zone; however 50.00% of the partitions
are storing 2 replicas in this zone (which is somewhat expected, because there
are more disks in this zone).</p>
<p>You can now either add more capacity to the other zones, decrease the total
weight in zone 3 or set the overload to a value <cite>greater than</cite> 33.333333% -
only as much overload as needed will be used.</p>
</div>
<div class="section" id="scripting-ring-creation">
<h2>Scripting Ring Creation<a class="headerlink" href="#scripting-ring-creation" title="Permalink to this headline">¶</a></h2>
<p>You can create scripts to create the account and container rings and rebalance. Here&#8217;s an example script for the Account ring. Use similar commands to create a make-container-ring.sh script on the proxy server node.</p>
<ol class="arabic">
<li><p class="first">Create a script file called make-account-ring.sh on the proxy
server node with the following content:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>#!/bin/bash
cd /etc/swift
rm -f account.builder account.ring.gz backups/account.builder backups/account.ring.gz
swift-ring-builder account.builder create 18 3 1
swift-ring-builder account.builder add r1z1-&lt;account-server-1&gt;:6202/sdb1 1
swift-ring-builder account.builder add r1z2-&lt;account-server-2&gt;:6202/sdb1 1
swift-ring-builder account.builder rebalance
</pre></div>
</div>
<p>You need to replace the values of &lt;account-server-1&gt;,
&lt;account-server-2&gt;, etc. with the IP addresses of the account
servers used in your setup. You can have as many account servers as
you need. All account servers are assumed to be listening on port
6202, and have a storage device called &#8220;sdb1&#8221; (this is a directory
name created under /drives when we setup the account server). The
&#8220;z1&#8221;, &#8220;z2&#8221;, etc. designate zones, and you can choose whether you
put devices in the same or different zones. The &#8220;r1&#8221; designates
the region, with different regions specified as &#8220;r1&#8221;, &#8220;r2&#8221;, etc.</p>
</li>
<li><p class="first">Make the script file executable and run it to create the account ring file:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>chmod +x make-account-ring.sh
sudo ./make-account-ring.sh
</pre></div>
</div>
</li>
<li><p class="first">Copy the resulting ring file /etc/swift/account.ring.gz to all the
account server nodes in your Swift environment, and put them in the
/etc/swift directory on these nodes. Make sure that every time you
change the account ring configuration, you copy the resulting ring
file to all the account nodes.</p>
</li>
</ol>
</div>
<div class="section" id="handling-system-updates">
<h2>Handling System Updates<a class="headerlink" href="#handling-system-updates" title="Permalink to this headline">¶</a></h2>
<p>It is recommended that system updates and reboots are done a zone at a time.
This allows the update to happen, and for the Swift cluster to stay available
and responsive to requests.  It is also advisable when updating a zone, let
it run for a while before updating the other zones to make sure the update
doesn&#8217;t have any adverse effects.</p>
</div>
<div class="section" id="handling-drive-failure">
<h2>Handling Drive Failure<a class="headerlink" href="#handling-drive-failure" title="Permalink to this headline">¶</a></h2>
<p>In the event that a drive has failed, the first step is to make sure the drive
is unmounted.  This will make it easier for swift to work around the failure
until it has been resolved.  If the drive is going to be replaced immediately,
then it is just best to replace the drive, format it, remount it, and let
replication fill it up.</p>
<p>After the drive is unmounted, make sure the mount point is owned by root
(root:root 755). This ensures that rsync will not try to replicate into the
root drive once the failed drive is unmounted.</p>
<p>If the drive can&#8217;t be replaced immediately, then it is best to leave it
unmounted, and set the device weight to 0. This will allow all the
replicas that were on that drive to be replicated elsewhere until the drive
is replaced. Once the drive is replaced, the device weight can be increased
again. Setting the device weight to 0 instead of removing the drive from the
ring gives Swift the chance to replicate data from the failing disk too (in case
it is still possible to read some of the data).</p>
<p>Setting the device weight to 0 (or removing a failed drive from the ring) has
another benefit: all partitions that were stored on the failed drive are
distributed over the remaining disks in the cluster, and each disk only needs to
store a few new partitions. This is much faster compared to replicating all
partitions to a single, new disk. It decreases the time to recover from a
degraded number of replicas significantly, and becomes more and more important
with bigger disks.</p>
</div>
<div class="section" id="handling-server-failure">
<h2>Handling Server Failure<a class="headerlink" href="#handling-server-failure" title="Permalink to this headline">¶</a></h2>
<p>If a server is having hardware issues, it is a good idea to make sure the
swift services are not running.  This will allow Swift to work around the
failure while you troubleshoot.</p>
<p>If the server just needs a reboot, or a small amount of work that should
only last a couple of hours, then it is probably best to let Swift work
around the failure and get the machine fixed and back online.  When the
machine comes back online, replication will make sure that anything that is
missing during the downtime will get updated.</p>
<p>If the server has more serious issues, then it is probably best to remove
all of the server&#8217;s devices from the ring.  Once the server has been repaired
and is back online, the server&#8217;s devices can be added back into the ring.
It is important that the devices are reformatted before putting them back
into the ring as it is likely to be responsible for a different set of
partitions than before.</p>
</div>
<div class="section" id="detecting-failed-drives">
<h2>Detecting Failed Drives<a class="headerlink" href="#detecting-failed-drives" title="Permalink to this headline">¶</a></h2>
<p>It has been our experience that when a drive is about to fail, error messages
will spew into <cite>/var/log/kern.log</cite>.  There is a script called
<cite>swift-drive-audit</cite> that can be run via cron to watch for bad drives.  If
errors are detected, it will unmount the bad drive, so that Swift can
work around it.  The script takes a configuration file with the following
settings:</p>
<p>[drive-audit]</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="19%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Option</td>
<td>Default</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>user</td>
<td>swift</td>
<td>Drop privileges to this user for non-root
tasks</td>
</tr>
<tr class="row-odd"><td>log_facility</td>
<td>LOG_LOCAL0</td>
<td>Syslog log facility</td>
</tr>
<tr class="row-even"><td>log_level</td>
<td>INFO</td>
<td>Log level</td>
</tr>
<tr class="row-odd"><td>device_dir</td>
<td>/srv/node</td>
<td>Directory devices are mounted under</td>
</tr>
<tr class="row-even"><td>minutes</td>
<td>60</td>
<td>Number of minutes to look back in
<cite>/var/log/kern.log</cite></td>
</tr>
<tr class="row-odd"><td>error_limit</td>
<td>1</td>
<td>Number of errors to find before a device
is unmounted</td>
</tr>
<tr class="row-even"><td>log_file_pattern</td>
<td>/var/log/kern*</td>
<td>Location of the log file with globbing
pattern to check against device errors</td>
</tr>
<tr class="row-odd"><td>regex_pattern_X</td>
<td>(see below)</td>
<td>Regular expression patterns to be used to
locate device blocks with errors in the
log file</td>
</tr>
</tbody>
</table>
<p>The default regex pattern used to locate device blocks with errors are
<cite>berrorb.*b(sd[a-z]{1,2}d?)b</cite> and <cite>b(sd[a-z]{1,2}d?)b.*berrorb</cite>.
One is able to overwrite the default above by providing new expressions
using the format <cite>regex_pattern_X = regex_expression</cite>, where <cite>X</cite> is a number.</p>
<p>This script has been tested on Ubuntu 10.04 and Ubuntu 12.04, so if you are
using a different distro or OS, some care should be taken before using in production.</p>
</div>
<div class="section" id="preventing-disk-full-scenarios">
<h2>Preventing Disk Full Scenarios<a class="headerlink" href="#preventing-disk-full-scenarios" title="Permalink to this headline">¶</a></h2>
<p>Prevent disk full scenarios by ensuring that the <code class="docutils literal"><span class="pre">proxy-server</span></code> blocks PUT
requests and rsync prevents replication to the specific drives.</p>
<p>You can prevent <cite>proxy-server</cite> PUT requests to low space disks by ensuring
<code class="docutils literal"><span class="pre">fallocate_reserve</span></code> is set in the <code class="docutils literal"><span class="pre">object-server.conf</span></code>. By default,
<code class="docutils literal"><span class="pre">fallocate_reserve</span></code> is set to 1%. This blocks PUT requests that leave the
free disk space below 1% of the disk.</p>
<p>In order to prevent rsync replication to specific drives, firstly
setup <code class="docutils literal"><span class="pre">rsync_module</span></code> per disk in your <code class="docutils literal"><span class="pre">object-replicator</span></code>.
Set this in <code class="docutils literal"><span class="pre">object-server.conf</span></code>:</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span>[object-replicator]
rsync_module = {replication_ip}::object_{device}
</pre></div>
</div>
<p>Set the individual drives in <code class="docutils literal"><span class="pre">rsync.conf</span></code>. For example:</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span>[object_sda]
max connections = 4
lock file = /var/lock/object_sda.lock

[object_sdb]
max connections = 4
lock file = /var/lock/object_sdb.lock
</pre></div>
</div>
<p>Finally, monitor the disk space of each disk and adjust the rsync
<code class="docutils literal"><span class="pre">max</span> <span class="pre">connections</span></code> per drive to <code class="docutils literal"><span class="pre">-1</span></code>. We recommend utilising your existing
monitoring solution to achieve this. The following is an example script:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">errno</span>

<span class="n">RESERVE</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">20</span>  <span class="c1"># 500 MiB</span>

<span class="n">DEVICES</span> <span class="o">=</span> <span class="s1">&#39;/srv/node1&#39;</span>

<span class="n">path_template</span> <span class="o">=</span> <span class="s1">&#39;/etc/rsync.d/disable_</span><span class="si">%s</span><span class="s1">.conf&#39;</span>
<span class="n">config_template</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">[object_</span><span class="si">%s</span><span class="s1">]</span>
<span class="s1">max connections = -1</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">disable_rsync</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_template</span> <span class="o">%</span> <span class="n">device</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">config_template</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span> <span class="o">%</span> <span class="n">device</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">enable_rsync</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">path_template</span> <span class="o">%</span> <span class="n">device</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># ignore file does not exist</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
            <span class="k">raise</span>


<span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">DEVICES</span><span class="p">):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">DEVICES</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">statvfs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">f_bavail</span> <span class="o">*</span> <span class="n">st</span><span class="o">.</span><span class="n">f_frsize</span>
    <span class="k">if</span> <span class="n">free</span> <span class="o">&lt;</span> <span class="n">RESERVE</span><span class="p">:</span>
        <span class="n">disable_rsync</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">enable_rsync</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<p>For the above script to work, ensure <code class="docutils literal"><span class="pre">/etc/rsync.d/</span></code> conf files are
included, by specifying <code class="docutils literal"><span class="pre">&amp;include</span></code> in your <code class="docutils literal"><span class="pre">rsync.conf</span></code> file:</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span>&amp;include /etc/rsync.d
</pre></div>
</div>
<p>Use this in conjunction with a cron job to periodically run the script, for example:</p>
<div class="code highlight-python"><div class="highlight"><pre><span></span># /etc/cron.d/devicecheck
* * * * * root /some/path/to/disable_rsync.py
</pre></div>
</div>
</div>
<div class="section" id="dispersion-report">
<span id="id1"></span><h2>Dispersion Report<a class="headerlink" href="#dispersion-report" title="Permalink to this headline">¶</a></h2>
<p>There is a swift-dispersion-report tool for measuring overall cluster health.
This is accomplished by checking if a set of deliberately distributed
containers and objects are currently in their proper places within the cluster.</p>
<p>For instance, a common deployment has three replicas of each object. The health
of that object can be measured by checking if each replica is in its proper
place. If only 2 of the 3 is in place the object&#8217;s heath can be said to be at
66.66%, where 100% would be perfect.</p>
<p>A single object&#8217;s health, especially an older object, usually reflects the
health of that entire partition the object is in. If we make enough objects on
a distinct percentage of the partitions in the cluster, we can get a pretty
valid estimate of the overall cluster health. In practice, about 1% partition
coverage seems to balance well between accuracy and the amount of time it takes
to gather results.</p>
<p>The first thing that needs to be done to provide this health value is create a
new account solely for this usage. Next, we need to place the containers and
objects throughout the system so that they are on distinct partitions. The
swift-dispersion-populate tool does this by making up random container and
object names until they fall on distinct partitions. Last, and repeatedly for
the life of the cluster, we need to run the swift-dispersion-report tool to
check the health of each of these containers and objects.</p>
<p>These tools need direct access to the entire cluster and to the ring files
(installing them on a proxy server will probably do). Both
swift-dispersion-populate and swift-dispersion-report use the same
configuration file, /etc/swift/dispersion.conf. Example conf file:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>[dispersion]
auth_url = http://localhost:8080/auth/v1.0
auth_user = test:tester
auth_key = testing
endpoint_type = internalURL
</pre></div>
</div>
<p>There are also options for the conf file for specifying the dispersion coverage
(defaults to 1%), retries, concurrency, etc. though usually the defaults are
fine. If you want to use keystone v3 for authentication there are options like
auth_version, user_domain_name, project_domain_name and project_name.</p>
<p>Once the configuration is in place, run <cite>swift-dispersion-populate</cite> to populate
the containers and objects throughout the cluster.</p>
<p>Now that those containers and objects are in place, you can run
<cite>swift-dispersion-report</cite> to get a dispersion report, or the overall health of
the cluster. Here is an example of a cluster in perfect health:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ swift-dispersion-report
Queried 2621 containers for dispersion reporting, 19s, 0 retries
100.00% of container copies found (7863 of 7863)
Sample represents 1.00% of the container partition space

Queried 2619 objects for dispersion reporting, 7s, 0 retries
100.00% of object copies found (7857 of 7857)
Sample represents 1.00% of the object partition space
</pre></div>
</div>
<p>Now I&#8217;ll deliberately double the weight of a device in the object ring (with
replication turned off) and rerun the dispersion report to show what impact
that has:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ swift-ring-builder object.builder set_weight d0 200
$ swift-ring-builder object.builder rebalance
...
$ swift-dispersion-report
Queried 2621 containers for dispersion reporting, 8s, 0 retries
100.00% of container copies found (7863 of 7863)
Sample represents 1.00% of the container partition space

Queried 2619 objects for dispersion reporting, 7s, 0 retries
There were 1763 partitions missing one copy.
77.56% of object copies found (6094 of 7857)
Sample represents 1.00% of the object partition space
</pre></div>
</div>
<p>You can see the health of the objects in the cluster has gone down
significantly. Of course, I only have four devices in this test environment, in
a production environment with many many devices the impact of one device change
is much less. Next, I&#8217;ll run the replicators to get everything put back into
place and then rerun the dispersion report:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>... start object replicators and monitor logs until they&#39;re caught up ...
$ swift-dispersion-report
Queried 2621 containers for dispersion reporting, 17s, 0 retries
100.00% of container copies found (7863 of 7863)
Sample represents 1.00% of the container partition space

Queried 2619 objects for dispersion reporting, 7s, 0 retries
100.00% of object copies found (7857 of 7857)
Sample represents 1.00% of the object partition space
</pre></div>
</div>
<p>You can also run the report for only containers or objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ swift-dispersion-report --container-only
Queried 2621 containers for dispersion reporting, 17s, 0 retries
100.00% of container copies found (7863 of 7863)
Sample represents 1.00% of the container partition space

$ swift-dispersion-report --object-only
Queried 2619 objects for dispersion reporting, 7s, 0 retries
100.00% of object copies found (7857 of 7857)
Sample represents 1.00% of the object partition space
</pre></div>
</div>
<p>Alternatively, the dispersion report can also be output in JSON format. This
allows it to be more easily consumed by third party utilities:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ swift-dispersion-report -j
{&quot;object&quot;: {&quot;retries:&quot;: 0, &quot;missing_two&quot;: 0, &quot;copies_found&quot;: 7863, &quot;missing_one&quot;: 0, &quot;copies_expected&quot;: 7863, &quot;pct_found&quot;: 100.0, &quot;overlapping&quot;: 0, &quot;missing_all&quot;: 0}, &quot;container&quot;: {&quot;retries:&quot;: 0, &quot;missing_two&quot;: 0, &quot;copies_found&quot;: 12534, &quot;missing_one&quot;: 0, &quot;copies_expected&quot;: 12534, &quot;pct_found&quot;: 100.0, &quot;overlapping&quot;: 15, &quot;missing_all&quot;: 0}}
</pre></div>
</div>
<p>Note that you may select which storage policy to use by setting the option
&#8216;&#8211;policy-name silver&#8217; or &#8216;-P silver&#8217; (silver is the example policy name here).
If no policy is specified, the default will be used per the swift.conf file.
When you specify a policy the containers created also include the policy index,
thus even when running a container_only report, you will need to specify the
policy not using the default.</p>
</div>
<div class="section" id="geographically-distributed-swift-considerations">
<h2>Geographically Distributed Swift Considerations<a class="headerlink" href="#geographically-distributed-swift-considerations" title="Permalink to this headline">¶</a></h2>
<p>Swift provides two features that may be used to distribute replicas of objects
across multiple geographically distributed data-centers: with
<a class="reference internal" href="overview_global_cluster.html"><em>Global Clusters</em></a> object replicas may be dispersed across devices
from different data-centers by using <cite>regions</cite> in ring device descriptors; with
<a class="reference internal" href="overview_container_sync.html"><em>Container to Container Synchronization</em></a> objects may be copied between independent Swift
clusters in each data-center. The operation and configuration of each are
described in their respective documentation. The following points should be
considered when selecting the feature that is most appropriate for a particular
use case:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Global Clusters allows the distribution of object replicas across
data-centers to be controlled by the cluster operator on per-policy basis,
since the distribution is determined by the assignment of devices from
each data-center in each policy&#8217;s ring file. With Container Sync the end
user controls the distribution of objects across clusters on a
per-container basis.</li>
<li>Global Clusters requires an operator to coordinate ring deployments across
multiple data-centers. Container Sync allows for independent management of
separate Swift clusters in each data-center, and for existing Swift
clusters to be used as peers in Container Sync relationships without
deploying new policies/rings.</li>
<li>Global Clusters seamlessly supports features that may rely on
cross-container operations such as large objects and versioned writes.
Container Sync requires the end user to ensure that all required
containers are sync&#8217;d for these features to work in all data-centers.</li>
<li>Global Clusters makes objects available for GET or HEAD requests in both
data-centers even if a replica of the object has not yet been
asynchronously migrated between data-centers, by forwarding requests
between data-centers. Container Sync is unable to serve requests for an
object in a particular data-center until the asynchronous sync process has
copied the object to that data-center.</li>
<li>Global Clusters may require less storage capacity than Container Sync to
achieve equivalent durability of objects in each data-center. Global
Clusters can restore replicas that are lost or corrupted in one
data-center using replicas from other data-centers. Container Sync
requires each data-center to independently manage the durability of
objects, which may result in each data-center storing more replicas than
with Global Clusters.</li>
<li>Global Clusters execute all account/container metadata updates
synchronously to account/container replicas in all data-centers, which may
incur delays when making updates across WANs. Container Sync only copies
objects between data-centers and all Swift internal traffic is
confined to each data-center.</li>
<li>Global Clusters does not yet guarantee the availability of objects stored
in Erasure Coded policies when one data-center is offline. With Container
Sync the availability of objects in each data-center is independent of the
state of other data-centers once objects have been synced. Container Sync
also allows objects to be stored using different policy types in different
data-centers.</li>
</ol>
</div></blockquote>
<div class="section" id="checking-handoff-partition-distribution">
<h3>Checking handoff partition distribution<a class="headerlink" href="#checking-handoff-partition-distribution" title="Permalink to this headline">¶</a></h3>
<p>You can check if handoff partitions are piling up on a server by
comparing the expected number of partitions with the actual number on
your disks. First get the number of partitions that are currently
assigned to a server using the <code class="docutils literal"><span class="pre">dispersion</span></code> command from
<code class="docutils literal"><span class="pre">swift-ring-builder</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>swift-ring-builder sample.builder dispersion --verbose
Dispersion is 0.000000, Balance is 0.000000, Overload is 0.00%
Required overload is 0.000000%
--------------------------------------------------------------------------
Tier                           Parts      %    Max     0     1     2     3
--------------------------------------------------------------------------
r1                              8192   0.00      2     0     0  8192     0
r1z1                            4096   0.00      1  4096  4096     0     0
r1z1-172.16.10.1                4096   0.00      1  4096  4096     0     0
r1z1-172.16.10.1/sda1           4096   0.00      1  4096  4096     0     0
r1z2                            4096   0.00      1  4096  4096     0     0
r1z2-172.16.10.2                4096   0.00      1  4096  4096     0     0
r1z2-172.16.10.2/sda1           4096   0.00      1  4096  4096     0     0
r1z3                            4096   0.00      1  4096  4096     0     0
r1z3-172.16.10.3                4096   0.00      1  4096  4096     0     0
r1z3-172.16.10.3/sda1           4096   0.00      1  4096  4096     0     0
r1z4                            4096   0.00      1  4096  4096     0     0
r1z4-172.16.20.4                4096   0.00      1  4096  4096     0     0
r1z4-172.16.20.4/sda1           4096   0.00      1  4096  4096     0     0
r2                              8192   0.00      2     0  8192     0     0
r2z1                            4096   0.00      1  4096  4096     0     0
r2z1-172.16.20.1                4096   0.00      1  4096  4096     0     0
r2z1-172.16.20.1/sda1           4096   0.00      1  4096  4096     0     0
r2z2                            4096   0.00      1  4096  4096     0     0
r2z2-172.16.20.2                4096   0.00      1  4096  4096     0     0
r2z2-172.16.20.2/sda1           4096   0.00      1  4096  4096     0     0
</pre></div>
</div>
<p>As you can see from the output, each server should store 4096 partitions, and
each region should store 8192 partitions. This example used a partition power
of 13 and 3 replicas.</p>
<p>With write_affinity enabled it is expected to have a higher number of
partitions on disk compared to the value reported by the
swift-ring-builder dispersion command. The number of additional (handoff)
partitions in region r1 depends on your cluster size, the amount
of incoming data as well as the replication speed.</p>
<p>Let&#8217;s use the example from above with 6 nodes in 2 regions, and write_affinity
configured to write to region r1 first. <cite>swift-ring-builder</cite> reported that
each node should store 4096 partitions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>Expected partitions for region r2:                                      8192
Handoffs stored across 4 nodes in region r1:                 8192 / 4 = 2048
Maximum number of partitions on each server in region r1: 2048 + 4096 = 6144
</pre></div>
</div>
<p>Worst case is that handoff partitions in region 1 are populated with new
object replicas faster than replication is able to move them to region 2.
In that case you will see ~ 6144 partitions per
server in region r1. Your actual number should be lower and
between 4096 and 6144 partitions (preferably on the lower side).</p>
<p>Now count the number of object partitions on a given server in region 1,
for example on 172.16.10.1.  Note that the pathnames might be
different; <cite>/srv/node/</cite> is the default mount location, and <cite>objects</cite>
applies only to storage policy 0 (storage policy 1 would use
<cite>objects-1</cite> and so on):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>find -L /srv/node/ -maxdepth 3 -type d -wholename &quot;*objects/*&quot; | wc -l
</pre></div>
</div>
<p>If this number is always on the upper end of the expected partition
number range (4096 to 6144) or increasing you should check your
replication speed and maybe even disable write_affinity.
Please refer to the next section how to collect metrics from Swift, and
especially <a class="reference internal" href="#recon-replication"><span>swift-recon -r</span></a> how to check replication
stats.</p>
</div>
</div>
<div class="section" id="cluster-telemetry-and-monitoring">
<h2>Cluster Telemetry and Monitoring<a class="headerlink" href="#cluster-telemetry-and-monitoring" title="Permalink to this headline">¶</a></h2>
<p>Various metrics and telemetry can be obtained from the account, container, and
object servers using the recon server middleware and the swift-recon cli. To do
so update your account, container, or object servers pipelines to include recon
and add the associated filter config.</p>
<p>object-server.conf sample:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>[pipeline:main]
pipeline = recon object-server

[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift
</pre></div>
</div>
<p>container-server.conf sample:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>[pipeline:main]
pipeline = recon container-server

[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift
</pre></div>
</div>
<p>account-server.conf sample:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>[pipeline:main]
pipeline = recon account-server

[filter:recon]
use = egg:swift#recon
recon_cache_path = /var/cache/swift
</pre></div>
</div>
<p>The recon_cache_path simply sets the directory where stats for a few items will
be stored. Depending on the method of deployment you may need to create this
directory manually and ensure that swift has read/write access.</p>
<p>Finally, if you also wish to track asynchronous pending on your object
servers you will need to setup a cronjob to run the swift-recon-cron script
periodically on your object servers:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>*/5 * * * * swift /usr/bin/swift-recon-cron /etc/swift/object-server.conf
</pre></div>
</div>
<p>Once the recon middleware is enabled, a GET request for
&#8220;/recon/&lt;metric&gt;&#8221; to the backend object server will return a
JSON-formatted response:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>fhines@ubuntu:~$ curl -i http://localhost:6030/recon/async
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 20
Date: Tue, 18 Oct 2011 21:03:01 GMT

{&quot;async_pending&quot;: 0}
</pre></div>
</div>
<p>Note that the default port for the object server is 6200, except on a
Swift All-In-One installation, which uses 6010, 6020, 6030, and 6040.</p>
<p>The following metrics and telemetry are currently exposed:</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Request URI</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>/recon/load</td>
<td>returns 1,5, and 15 minute load average</td>
</tr>
<tr class="row-odd"><td>/recon/mem</td>
<td>returns /proc/meminfo</td>
</tr>
<tr class="row-even"><td>/recon/mounted</td>
<td>returns <em>ALL</em> currently mounted filesystems</td>
</tr>
<tr class="row-odd"><td>/recon/unmounted</td>
<td>returns all unmounted drives if mount_check = True</td>
</tr>
<tr class="row-even"><td>/recon/diskusage</td>
<td>returns disk utilization for storage devices</td>
</tr>
<tr class="row-odd"><td>/recon/driveaudit</td>
<td>returns # of drive audit errors</td>
</tr>
<tr class="row-even"><td>/recon/ringmd5</td>
<td>returns object/container/account ring md5sums</td>
</tr>
<tr class="row-odd"><td>/recon/swiftconfmd5</td>
<td>returns swift.conf md5sum</td>
</tr>
<tr class="row-even"><td>/recon/quarantined</td>
<td>returns # of quarantined objects/accounts/containers</td>
</tr>
<tr class="row-odd"><td>/recon/sockstat</td>
<td>returns consumable info from /proc/net/sockstat|6</td>
</tr>
<tr class="row-even"><td>/recon/devices</td>
<td>returns list of devices and devices dir i.e. /srv/node</td>
</tr>
<tr class="row-odd"><td>/recon/async</td>
<td>returns count of async pending</td>
</tr>
<tr class="row-even"><td>/recon/replication</td>
<td>returns object replication info (for backward compatibility)</td>
</tr>
<tr class="row-odd"><td>/recon/replication/&lt;type&gt;</td>
<td>returns replication info for given type (account, container, object)</td>
</tr>
<tr class="row-even"><td>/recon/auditor/&lt;type&gt;</td>
<td>returns auditor stats on last reported scan for given type (account, container, object)</td>
</tr>
<tr class="row-odd"><td>/recon/updater/&lt;type&gt;</td>
<td>returns last updater sweep times for given type (container, object)</td>
</tr>
<tr class="row-even"><td>/recon/expirer/object</td>
<td>returns time elapsed and number of objects deleted during last object expirer sweep</td>
</tr>
<tr class="row-odd"><td>/recon/version</td>
<td>returns Swift version</td>
</tr>
<tr class="row-even"><td>/recon/time</td>
<td>returns node time</td>
</tr>
</tbody>
</table>
<p>Note that &#8216;object_replication_last&#8217; and &#8216;object_replication_time&#8217; in object
replication info are considered to be transitional and will be removed in
the subsequent releases. Use &#8216;replication_last&#8217; and &#8216;replication_time&#8217; instead.</p>
<p>This information can also be queried via the swift-recon command line utility:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>fhines@ubuntu:~$ swift-recon -h
Usage:
        usage: swift-recon &lt;server_type&gt; [-v] [--suppress] [-a] [-r] [-u] [-d]
        [-l] [-T] [--md5] [--auditor] [--updater] [--expirer] [--sockstat]

        &lt;server_type&gt;   account|container|object
        Defaults to object server.

        ex: swift-recon container -l --auditor


Options:
  -h, --help            show this help message and exit
  -v, --verbose         Print verbose info
  --suppress            Suppress most connection related errors
  -a, --async           Get async stats
  -r, --replication     Get replication stats
  --auditor             Get auditor stats
  --updater             Get updater stats
  --expirer             Get expirer stats
  -u, --unmounted       Check cluster for unmounted devices
  -d, --diskusage       Get disk usage stats
  -l, --loadstats       Get cluster load average stats
  -q, --quarantined     Get cluster quarantine stats
  --md5                 Get md5sum of servers ring and compare to local copy
  --sockstat            Get cluster socket usage stats
  -T, --time            Check time synchronization
  --all                 Perform all checks. Equal to
                        -arudlqT --md5 --sockstat --auditor --updater
                        --expirer --driveaudit --validate-servers
  -z ZONE, --zone=ZONE  Only query servers in specified zone
  -t SECONDS, --timeout=SECONDS
                        Time to wait for a response from a server
  --swiftdir=SWIFTDIR   Default = /etc/swift
</pre></div>
</div>
<p id="recon-replication">For example, to obtain container replication info from all hosts in zone &#8220;3&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>fhines@ubuntu:~$ swift-recon container -r --zone 3
===============================================================================
--&gt; Starting reconnaissance on 1 hosts
===============================================================================
[2012-04-02 02:45:48] Checking on replication
[failure] low: 0.000, high: 0.000, avg: 0.000, reported: 1
[success] low: 486.000, high: 486.000, avg: 486.000, reported: 1
[replication_time] low: 20.853, high: 20.853, avg: 20.853, reported: 1
[attempted] low: 243.000, high: 243.000, avg: 243.000, reported: 1
</pre></div>
</div>
</div>
<div class="section" id="reporting-metrics-to-statsd">
<h2>Reporting Metrics to StatsD<a class="headerlink" href="#reporting-metrics-to-statsd" title="Permalink to this headline">¶</a></h2>
<p>If you have a <a class="reference external" href="http://codeascraft.etsy.com/2011/02/15/measure-anything-measure-everything/">StatsD</a> server running, Swift may be configured to send it
real-time operational metrics.  To enable this, set the following
configuration entries (see the sample configuration files):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">log_statsd_host</span> <span class="o">=</span> <span class="n">localhost</span>
<span class="n">log_statsd_port</span> <span class="o">=</span> <span class="mi">8125</span>
<span class="n">log_statsd_default_sample_rate</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">log_statsd_sample_rate_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">log_statsd_metric_prefix</span> <span class="o">=</span>                <span class="p">[</span><span class="n">empty</span><span class="o">-</span><span class="n">string</span><span class="p">]</span>
</pre></div>
</div>
<p>If <cite>log_statsd_host</cite> is not set, this feature is disabled.  The default values
for the other settings are given above.  The <cite>log_statsd_host</cite> can be a
hostname, an IPv4 address, or an IPv6 address (not surrounded with brackets, as
this is unnecessary since the port is specified separately).  If a hostname
resolves to an IPv4 address, an IPv4 socket will be used to send StatsD UDP
packets, even if the hostname would also resolve to an IPv6 address.</p>
<p>The sample rate is a real number between 0 and 1 which defines the
probability of sending a sample for any given event or timing measurement.
This sample rate is sent with each sample to StatsD and used to
multiply the value.  For example, with a sample rate of 0.5, StatsD will
multiply that counter&#8217;s value by 2 when flushing the metric to an upstream
monitoring system (<a class="reference external" href="http://graphite.wikidot.com/">Graphite</a>, <a class="reference external" href="http://ganglia.sourceforge.net/">Ganglia</a>, etc.).</p>
<p>Some relatively high-frequency metrics have a default sample rate less than
one.  If you want to override the default sample rate for all metrics whose
default sample rate is not specified in the Swift source, you may set
<cite>log_statsd_default_sample_rate</cite> to a value less than one.  This is NOT
recommended (see next paragraph).  A better way to reduce StatsD load is to
adjust <cite>log_statsd_sample_rate_factor</cite> to a value less than one.  The
<cite>log_statsd_sample_rate_factor</cite> is multiplied to any sample rate (either the
global default or one specified by the actual metric logging call in the Swift
source) prior to handling.  In other words, this one tunable can lower the
frequency of all StatsD logging by a proportional amount.</p>
<p>To get the best data, start with the default <cite>log_statsd_default_sample_rate</cite>
and <cite>log_statsd_sample_rate_factor</cite> values of 1 and only lower
<cite>log_statsd_sample_rate_factor</cite> if needed.  The
<cite>log_statsd_default_sample_rate</cite> should not be used and remains for backward
compatibility only.</p>
<p>The metric prefix will be prepended to every metric sent to the StatsD server
For example, with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">log_statsd_metric_prefix</span> <span class="o">=</span> <span class="n">proxy01</span>
</pre></div>
</div>
<p>the metric <cite>proxy-server.errors</cite> would be sent to StatsD as
<cite>proxy01.proxy-server.errors</cite>.  This is useful for differentiating different
servers when sending statistics to a central StatsD server.  If you run a local
StatsD server per node, you could configure a per-node metrics prefix there and
leave <cite>log_statsd_metric_prefix</cite> blank.</p>
<p>Note that metrics reported to StatsD are counters or timing data (which are
sent in units of milliseconds).  StatsD usually expands timing data out to min,
max, avg, count, and 90th percentile per timing metric, but the details of
this behavior will depend on the configuration of your StatsD server.  Some
important &#8220;gauge&#8221; metrics may still need to be collected using another method.
For example, the <cite>object-server.async_pendings</cite> StatsD metric counts the generation
of async_pendings in real-time, but will not tell you the current number of
async_pending container updates on disk at any point in time.</p>
<p>Note also that the set of metrics collected, their names, and their semantics
are not locked down and will change over time.</p>
<p>Metrics for <cite>account-auditor</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>account-auditor.errors</cite></td>
<td>Count of audit runs (across all account databases) which
caught an Exception.</td>
</tr>
<tr class="row-odd"><td><cite>account-auditor.passes</cite></td>
<td>Count of individual account databases which passed audit.</td>
</tr>
<tr class="row-even"><td><cite>account-auditor.failures</cite></td>
<td>Count of individual account databases which failed audit.</td>
</tr>
<tr class="row-odd"><td><cite>account-auditor.timing</cite></td>
<td>Timing data for individual account database audits.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>account-reaper</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.errors</cite></td>
<td>Count of devices failing the mount check.</td>
</tr>
<tr class="row-odd"><td><cite>account-reaper.timing</cite></td>
<td>Timing data for each reap_account() call.</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.return_codes.X</cite></td>
<td>Count of HTTP return codes from various operations
(e.g. object listing, container deletion, etc.). The
value for X is the first digit of the return code
(2 for 201, 4 for 404, etc.).</td>
</tr>
<tr class="row-odd"><td><cite>account-reaper.containers_failures</cite></td>
<td>Count of failures to delete a container.</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.containers_deleted</cite></td>
<td>Count of containers successfully deleted.</td>
</tr>
<tr class="row-odd"><td><cite>account-reaper.containers_remaining</cite></td>
<td>Count of containers which failed to delete with
zero successes.</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.containers_possibly_remaining</cite></td>
<td>Count of containers which failed to delete with
at least one success.</td>
</tr>
<tr class="row-odd"><td><cite>account-reaper.objects_failures</cite></td>
<td>Count of failures to delete an object.</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.objects_deleted</cite></td>
<td>Count of objects successfully deleted.</td>
</tr>
<tr class="row-odd"><td><cite>account-reaper.objects_remaining</cite></td>
<td>Count of objects which failed to delete with zero
successes.</td>
</tr>
<tr class="row-even"><td><cite>account-reaper.objects_possibly_remaining</cite></td>
<td>Count of objects which failed to delete with at
least one success.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>account-server</cite> (&#8220;Not Found&#8221; is not considered an error and requests
which increment <cite>errors</cite> are not included in the timing data):</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>account-server.DELETE.errors.timing</cite></td>
<td>Timing data for each DELETE request resulting in an
error: bad request, not mounted, missing timestamp.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.DELETE.timing</cite></td>
<td>Timing data for each DELETE request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>account-server.PUT.errors.timing</cite></td>
<td>Timing data for each PUT request resulting in an error:
bad request, not mounted, conflict, recently-deleted.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.PUT.timing</cite></td>
<td>Timing data for each PUT request not resulting in an
error.</td>
</tr>
<tr class="row-even"><td><cite>account-server.HEAD.errors.timing</cite></td>
<td>Timing data for each HEAD request resulting in an
error: bad request, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.HEAD.timing</cite></td>
<td>Timing data for each HEAD request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>account-server.GET.errors.timing</cite></td>
<td>Timing data for each GET request resulting in an
error: bad request, not mounted, bad delimiter,
account listing limit too high, bad accept header.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.GET.timing</cite></td>
<td>Timing data for each GET request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>account-server.REPLICATE.errors.timing</cite></td>
<td>Timing data for each REPLICATE request resulting in an
error: bad request, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.REPLICATE.timing</cite></td>
<td>Timing data for each REPLICATE request not resulting
in an error.</td>
</tr>
<tr class="row-even"><td><cite>account-server.POST.errors.timing</cite></td>
<td>Timing data for each POST request resulting in an
error: bad request, bad or missing timestamp, not
mounted.</td>
</tr>
<tr class="row-odd"><td><cite>account-server.POST.timing</cite></td>
<td>Timing data for each POST request not resulting in
an error.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>account-replicator</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.diffs</cite></td>
<td>Count of syncs handled by sending differing rows.</td>
</tr>
<tr class="row-odd"><td><cite>account-replicator.diff_caps</cite></td>
<td>Count of &#8220;diffs&#8221; operations which failed because
&#8220;max_diffs&#8221; was hit.</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.no_changes</cite></td>
<td>Count of accounts found to be in sync.</td>
</tr>
<tr class="row-odd"><td><cite>account-replicator.hashmatches</cite></td>
<td>Count of accounts found to be in sync via hash
comparison (<cite>broker.merge_syncs</cite> was called).</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.rsyncs</cite></td>
<td>Count of completely missing accounts which were sent
via rsync.</td>
</tr>
<tr class="row-odd"><td><cite>account-replicator.remote_merges</cite></td>
<td>Count of syncs handled by sending entire database
via rsync.</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.attempts</cite></td>
<td>Count of database replication attempts.</td>
</tr>
<tr class="row-odd"><td><cite>account-replicator.failures</cite></td>
<td>Count of database replication attempts which failed
due to corruption (quarantined) or inability to read
as well as attempts to individual nodes which
failed.</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.removes.&lt;device&gt;</cite></td>
<td>Count of databases on &lt;device&gt; deleted because the
delete_timestamp was greater than the put_timestamp
and the database had no rows or because it was
successfully sync&#8217;ed to other locations and doesn&#8217;t
belong here anymore.</td>
</tr>
<tr class="row-odd"><td><cite>account-replicator.successes</cite></td>
<td>Count of replication attempts to an individual node
which were successful.</td>
</tr>
<tr class="row-even"><td><cite>account-replicator.timing</cite></td>
<td>Timing data for each database replication attempt
not resulting in a failure.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>container-auditor</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>container-auditor.errors</cite></td>
<td>Incremented when an Exception is caught in an audit
pass (only once per pass, max).</td>
</tr>
<tr class="row-odd"><td><cite>container-auditor.passes</cite></td>
<td>Count of individual containers passing an audit.</td>
</tr>
<tr class="row-even"><td><cite>container-auditor.failures</cite></td>
<td>Count of individual containers failing an audit.</td>
</tr>
<tr class="row-odd"><td><cite>container-auditor.timing</cite></td>
<td>Timing data for each container audit.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>container-replicator</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.diffs</cite></td>
<td>Count of syncs handled by sending differing rows.</td>
</tr>
<tr class="row-odd"><td><cite>container-replicator.diff_caps</cite></td>
<td>Count of &#8220;diffs&#8221; operations which failed because
&#8220;max_diffs&#8221; was hit.</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.no_changes</cite></td>
<td>Count of containers found to be in sync.</td>
</tr>
<tr class="row-odd"><td><cite>container-replicator.hashmatches</cite></td>
<td>Count of containers found to be in sync via hash
comparison (<cite>broker.merge_syncs</cite> was called).</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.rsyncs</cite></td>
<td>Count of completely missing containers where were sent
via rsync.</td>
</tr>
<tr class="row-odd"><td><cite>container-replicator.remote_merges</cite></td>
<td>Count of syncs handled by sending entire database
via rsync.</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.attempts</cite></td>
<td>Count of database replication attempts.</td>
</tr>
<tr class="row-odd"><td><cite>container-replicator.failures</cite></td>
<td>Count of database replication attempts which failed
due to corruption (quarantined) or inability to read
as well as attempts to individual nodes which
failed.</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.removes.&lt;device&gt;</cite></td>
<td>Count of databases deleted on &lt;device&gt; because the
delete_timestamp was greater than the put_timestamp
and the database had no rows or because it was
successfully sync&#8217;ed to other locations and doesn&#8217;t
belong here anymore.</td>
</tr>
<tr class="row-odd"><td><cite>container-replicator.successes</cite></td>
<td>Count of replication attempts to an individual node
which were successful.</td>
</tr>
<tr class="row-even"><td><cite>container-replicator.timing</cite></td>
<td>Timing data for each database replication attempt
not resulting in a failure.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>container-server</cite> (&#8220;Not Found&#8221; is not considered an error and requests
which increment <cite>errors</cite> are not included in the timing data):</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>container-server.DELETE.errors.timing</cite></td>
<td>Timing data for DELETE request errors: bad request,
not mounted, missing timestamp, conflict.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.DELETE.timing</cite></td>
<td>Timing data for each DELETE request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>container-server.PUT.errors.timing</cite></td>
<td>Timing data for PUT request errors: bad request,
missing timestamp, not mounted, conflict.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.PUT.timing</cite></td>
<td>Timing data for each PUT request not resulting in an
error.</td>
</tr>
<tr class="row-even"><td><cite>container-server.HEAD.errors.timing</cite></td>
<td>Timing data for HEAD request errors: bad request,
not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.HEAD.timing</cite></td>
<td>Timing data for each HEAD request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>container-server.GET.errors.timing</cite></td>
<td>Timing data for GET request errors: bad request,
not mounted, parameters not utf8, bad accept header.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.GET.timing</cite></td>
<td>Timing data for each GET request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>container-server.REPLICATE.errors.timing</cite></td>
<td>Timing data for REPLICATE request errors: bad
request, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.REPLICATE.timing</cite></td>
<td>Timing data for each REPLICATE request not resulting
in an error.</td>
</tr>
<tr class="row-even"><td><cite>container-server.POST.errors.timing</cite></td>
<td>Timing data for POST request errors: bad request,
bad x-container-sync-to, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>container-server.POST.timing</cite></td>
<td>Timing data for each POST request not resulting in
an error.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>container-sync</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>container-sync.skips</cite></td>
<td>Count of containers skipped because they don&#8217;t have
sync&#8217;ing enabled.</td>
</tr>
<tr class="row-odd"><td><cite>container-sync.failures</cite></td>
<td>Count of failures sync&#8217;ing of individual containers.</td>
</tr>
<tr class="row-even"><td><cite>container-sync.syncs</cite></td>
<td>Count of individual containers sync&#8217;ed successfully.</td>
</tr>
<tr class="row-odd"><td><cite>container-sync.deletes</cite></td>
<td>Count of container database rows sync&#8217;ed by
deletion.</td>
</tr>
<tr class="row-even"><td><cite>container-sync.deletes.timing</cite></td>
<td>Timing data for each container database row
synchronization via deletion.</td>
</tr>
<tr class="row-odd"><td><cite>container-sync.puts</cite></td>
<td>Count of container database rows sync&#8217;ed by PUTing.</td>
</tr>
<tr class="row-even"><td><cite>container-sync.puts.timing</cite></td>
<td>Timing data for each container database row
synchronization via PUTing.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>container-updater</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>container-updater.successes</cite></td>
<td>Count of containers which successfully updated their
account.</td>
</tr>
<tr class="row-odd"><td><cite>container-updater.failures</cite></td>
<td>Count of containers which failed to update their
account.</td>
</tr>
<tr class="row-even"><td><cite>container-updater.no_changes</cite></td>
<td>Count of containers which didn&#8217;t need to update
their account.</td>
</tr>
<tr class="row-odd"><td><cite>container-updater.timing</cite></td>
<td>Timing data for processing a container; only
includes timing for containers which needed to
update their accounts (i.e. &#8220;successes&#8221; and
&#8220;failures&#8221; but not &#8220;no_changes&#8221;).</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-auditor</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-auditor.quarantines</cite></td>
<td>Count of objects failing audit and quarantined.</td>
</tr>
<tr class="row-odd"><td><cite>object-auditor.errors</cite></td>
<td>Count of errors encountered while auditing objects.</td>
</tr>
<tr class="row-even"><td><cite>object-auditor.timing</cite></td>
<td>Timing data for each object audit (does not include
any rate-limiting sleep time for
max_files_per_second, but does include rate-limiting
sleep time for max_bytes_per_second).</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-expirer</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-expirer.objects</cite></td>
<td>Count of objects expired.</td>
</tr>
<tr class="row-odd"><td><cite>object-expirer.errors</cite></td>
<td>Count of errors encountered while attempting to
expire an object.</td>
</tr>
<tr class="row-even"><td><cite>object-expirer.timing</cite></td>
<td>Timing data for each object expiration attempt,
including ones resulting in an error.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-reconstructor</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-reconstructor.partition.delete.count.&lt;device&gt;</cite></td>
<td>A count of partitions on &lt;device&gt; which were
reconstructed and synced to another node because they
didn&#8217;t belong on this node. This metric is tracked
per-device to allow for &#8220;quiescence detection&#8221; for
object reconstruction activity on each device.</td>
</tr>
<tr class="row-odd"><td><cite>object-reconstructor.partition.delete.timing</cite></td>
<td>Timing data for partitions reconstructed and synced to
another node because they didn&#8217;t belong on this node.
This metric is not tracked per device.</td>
</tr>
<tr class="row-even"><td><cite>object-reconstructor.partition.update.count.&lt;device&gt;</cite></td>
<td>A count of partitions on &lt;device&gt; which were
reconstructed and synced to another node, but also
belong on this node. As with delete.count, this metric
is tracked per-device.</td>
</tr>
<tr class="row-odd"><td><cite>object-reconstructor.partition.update.timing</cite></td>
<td>Timing data for partitions reconstructed which also
belong on this node. This metric is not tracked
per-device.</td>
</tr>
<tr class="row-even"><td><cite>object-reconstructor.suffix.hashes</cite></td>
<td>Count of suffix directories whose hash (of filenames)
was recalculated.</td>
</tr>
<tr class="row-odd"><td><cite>object-reconstructor.suffix.syncs</cite></td>
<td>Count of suffix directories reconstructed with ssync.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-replicator</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-replicator.partition.delete.count.&lt;device&gt;</cite></td>
<td>A count of partitions on &lt;device&gt; which were
replicated to another node because they didn&#8217;t
belong on this node.  This metric is tracked
per-device to allow for &#8220;quiescence detection&#8221; for
object replication activity on each device.</td>
</tr>
<tr class="row-odd"><td><cite>object-replicator.partition.delete.timing</cite></td>
<td>Timing data for partitions replicated to another
node because they didn&#8217;t belong on this node.  This
metric is not tracked per device.</td>
</tr>
<tr class="row-even"><td><cite>object-replicator.partition.update.count.&lt;device&gt;</cite></td>
<td>A count of partitions on &lt;device&gt; which were
replicated to another node, but also belong on this
node.  As with delete.count, this metric is tracked
per-device.</td>
</tr>
<tr class="row-odd"><td><cite>object-replicator.partition.update.timing</cite></td>
<td>Timing data for partitions replicated which also
belong on this node.  This metric is not tracked
per-device.</td>
</tr>
<tr class="row-even"><td><cite>object-replicator.suffix.hashes</cite></td>
<td>Count of suffix directories whose hash (of filenames)
was recalculated.</td>
</tr>
<tr class="row-odd"><td><cite>object-replicator.suffix.syncs</cite></td>
<td>Count of suffix directories replicated with rsync.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-server</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-server.quarantines</cite></td>
<td>Count of objects (files) found bad and moved to
quarantine.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.async_pendings</cite></td>
<td>Count of container updates saved as async_pendings
(may result from PUT or DELETE requests).</td>
</tr>
<tr class="row-even"><td><cite>object-server.POST.errors.timing</cite></td>
<td>Timing data for POST request errors: bad request,
missing timestamp, delete-at in past, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.POST.timing</cite></td>
<td>Timing data for each POST request not resulting in
an error.</td>
</tr>
<tr class="row-even"><td><cite>object-server.PUT.errors.timing</cite></td>
<td>Timing data for PUT request errors: bad request,
not mounted, missing timestamp, object creation
constraint violation, delete-at in past.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.PUT.timeouts</cite></td>
<td>Count of object PUTs which exceeded max_upload_time.</td>
</tr>
<tr class="row-even"><td><cite>object-server.PUT.timing</cite></td>
<td>Timing data for each PUT request not resulting in an
error.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.PUT.&lt;device&gt;.timing</cite></td>
<td>Timing data per kB transferred (ms/kB) for each
non-zero-byte PUT request on each device.
Monitoring problematic devices, higher is bad.</td>
</tr>
<tr class="row-even"><td><cite>object-server.GET.errors.timing</cite></td>
<td>Timing data for GET request errors: bad request,
not mounted, header timestamps before the epoch,
precondition failed.
File errors resulting in a quarantine are not
counted here.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.GET.timing</cite></td>
<td>Timing data for each GET request not resulting in an
error.  Includes requests which couldn&#8217;t find the
object (including disk errors resulting in file
quarantine).</td>
</tr>
<tr class="row-even"><td><cite>object-server.HEAD.errors.timing</cite></td>
<td>Timing data for HEAD request errors: bad request,
not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.HEAD.timing</cite></td>
<td>Timing data for each HEAD request not resulting in
an error.  Includes requests which couldn&#8217;t find the
object (including disk errors resulting in file
quarantine).</td>
</tr>
<tr class="row-even"><td><cite>object-server.DELETE.errors.timing</cite></td>
<td>Timing data for DELETE request errors: bad request,
missing timestamp, not mounted, precondition
failed.  Includes requests which couldn&#8217;t find or
match the object.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.DELETE.timing</cite></td>
<td>Timing data for each DELETE request not resulting
in an error.</td>
</tr>
<tr class="row-even"><td><cite>object-server.REPLICATE.errors.timing</cite></td>
<td>Timing data for REPLICATE request errors: bad
request, not mounted.</td>
</tr>
<tr class="row-odd"><td><cite>object-server.REPLICATE.timing</cite></td>
<td>Timing data for each REPLICATE request not resulting
in an error.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>object-updater</cite>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>object-updater.errors</cite></td>
<td>Count of drives not mounted or async_pending files
with an unexpected name.</td>
</tr>
<tr class="row-odd"><td><cite>object-updater.timing</cite></td>
<td>Timing data for object sweeps to flush async_pending
container updates.  Does not include object sweeps
which did not find an existing async_pending storage
directory.</td>
</tr>
<tr class="row-even"><td><cite>object-updater.quarantines</cite></td>
<td>Count of async_pending container updates which were
corrupted and moved to quarantine.</td>
</tr>
<tr class="row-odd"><td><cite>object-updater.successes</cite></td>
<td>Count of successful container updates.</td>
</tr>
<tr class="row-even"><td><cite>object-updater.failures</cite></td>
<td>Count of failed container updates.</td>
</tr>
<tr class="row-odd"><td><cite>object-updater.unlinks</cite></td>
<td>Count of async_pending files unlinked. An
async_pending file is unlinked either when it is
successfully processed or when the replicator sees
that there is a newer async_pending file for the
same object.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>proxy-server</cite> (in the table, <cite>&lt;type&gt;</cite> is the proxy-server
controller responsible for the request and will be one of &#8220;account&#8221;,
&#8220;container&#8221;, or &#8220;object&#8221;):</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.errors</cite></td>
<td>Count of errors encountered while serving requests
before the controller type is determined.  Includes
invalid Content-Length, errors finding the internal
controller to handle the request, invalid utf8, and
bad URLs.</td>
</tr>
<tr class="row-odd"><td><cite>proxy-server.&lt;type&gt;.handoff_count</cite></td>
<td>Count of node hand-offs; only tracked if log_handoffs
is set in the proxy-server config.</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.&lt;type&gt;.handoff_all_count</cite></td>
<td>Count of times <em>only</em> hand-off locations were
utilized; only tracked if log_handoffs is set in the
proxy-server config.</td>
</tr>
<tr class="row-odd"><td><cite>proxy-server.&lt;type&gt;.client_timeouts</cite></td>
<td>Count of client timeouts (client did not read within
<cite>client_timeout</cite> seconds during a GET or did not
supply data within <cite>client_timeout</cite> seconds during
a PUT).</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.&lt;type&gt;.client_disconnects</cite></td>
<td>Count of detected client disconnects during PUT
operations (does NOT include caught Exceptions in
the proxy-server which caused a client disconnect).</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>proxy-logging</cite> middleware (in the table, <cite>&lt;type&gt;</cite> is either the
proxy-server controller responsible for the request: &#8220;account&#8221;, &#8220;container&#8221;,
&#8220;object&#8221;, or the string &#8220;SOS&#8221; if the request came from the <a class="reference external" href="https://github.com/dpgoetz/sos">Swift Origin Server</a>
middleware.  The <cite>&lt;verb&gt;</cite> portion will be one of &#8220;GET&#8221;, &#8220;HEAD&#8221;, &#8220;POST&#8221;, &#8220;PUT&#8221;,
&#8220;DELETE&#8221;, &#8220;COPY&#8221;, &#8220;OPTIONS&#8221;, or &#8220;BAD_METHOD&#8221;.  The list of valid HTTP methods
is configurable via the <cite>log_statsd_valid_http_methods</cite> config variable and
the default setting yields the above behavior):</p>
<table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.timing</cite></td>
<td>Timing data for requests, start to finish.
The &lt;status&gt; portion is the numeric HTTP
status code for the request (e.g.  &#8220;200&#8221; or
&#8220;404&#8221;).</td>
</tr>
<tr class="row-odd"><td><cite>proxy-server.&lt;type&gt;.GET.&lt;status&gt;.first-byte.timing</cite></td>
<td>Timing data up to completion of sending the
response headers (only for GET requests).
&lt;status&gt; and &lt;type&gt; are as for the main
timing metric.</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.&lt;type&gt;.&lt;verb&gt;.&lt;status&gt;.xfer</cite></td>
<td>This counter metric is the sum of bytes
transferred in (from clients) and out (to
clients) for requests.  The &lt;type&gt;, &lt;verb&gt;,
and &lt;status&gt; portions of the metric are just
like the main timing metric.</td>
</tr>
</tbody>
</table>
<p>The <cite>proxy-logging</cite> middleware also groups these metrics by policy.  The
<cite>&lt;policy-index&gt;</cite> portion represents a policy index):</p>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.object.policy.&lt;policy-index&gt;.&lt;verb&gt;.&lt;status&gt;.timing</cite></td>
<td>Timing data for requests, aggregated
by policy index.</td>
</tr>
<tr class="row-odd"><td><cite>proxy-server.object.policy.&lt;policy-index&gt;.GET.&lt;status&gt;.first-byte.timing</cite></td>
<td>Timing data up to completion of
sending the response headers,
aggregated by policy index.</td>
</tr>
<tr class="row-even"><td><cite>proxy-server.object.policy.&lt;policy-index&gt;.&lt;verb&gt;.&lt;status&gt;.xfer</cite></td>
<td>Sum of bytes transferred in and out,
aggregated by policy index.</td>
</tr>
</tbody>
</table>
<p>Metrics for <cite>tempauth</cite> middleware (in the table, <cite>&lt;reseller_prefix&gt;</cite> represents
the actual configured reseller_prefix or &#8220;<cite>NONE</cite>&#8221; if the reseller_prefix is the
empty string):</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Metric Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td><cite>tempauth.&lt;reseller_prefix&gt;.unauthorized</cite></td>
<td>Count of regular requests which were denied with
HTTPUnauthorized.</td>
</tr>
<tr class="row-odd"><td><cite>tempauth.&lt;reseller_prefix&gt;.forbidden</cite></td>
<td>Count of regular requests which were denied with
HTTPForbidden.</td>
</tr>
<tr class="row-even"><td><cite>tempauth.&lt;reseller_prefix&gt;.token_denied</cite></td>
<td>Count of token requests which were denied.</td>
</tr>
<tr class="row-odd"><td><cite>tempauth.&lt;reseller_prefix&gt;.errors</cite></td>
<td>Count of errors.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="debugging-tips-and-tools">
<h2>Debugging Tips and Tools<a class="headerlink" href="#debugging-tips-and-tools" title="Permalink to this headline">¶</a></h2>
<p>When a request is made to Swift, it is given a unique transaction id.  This
id should be in every log line that has to do with that request.  This can
be useful when looking at all the services that are hit by a single request.</p>
<p>If you need to know where a specific account, container or object is in the
cluster, <cite>swift-get-nodes</cite> will show the location where each replica should be.</p>
<p>If you are looking at an object on the server and need more info,
<cite>swift-object-info</cite> will display the account, container, replica locations
and metadata of the object.</p>
<p>If you are looking at a container on the server and need more info,
<cite>swift-container-info</cite> will display all the information like the account,
container, replica locations and metadata of the container.</p>
<p>If you are looking at an account on the server and need more info,
<cite>swift-account-info</cite> will display the account, replica locations
and metadata of the account.</p>
<p>If you want to audit the data for an account, <cite>swift-account-audit</cite> can be
used to crawl the account, checking that all containers and objects can be
found.</p>
</div>
<div class="section" id="managing-services">
<h2>Managing Services<a class="headerlink" href="#managing-services" title="Permalink to this headline">¶</a></h2>
<p>Swift services are generally managed with <cite>swift-init</cite>. the general usage is
<code class="docutils literal"><span class="pre">swift-init</span> <span class="pre">&lt;service&gt;</span> <span class="pre">&lt;command&gt;</span></code>, where service is the swift service to
manage (for example object, container, account, proxy) and command is one of:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Command</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>start</td>
<td>Start the service</td>
</tr>
<tr class="row-odd"><td>stop</td>
<td>Stop the service</td>
</tr>
<tr class="row-even"><td>restart</td>
<td>Restart the service</td>
</tr>
<tr class="row-odd"><td>shutdown</td>
<td>Attempt to gracefully shutdown the service</td>
</tr>
<tr class="row-even"><td>reload</td>
<td>Attempt to gracefully restart the service</td>
</tr>
</tbody>
</table>
<p>A graceful shutdown or reload will finish any current requests before
completely stopping the old service.  There is also a special case of
<cite>swift-init all &lt;command&gt;</cite>, which will run the command for all swift services.</p>
<p>In cases where there are multiple configs for a service, a specific config
can be managed with <code class="docutils literal"><span class="pre">swift-init</span> <span class="pre">&lt;service&gt;.&lt;config&gt;</span> <span class="pre">&lt;command&gt;</span></code>.
For example, when a separate replication network is used, there might be
<cite>/etc/swift/object-server/public.conf</cite> for the object server and
<cite>/etc/swift/object-server/replication.conf</cite> for the replication services.
In this case, the replication services could be restarted with
<code class="docutils literal"><span class="pre">swift-init</span> <span class="pre">object-server.replication</span> <span class="pre">restart</span></code>.</p>
</div>
<div class="section" id="object-auditor">
<h2>Object Auditor<a class="headerlink" href="#object-auditor" title="Permalink to this headline">¶</a></h2>
<p>On system failures, the XFS file system can sometimes truncate files it&#8217;s
trying to write and produce zero-byte files. The object-auditor will catch
these problems but in the case of a system crash it would be advisable to run
an extra, less rate limited sweep to check for these specific files. You can
run this command as follows:
<cite>swift-object-auditor /path/to/object-server/config/file.conf once -z 1000</cite>
&#8220;-z&#8221; means to only check for zero-byte files at 1000 files per second.</p>
<p>At times it is useful to be able to run the object auditor on a specific
device or set of devices.  You can run the object-auditor as follows:
swift-object-auditor /path/to/object-server/config/file.conf once &#8211;devices=sda,sdb</p>
<p>This will run the object auditor on only the sda and sdb devices. This param
accepts a comma separated list of values.</p>
</div>
<div class="section" id="object-replicator">
<h2>Object Replicator<a class="headerlink" href="#object-replicator" title="Permalink to this headline">¶</a></h2>
<p>At times it is useful to be able to run the object replicator on a specific
device or partition.  You can run the object-replicator as follows:
swift-object-replicator /path/to/object-server/config/file.conf once &#8211;devices=sda,sdb</p>
<p>This will run the object replicator on only the sda and sdb devices.  You can
likewise run that command with &#8211;partitions.  Both params accept a comma
separated list of values. If both are specified they will be ANDed together.
These can only be run in &#8220;once&#8221; mode.</p>
</div>
<div class="section" id="swift-orphans">
<h2>Swift Orphans<a class="headerlink" href="#swift-orphans" title="Permalink to this headline">¶</a></h2>
<p>Swift Orphans are processes left over after a reload of a Swift server.</p>
<p>For example, when upgrading a proxy server you would probably finish
with a <cite>swift-init proxy-server reload</cite> or <cite>/etc/init.d/swift-proxy
reload</cite>. This kills the parent proxy server process and leaves the
child processes running to finish processing whatever requests they
might be handling at the time. It then starts up a new parent proxy
server process and its children to handle new incoming requests. This
allows zero-downtime upgrades with no impact to existing requests.</p>
<p>The orphaned child processes may take a while to exit, depending on
the length of the requests they were handling. However, sometimes an
old process can be hung up due to some bug or hardware issue. In these
cases, these orphaned processes will hang around
forever. <cite>swift-orphans</cite> can be used to find and kill these orphans.</p>
<p><cite>swift-orphans</cite> with no arguments will just list the orphans it finds
that were started more than 24 hours ago. You shouldn&#8217;t really check
for orphans until 24 hours after you perform a reload, as some
requests can take a long time to process. <cite>swift-orphans -k TERM</cite> will
send the SIG_TERM signal to the orphans processes, or you can <cite>kill
-TERM</cite> the pids yourself if you prefer.</p>
<p>You can run <cite>swift-orphans &#8211;help</cite> for more options.</p>
</div>
<div class="section" id="swift-oldies">
<h2>Swift Oldies<a class="headerlink" href="#swift-oldies" title="Permalink to this headline">¶</a></h2>
<p>Swift Oldies are processes that have just been around for a long
time. There&#8217;s nothing necessarily wrong with this, but it might
indicate a hung process if you regularly upgrade and reload/restart
services. You might have so many servers that you don&#8217;t notice when a
reload/restart fails; <cite>swift-oldies</cite> can help with this.</p>
<p>For example, if you upgraded and reloaded/restarted everything 2 days
ago, and you&#8217;ve already cleaned up any orphans with <cite>swift-orphans</cite>,
you can run <cite>swift-oldies -a 48</cite> to find any Swift processes still
around that were started more than 2 days ago and then investigate
them accordingly.</p>
</div>
<div class="section" id="custom-log-handlers">
<h2>Custom Log Handlers<a class="headerlink" href="#custom-log-handlers" title="Permalink to this headline">¶</a></h2>
<p>Swift supports setting up custom log handlers for services by specifying a
comma-separated list of functions to invoke when logging is setup. It does so
via the <cite>log_custom_handlers</cite> configuration option. Logger hooks invoked are
passed the same arguments as Swift&#8217;s get_logger function (as well as the
getLogger and LogAdapter object):</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Name</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>conf</td>
<td>Configuration dict to read settings from</td>
</tr>
<tr class="row-odd"><td>name</td>
<td>Name of the logger received</td>
</tr>
<tr class="row-even"><td>log_to_console</td>
<td>(optional) Write log messages to console on stderr</td>
</tr>
<tr class="row-odd"><td>log_route</td>
<td>Route for the logging received</td>
</tr>
<tr class="row-even"><td>fmt</td>
<td>Override log format received</td>
</tr>
<tr class="row-odd"><td>logger</td>
<td>The logging.getLogger object</td>
</tr>
<tr class="row-even"><td>adapted_logger</td>
<td>The LogAdapter object</td>
</tr>
</tbody>
</table>
<p>A basic example that sets up a custom logger might look like the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_logger</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">log_to_console</span><span class="p">,</span> <span class="n">log_route</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span>
              <span class="n">adapted_logger</span><span class="p">):</span>
    <span class="n">my_conf_opt</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;some_custom_setting&#39;</span><span class="p">)</span>
    <span class="n">my_handler</span> <span class="o">=</span> <span class="n">third_party_logstore_handler</span><span class="p">(</span><span class="n">my_conf_opt</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">my_handler</span><span class="p">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="associated_projects.html#custom-logger-hooks-label"><span>Custom Logger Hooks</span></a> for sample use cases.</p>
</div>
<div class="section" id="securing-openstack-swift">
<h2>Securing OpenStack Swift<a class="headerlink" href="#securing-openstack-swift" title="Permalink to this headline">¶</a></h2>
<p>Please refer to the security guides at:</p>
<ul class="simple">
<li><a class="reference external" href="http://docs.openstack.org/sec/">http://docs.openstack.org/sec/</a></li>
<li><a class="reference external" href="http://docs.openstack.org/security-guide/content/object-storage.html">http://docs.openstack.org/security-guide/content/object-storage.html</a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Administrator&#8217;s Guide</a><ul>
<li><a class="reference internal" href="#defining-storage-policies">Defining Storage Policies</a></li>
<li><a class="reference internal" href="#managing-the-rings">Managing the Rings</a></li>
<li><a class="reference internal" href="#scripting-ring-creation">Scripting Ring Creation</a></li>
<li><a class="reference internal" href="#handling-system-updates">Handling System Updates</a></li>
<li><a class="reference internal" href="#handling-drive-failure">Handling Drive Failure</a></li>
<li><a class="reference internal" href="#handling-server-failure">Handling Server Failure</a></li>
<li><a class="reference internal" href="#detecting-failed-drives">Detecting Failed Drives</a></li>
<li><a class="reference internal" href="#preventing-disk-full-scenarios">Preventing Disk Full Scenarios</a></li>
<li><a class="reference internal" href="#dispersion-report">Dispersion Report</a></li>
<li><a class="reference internal" href="#geographically-distributed-swift-considerations">Geographically Distributed Swift Considerations</a><ul>
<li><a class="reference internal" href="#checking-handoff-partition-distribution">Checking handoff partition distribution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cluster-telemetry-and-monitoring">Cluster Telemetry and Monitoring</a></li>
<li><a class="reference internal" href="#reporting-metrics-to-statsd">Reporting Metrics to StatsD</a></li>
<li><a class="reference internal" href="#debugging-tips-and-tools">Debugging Tips and Tools</a></li>
<li><a class="reference internal" href="#managing-services">Managing Services</a></li>
<li><a class="reference internal" href="#object-auditor">Object Auditor</a></li>
<li><a class="reference internal" href="#object-replicator">Object Replicator</a></li>
<li><a class="reference internal" href="#swift-orphans">Swift Orphans</a></li>
<li><a class="reference internal" href="#swift-oldies">Swift Oldies</a></li>
<li><a class="reference internal" href="#custom-log-handlers">Custom Log Handlers</a></li>
<li><a class="reference internal" href="#securing-openstack-swift">Securing OpenStack Swift</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="apache_deployment_guide.html"
                                  title="previous chapter">Apache Deployment Guide</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="replication_network.html"
                                  title="next chapter">Dedicated replication network</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/swift
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/admin_guide.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="replication_network.html" title="Dedicated replication network"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="apache_deployment_guide.html" title="Apache Deployment Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">swift 2.12.1.dev102 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, OpenStack Foundation.
      Last updated on &#39;Tue Feb 14 07:57:22 2017, commit 7cb6882&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/swift");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>