<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Storage Policies &mdash; swift 2.12.1.dev102 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.12.1.dev102',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="swift 2.12.1.dev102 documentation" href="index.html" />
    <link rel="next" title="The Account Reaper" href="overview_reaper.html" />
    <link rel="prev" title="The Rings" href="overview_ring.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="storage-policies">
<h1>Storage Policies<a class="headerlink" href="#storage-policies" title="Permalink to this headline">¶</a></h1>
<p>Storage Policies allow for some level of segmenting the cluster for various
purposes through the creation of multiple object rings. The Storage Policies
feature is implemented throughout the entire code base so it is an important
concept in understanding Swift architecture.</p>
<p>As described in <a class="reference internal" href="overview_ring.html"><em>The Rings</em></a>, Swift uses modified hashing rings to
determine where data should reside in the cluster. There is a separate ring for
account databases, container databases, and there is also one object ring per
storage policy.  Each object ring behaves exactly the same way and is maintained
in the same manner, but with policies, different devices can belong to different
rings. By supporting multiple object rings, Swift allows the application and/or
deployer to essentially segregate the object storage within a single cluster.
There are many reasons why this might be desirable:</p>
<ul class="simple">
<li>Different levels of durability:  If a provider wants to offer, for example,
2x replication and 3x replication but doesn&#8217;t want to maintain 2 separate
clusters, they would setup a 2x and a 3x replication policy and assign the
nodes to their respective rings. Furthermore, if a provider wanted to offer a
cold storage tier, they could create an erasure coded policy.</li>
<li>Performance:  Just as SSDs can be used as the exclusive members of an account
or database ring, an SSD-only object ring can be created as well and used to
implement a low-latency/high performance policy.</li>
<li>Collecting nodes into group:  Different object rings may have different
physical servers so that objects in specific storage policies are always
placed in a particular data center or geography.</li>
<li>Different Storage implementations:  Another example would be to collect
together a set of nodes that use a different Diskfile (e.g., Kinetic,
GlusterFS) and use a policy to direct traffic just to those nodes.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Today, Swift supports two different policy types: Replication and Erasure
Code. See <a class="reference internal" href="overview_erasure_code.html"><em>Erasure Code Support</em></a> for details.</p>
<p class="last">Also note that Diskfile refers to backend object storage plug-in
architecture. See <a class="reference internal" href="development_ondisk_backends.html"><em>Pluggable On-Disk Back-end APIs</em></a> for details.</p>
</div>
<div class="section" id="containers-and-policies">
<h2>Containers and Policies<a class="headerlink" href="#containers-and-policies" title="Permalink to this headline">¶</a></h2>
<p>Policies are implemented at the container level.  There are many advantages to
this approach, not the least of which is how easy it makes life on
applications that want to take advantage of them.  It also ensures that
Storage Policies remain a core feature of Swift independent of the auth
implementation.  Policies were not implemented at the account/auth layer
because it would require changes to all auth systems in use by Swift
deployers.  Each container has a new special immutable metadata element called
the storage policy index.  Note that internally, Swift relies on policy
indexes and not policy names.  Policy names exist for human readability and
translation is managed in the proxy.  When a container is created, one new
optional header is supported to specify the policy name. If no name is
specified, the default policy is used (and if no other policies defined,
Policy-0 is considered the default).  We will be covering the difference
between default and Policy-0 in the next section.</p>
<p>Policies are assigned when a container is created.  Once a container has been
assigned a policy, it cannot be changed (unless it is deleted/recreated).  The
implications on data placement/movement for large datasets would make this a
task best left for applications to perform. Therefore, if a container has an
existing policy of, for example 3x replication, and one wanted to migrate that
data to an Erasure Code policy, the application would create another container
specifying the other policy parameters and then simply move the data from one
container to the other.  Policies apply on a per container basis allowing for
minimal application awareness; once a container has been created with a specific
policy, all objects stored in it will be done so in accordance with that policy.
If a container with a specific name is deleted (requires the container be empty)
a new container may be created with the same name without any restriction on
storage policy enforced by the deleted container which previously shared the
same name.</p>
<p>Containers have a many-to-one relationship with policies meaning that any number
of containers can share one policy.  There is no limit to how many containers
can use a specific policy.</p>
<p>The notion of associating a ring with a container introduces an interesting
scenario: What would happen if 2 containers of the same name were created with
different Storage Policies on either side of a network outage at the same time?
Furthermore, what would happen if objects were placed in those containers, a
whole bunch of them, and then later the network outage was restored?  Well,
without special care it would be a big problem as an application could end up
using the wrong ring to try and find an object.  Luckily there is a solution for
this problem, a daemon known as the Container Reconciler works tirelessly to
identify and rectify this potential scenario.</p>
</div>
<div class="section" id="container-reconciler">
<h2>Container Reconciler<a class="headerlink" href="#container-reconciler" title="Permalink to this headline">¶</a></h2>
<p>Because atomicity of container creation cannot be enforced in a
distributed eventually consistent system, object writes into the wrong
storage policy must be eventually merged into the correct storage policy
by an asynchronous daemon.  Recovery from object writes during a network
partition which resulted in a split brain container created with
different storage policies are handled by the
<cite>swift-container-reconciler</cite> daemon.</p>
<p>The container reconciler works off a queue similar to the
object-expirer.  The queue is populated during container-replication.
It is never considered incorrect to enqueue an object to be evaluated by
the container-reconciler because if there is nothing wrong with the location
of the object the reconciler will simply dequeue it.  The
container-reconciler queue is an indexed log for the real location of an
object for which a discrepancy in the storage policy of the container was
discovered.</p>
<p>To determine the correct storage policy of a container, it is necessary
to update the status_changed_at field in the container_stat table when a
container changes status from deleted to re-created.  This transaction
log allows the container-replicator to update the correct storage policy
both when replicating a container and handling REPLICATE requests.</p>
<p>Because each object write is a separate distributed transaction it is
not possible to determine the correctness of the storage policy for each
object write with respect to the entire transaction log at a given
container database.  As such, container databases will always record the
object write regardless of the storage policy on a per object row basis.
Object byte and count stats are tracked per storage policy in each
container and reconciled using normal object row merge semantics.</p>
<p>The object rows are ensured to be fully durable during replication using
the normal container replication.  After the container
replicator pushes its object rows to available primary nodes any
misplaced object rows are bulk loaded into containers based off the
object timestamp under the <code class="docutils literal"><span class="pre">.misplaced_objects</span></code> system account.  The
rows are initially written to a handoff container on the local node, and
at the end of the replication pass the <code class="docutils literal"><span class="pre">.misplaced_objects</span></code> containers are
replicated to the correct primary nodes.</p>
<p>The container-reconciler processes the <code class="docutils literal"><span class="pre">.misplaced_objects</span></code> containers in
descending order and reaps its containers as the objects represented by
the rows are successfully reconciled.  The container-reconciler will
always validate the correct storage policy for enqueued objects using
direct container HEAD requests which are accelerated via caching.</p>
<p>Because failure of individual storage nodes in aggregate is assumed to
be common at scale, the container-reconciler will make forward progress
with a simple quorum majority.  During a combination of failures and
rebalances it is possible that a quorum could provide an incomplete
record of the correct storage policy - so an object write may have to be
applied more than once.  Because storage nodes and container databases
will not process writes with an <code class="docutils literal"><span class="pre">X-Timestamp</span></code> less than or equal to
their existing record when objects writes are re-applied their timestamp
is slightly incremented.  In order for this increment to be applied
transparently to the client a second vector of time has been added to
Swift for internal use.  See <a class="reference internal" href="misc.html#swift.common.utils.Timestamp" title="swift.common.utils.Timestamp"><code class="xref py py-class docutils literal"><span class="pre">Timestamp</span></code></a>.</p>
<p>As the reconciler applies object writes to the correct storage policy it
cleans up writes which no longer apply to the incorrect storage policy
and removes the rows from the <code class="docutils literal"><span class="pre">.misplaced_objects</span></code> containers.  After all
rows have been successfully processed it sleeps and will periodically
check for newly enqueued rows to be discovered during container
replication.</p>
</div>
<div class="section" id="default-versus-policy-0">
<span id="default-policy"></span><h2>Default versus &#8216;Policy-0&#8217;<a class="headerlink" href="#default-versus-policy-0" title="Permalink to this headline">¶</a></h2>
<p>Storage Policies is a versatile feature intended to support both new and
pre-existing clusters with the same level of flexibility.  For that reason, we
introduce the <code class="docutils literal"><span class="pre">Policy-0</span></code> concept which is not the same as the &#8220;default&#8221;
policy.  As you will see when we begin to configure policies, each policy has
a single name and an arbitrary number of aliases (human friendly,
configurable) as well as an index (or simply policy number). Swift reserves
index 0 to map to the object ring that&#8217;s present in all installations
(e.g., <code class="docutils literal"><span class="pre">/etc/swift/object.ring.gz</span></code>). You can name this policy anything you
like, and if no policies are defined it will report itself as <code class="docutils literal"><span class="pre">Policy-0</span></code>,
however you cannot change the index as there must always be a policy with
index 0.</p>
<p>Another important concept is the default policy which can be any policy
in the cluster.  The default policy is the policy that is automatically
chosen when a container creation request is sent without a storage
policy being specified. <a class="reference internal" href="#configure-policy"><span>Configuring Policies</span></a> describes how to set the
default policy.  The difference from <code class="docutils literal"><span class="pre">Policy-0</span></code> is subtle but
extremely important.  <code class="docutils literal"><span class="pre">Policy-0</span></code> is what is used by Swift when
accessing pre-storage-policy containers which won&#8217;t have a policy - in
this case we would not use the default as it might not have the same
policy as legacy containers.  When no other policies are defined, Swift
will always choose <code class="docutils literal"><span class="pre">Policy-0</span></code> as the default.</p>
<p>In other words, default means &#8220;create using this policy if nothing else is
specified&#8221; and <code class="docutils literal"><span class="pre">Policy-0</span></code> means &#8220;use the legacy policy if a container doesn&#8217;t
have one&#8221; which really means use <code class="docutils literal"><span class="pre">object.ring.gz</span></code> for lookups.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With the Storage Policy based code, it&#8217;s not possible to create a
container that doesn&#8217;t have a policy.  If nothing is provided, Swift will
still select the default and assign it to the container.  For containers
created before Storage Policies were introduced, the legacy Policy-0 will
be used.</p>
</div>
</div>
<div class="section" id="deprecating-policies">
<span id="deprecate-policy"></span><h2>Deprecating Policies<a class="headerlink" href="#deprecating-policies" title="Permalink to this headline">¶</a></h2>
<p>There will be times when a policy is no longer desired; however simply
deleting the policy and associated rings would be problematic for existing
data.  In order to ensure that resources are not orphaned in the cluster (left
on disk but no longer accessible) and to provide proper messaging to
applications when a policy needs to be retired, the notion of deprecation is
used.  <a class="reference internal" href="#configure-policy"><span>Configuring Policies</span></a> describes how to deprecate a policy.</p>
<p>Swift&#8217;s behavior with deprecated policies is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>The deprecated policy will not appear in /info</li>
<li>PUT/GET/DELETE/POST/HEAD are still allowed on the pre-existing containers
created with a deprecated policy</li>
<li>Clients will get an &#8216;&#8216;400 Bad Request&#8217;&#8217; error when trying to create a new
container using the deprecated policy</li>
<li>Clients still have access to policy statistics via HEAD on pre-existing
containers</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A policy cannot be both the default and deprecated.  If you deprecate the
default policy, you must specify a new default.</p>
</div>
<p>You can also use the deprecated feature to rollout new policies.  If you
want to test a new storage policy before making it generally available
you could deprecate the policy when you initially roll it the new
configuration and rings to all nodes.  Being deprecated will render it
innate and unable to be used.  To test it you will need to create a
container with that storage policy; which will require a single proxy
instance (or a set of proxy-servers which are only internally
accessible) that has been one-off configured with the new policy NOT
marked deprecated.  Once the container has been created with the new
storage policy any client authorized to use that container will be able
to add and access data stored in that container in the new storage
policy.  When satisfied you can roll out a new <code class="docutils literal"><span class="pre">swift.conf</span></code> which does
not mark the policy as deprecated to all nodes.</p>
</div>
<div class="section" id="configuring-policies">
<span id="configure-policy"></span><h2>Configuring Policies<a class="headerlink" href="#configuring-policies" title="Permalink to this headline">¶</a></h2>
<p>Policies are configured in <code class="docutils literal"><span class="pre">swift.conf</span></code> and it is important that the deployer
have a solid understanding of the semantics for configuring policies.  Recall
that a policy must have a corresponding ring file, so configuring a policy is a
two-step process.  First, edit your <code class="docutils literal"><span class="pre">/etc/swift/swift.conf</span></code> file to add your
new policy and, second, create the corresponding policy object ring file.</p>
<p>See <a class="reference internal" href="policies_saio.html"><em>Adding Storage Policies to an Existing SAIO</em></a> for a step by step guide on adding a policy to the SAIO
setup.</p>
<p>Note that each policy has a section starting with <code class="docutils literal"><span class="pre">[storage-policy:N]</span></code> where N
is the policy index.  There&#8217;s no reason other than readability that these be
sequential but there are a number of rules enforced by Swift when parsing this
file:</p>
<blockquote>
<div><ul class="simple">
<li>If a policy with index 0 is not declared and no other policies defined,
Swift will create one</li>
<li>The policy index must be a non-negative integer</li>
<li>If no policy is declared as the default and no other policies are
defined, the policy with index 0 is set as the default</li>
<li>Policy indexes must be unique</li>
<li>Policy names are required</li>
<li>Policy names are case insensitive</li>
<li>Policy names must contain only letters, digits or a dash</li>
<li>Policy names must be unique</li>
<li>The policy name &#8216;Policy-0&#8217; can only be used for the policy with index 0</li>
<li>Multiple names can be assigned to one policy using aliases. All names
must follow the Swift naming rules.</li>
<li>If any policies are defined, exactly one policy must be declared default</li>
<li>Deprecated policies cannot be declared the default</li>
<li>If no <code class="docutils literal"><span class="pre">policy_type</span></code> is provided, <code class="docutils literal"><span class="pre">replication</span></code> is the default value.</li>
</ul>
</div></blockquote>
<p>The following is an example of a properly configured <code class="docutils literal"><span class="pre">swift.conf</span></code> file. See
<a class="reference internal" href="policies_saio.html"><em>Adding Storage Policies to an Existing SAIO</em></a> for full instructions on setting up an all-in-one with this
example configuration.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>[swift-hash]
# random unique strings that can never change (DO NOT LOSE)
# Use only printable chars (python -c &quot;import string; print(string.printable)&quot;)
swift_hash_path_prefix = changeme
swift_hash_path_suffix = changeme

[storage-policy:0]
name = gold
aliases = yellow, orange
policy_type = replication
default = yes

[storage-policy:1]
name = silver
policy_type = replication
deprecated = yes
</pre></div>
</div>
<p>Review <a class="reference internal" href="#default-policy"><span>Default versus &#8216;Policy-0&#8217;</span></a> and <a class="reference internal" href="#deprecate-policy"><span>Deprecating Policies</span></a> for more
information about the <code class="docutils literal"><span class="pre">default</span></code> and <code class="docutils literal"><span class="pre">deprecated</span></code> options.</p>
<p>There are some other considerations when managing policies:</p>
<blockquote>
<div><ul class="simple">
<li>Policy names can be changed.</li>
<li>Aliases are supported and can be added and removed. If the primary name
of a policy is removed the next available alias will be adopted as the
primary name. A policy must always have at least one name.</li>
<li>You cannot change the index of a policy once it has been created</li>
<li>The default policy can be changed at any time, by adding the
default directive to the desired policy section</li>
<li>Any policy may be deprecated by adding the deprecated directive to
the desired policy section, but a deprecated policy may not also
be declared the default, and you must specify a default - so you
must have policy which is not deprecated at all times.</li>
<li>The option <code class="docutils literal"><span class="pre">policy_type</span></code> is used to distinguish between different
policy types. The default value is <code class="docutils literal"><span class="pre">replication</span></code>. When defining an EC
policy use the value <code class="docutils literal"><span class="pre">erasure_coding</span></code>.</li>
<li>The EC policy has additional required parameters. See
<a class="reference internal" href="overview_erasure_code.html"><em>Erasure Code Support</em></a> for details.</li>
</ul>
</div></blockquote>
<p>Once <code class="docutils literal"><span class="pre">swift.conf</span></code> is configured for a new policy, a new ring must be created.
The ring tools are not policy name aware so it&#8217;s critical that the
correct policy index be used when creating the new policy&#8217;s ring file.
Additional object rings are created in the same manner as the legacy ring
except that &#8216;-N&#8217; is appended after the word <code class="docutils literal"><span class="pre">object</span></code> where N matches the
policy index used in <code class="docutils literal"><span class="pre">swift.conf</span></code>.  This naming convention follows the pattern
for per-policy storage node data directories as well.  So, to create the ring
for policy 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>swift-ring-builder object-1.builder create 10 3 1
&lt;and add devices, rebalance using the same naming convention&gt;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The same drives can indeed be used for multiple policies and the details
of how that&#8217;s managed on disk will be covered in a later section, it&#8217;s
important to understand the implications of such a configuration before
setting one up.  Make sure it&#8217;s really what you want to do, in many cases
it will be, but in others maybe not.</p>
</div>
</div>
<div class="section" id="using-policies">
<h2>Using Policies<a class="headerlink" href="#using-policies" title="Permalink to this headline">¶</a></h2>
<p>Using policies is very simple - a policy is only specified when a container is
initially created.  There are no other API changes.  Creating a container can
be done without any special policy information:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>curl -v -X PUT -H &#39;X-Auth-Token: &lt;your auth token&gt;&#39; \
    http://127.0.0.1:8080/v1/AUTH_test/myCont0
</pre></div>
</div>
<p>Which will result in a container created that is associated with the
policy name &#8216;gold&#8217; assuming we&#8217;re using the swift.conf example from
above.  It would use &#8216;gold&#8217; because it was specified as the default.
Now, when we put an object into this container, it will get placed on
nodes that are part of the ring we created for policy &#8216;gold&#8217;.</p>
<p>If we wanted to explicitly state that we wanted policy &#8216;gold&#8217; the command
would simply need to include a new header as shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>curl -v -X PUT -H &#39;X-Auth-Token: &lt;your auth token&gt;&#39; \
    -H &#39;X-Storage-Policy: gold&#39; http://127.0.0.1:8080/v1/AUTH_test/myCont0
</pre></div>
</div>
<p>And that&#8217;s it!  The application does not need to specify the policy name ever
again.  There are some illegal operations however:</p>
<ul class="simple">
<li>If an invalid (typo, non-existent) policy is specified: 400 Bad Request</li>
<li>if you try to change the policy either via PUT or POST: 409 Conflict</li>
</ul>
<p>If you&#8217;d like to see how the storage in the cluster is being used, simply HEAD
the account and you&#8217;ll see not only the cumulative numbers, as before, but
per policy statistics as well.  In the example below there&#8217;s 3 objects total
with two of them in policy &#8216;gold&#8217; and one in policy &#8216;silver&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>curl -i -X HEAD -H &#39;X-Auth-Token: &lt;your auth token&gt;&#39; \
    http://127.0.0.1:8080/v1/AUTH_test
</pre></div>
</div>
<p>and your results will include (some output removed for readability):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>X-Account-Container-Count: 3
X-Account-Object-Count: 3
X-Account-Bytes-Used: 21
X-Storage-Policy-Gold-Object-Count: 2
X-Storage-Policy-Gold-Bytes-Used: 14
X-Storage-Policy-Silver-Object-Count: 1
X-Storage-Policy-Silver-Bytes-Used: 7
</pre></div>
</div>
</div>
<div class="section" id="under-the-hood">
<h2>Under the Hood<a class="headerlink" href="#under-the-hood" title="Permalink to this headline">¶</a></h2>
<p>Now that we&#8217;ve explained a little about what Policies are and how to
configure/use them, let&#8217;s explore how Storage Policies fit in at the
nuts-n-bolts level.</p>
<div class="section" id="parsing-and-configuring">
<h3>Parsing and Configuring<a class="headerlink" href="#parsing-and-configuring" title="Permalink to this headline">¶</a></h3>
<p>The module, <a class="reference internal" href="misc.html#storage-policy"><span>Storage Policy</span></a>, is responsible for parsing the
<code class="docutils literal"><span class="pre">swift.conf</span></code> file, validating the input, and creating a global collection of
configured policies via class <a class="reference internal" href="misc.html#swift.common.storage_policy.StoragePolicyCollection" title="swift.common.storage_policy.StoragePolicyCollection"><code class="xref py py-class docutils literal"><span class="pre">StoragePolicyCollection</span></code></a>.  This
collection is made up of policies of class <a class="reference internal" href="misc.html#swift.common.storage_policy.StoragePolicy" title="swift.common.storage_policy.StoragePolicy"><code class="xref py py-class docutils literal"><span class="pre">StoragePolicy</span></code></a>. The
collection class includes handy functions for getting to a policy either by
name or by index , getting info about the policies, etc. There&#8217;s also one
very important function, <a class="reference internal" href="misc.html#swift.common.storage_policy.StoragePolicyCollection.get_object_ring" title="swift.common.storage_policy.StoragePolicyCollection.get_object_ring"><code class="xref py py-meth docutils literal"><span class="pre">get_object_ring()</span></code></a>.
Object rings are members of the <a class="reference internal" href="misc.html#swift.common.storage_policy.StoragePolicy" title="swift.common.storage_policy.StoragePolicy"><code class="xref py py-class docutils literal"><span class="pre">StoragePolicy</span></code></a> class and are
actually not instantiated until the <code class="xref py py-meth docutils literal"><span class="pre">load_ring()</span></code>
method is called.  Any caller anywhere in the code base that needs to access
an object ring must use the <code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> global singleton to access the
<a class="reference internal" href="misc.html#swift.common.storage_policy.StoragePolicyCollection.get_object_ring" title="swift.common.storage_policy.StoragePolicyCollection.get_object_ring"><code class="xref py py-meth docutils literal"><span class="pre">get_object_ring()</span></code></a> function and provide the
policy index which will call <code class="xref py py-meth docutils literal"><span class="pre">load_ring()</span></code> if
needed; however, when starting request handling services such as the
<a class="reference internal" href="proxy.html#proxy-server"><span>Proxy Server</span></a> rings are proactively loaded to provide moderate
protection against a mis-configuration resulting in a run time error.  The
global is instantiated when Swift starts and provides a mechanism to patch
policies for the test code.</p>
</div>
<div class="section" id="middleware">
<h3>Middleware<a class="headerlink" href="#middleware" title="Permalink to this headline">¶</a></h3>
<p>Middleware can take advantage of policies through the <code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> global
and by importing <a class="reference internal" href="proxy.html#swift.proxy.controllers.base.get_container_info" title="swift.proxy.controllers.base.get_container_info"><code class="xref py py-func docutils literal"><span class="pre">get_container_info()</span></code></a> to gain access to the policy index
associated with the container in question.  From the index it can then use the
<code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> singleton to grab the right ring.  For example,
<a class="reference internal" href="middleware.html#list-endpoints"><span>List Endpoints</span></a> is policy aware using the means just described. Another
example is <a class="reference internal" href="middleware.html#recon"><span>Recon</span></a> which will report the md5 sums for all of the rings.</p>
</div>
<div class="section" id="proxy-server">
<h3>Proxy Server<a class="headerlink" href="#proxy-server" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="proxy.html#proxy-server"><span>Proxy Server</span></a> module&#8217;s role in Storage Policies is essentially to make
sure the correct ring is used as its member element.  Before policies, the one
object ring would be instantiated when the <a class="reference internal" href="proxy.html#swift.proxy.server.Application" title="swift.proxy.server.Application"><code class="xref py py-class docutils literal"><span class="pre">Application</span></code></a> class was
instantiated and could be overridden by test code via init parameter.  With
policies, however, there is no init parameter and the <a class="reference internal" href="proxy.html#swift.proxy.server.Application" title="swift.proxy.server.Application"><code class="xref py py-class docutils literal"><span class="pre">Application</span></code></a>
class instead depends on the <code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> global singleton to retrieve the
ring which is instantiated the first time it&#8217;s needed.  So, instead of an object
ring member of the <a class="reference internal" href="proxy.html#swift.proxy.server.Application" title="swift.proxy.server.Application"><code class="xref py py-class docutils literal"><span class="pre">Application</span></code></a> class, there is an accessor function,
<a class="reference internal" href="proxy.html#swift.proxy.server.Application.get_object_ring" title="swift.proxy.server.Application.get_object_ring"><code class="xref py py-meth docutils literal"><span class="pre">get_object_ring()</span></code></a>, that gets the ring from
<code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code>.</p>
<p>In general, when any module running on the proxy requires an object ring, it
does so via first getting the policy index from the cached container info.  The
exception is during container creation where it uses the policy name from the
request header to look up policy index from the <code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> global.  Once
the proxy has determined the policy index, it can use the
<a class="reference internal" href="proxy.html#swift.proxy.server.Application.get_object_ring" title="swift.proxy.server.Application.get_object_ring"><code class="xref py py-meth docutils literal"><span class="pre">get_object_ring()</span></code></a> method described earlier to gain access to
the correct ring.  It then has the responsibility of passing the index
information, not the policy name, on to the back-end servers via the header <code class="docutils literal"><span class="pre">X</span>
<span class="pre">-Backend-Storage-Policy-Index</span></code>. Going the other way, the proxy also strips the
index out of headers that go back to clients, and makes sure they only see the
friendly policy names.</p>
</div>
<div class="section" id="on-disk-storage">
<h3>On Disk Storage<a class="headerlink" href="#on-disk-storage" title="Permalink to this headline">¶</a></h3>
<p>Policies each have their own directories on the back-end servers and are
identified by their storage policy indexes.  Organizing the back-end directory
structures by policy index helps keep track of things and also allows for
sharing of disks between policies which may or may not make sense depending on
the needs of the provider.  More on this later, but for now be aware of the
following directory naming convention:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">/objects</span></code> maps to objects associated with Policy-0</li>
<li><code class="docutils literal"><span class="pre">/objects-N</span></code> maps to storage policy index #N</li>
<li><code class="docutils literal"><span class="pre">/async_pending</span></code> maps to async pending update for Policy-0</li>
<li><code class="docutils literal"><span class="pre">/async_pending-N</span></code> maps to async pending update for storage policy index #N</li>
<li><code class="docutils literal"><span class="pre">/tmp</span></code> maps to the DiskFile temporary directory for Policy-0</li>
<li><code class="docutils literal"><span class="pre">/tmp-N</span></code> maps to the DiskFile temporary directory for policy index #N</li>
<li><code class="docutils literal"><span class="pre">/quarantined/objects</span></code> maps to the quarantine directory for Policy-0</li>
<li><code class="docutils literal"><span class="pre">/quarantined/objects-N</span></code> maps to the quarantine directory for policy index #N</li>
</ul>
<p>Note that these directory names are actually owned by the specific Diskfile
implementation, the names shown above are used by the default Diskfile.</p>
</div>
<div class="section" id="object-server">
<h3>Object Server<a class="headerlink" href="#object-server" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="object.html#object-server"><span>Object Server</span></a> is not involved with selecting the storage policy
placement directly.  However, because of how back-end directory structures are
setup for policies, as described earlier, the object server modules do play a
role.  When the object server gets a <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code>, it passes in the
policy index and leaves the actual directory naming/structure mechanisms to
<code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code>.  By passing in the index, the instance of
<code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> being used will assure that data is properly located in the
tree based on its policy.</p>
<p>For the same reason, the <a class="reference internal" href="object.html#object-updater"><span>Object Updater</span></a> also is policy aware.  As
previously described, different policies use different async pending directories
so the updater needs to know how to scan them appropriately.</p>
<p>The <a class="reference internal" href="object.html#object-replicator"><span>Object Replicator</span></a> is policy aware in that, depending on the policy,
it may have to do drastically different things, or maybe not.  For example, the
difference in handling a replication job for 2x versus 3x is trivial; however,
the difference in handling replication between 3x and erasure code is most
definitely not.  In fact, the term &#8216;replication&#8217; really isn&#8217;t appropriate for
some policies like erasure code; however, the majority of the framework for
collecting and processing jobs is common.  Thus, those functions in the
replicator are leveraged for all policies and then there is policy specific code
required for each policy, added when the policy is defined if needed.</p>
<p>The ssync functionality is policy aware for the same reason. Some of the
other modules may not obviously be affected, but the back-end directory
structure owned by <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> requires the policy index
parameter.  Therefore ssync being policy aware really means passing the
policy index along.  See <a class="reference internal" href="object.html#module-swift.obj.ssync_sender" title="swift.obj.ssync_sender"><code class="xref py py-class docutils literal"><span class="pre">ssync_sender</span></code></a> and
<a class="reference internal" href="object.html#module-swift.obj.ssync_receiver" title="swift.obj.ssync_receiver"><code class="xref py py-class docutils literal"><span class="pre">ssync_receiver</span></code></a> for more information on ssync.</p>
<p>For <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> itself, being policy aware is all about managing the
back-end structure using the provided policy index.  In other words, callers who
get a <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> instance provide a policy index and
<code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code>&#8216;s job is to keep data separated via this index (however it
chooses) such that policies can share the same media/nodes if desired.  The
included implementation of <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> lays out the directory structure
described earlier but that&#8217;s owned within <code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code>; external modules
have no visibility into that detail.  A common function is provided to map
various directory names and/or strings based on their policy index. For example
<code class="xref py py-class docutils literal"><span class="pre">Diskfile</span></code> defines <code class="xref py py-func docutils literal"><span class="pre">get_data_dir()</span></code> which builds off of a generic
<a class="reference internal" href="misc.html#swift.common.storage_policy.get_policy_string" title="swift.common.storage_policy.get_policy_string"><code class="xref py py-func docutils literal"><span class="pre">get_policy_string()</span></code></a> to consistently build policy aware strings for
various usage.</p>
</div>
<div class="section" id="container-server">
<h3>Container Server<a class="headerlink" href="#container-server" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="container.html#container-server"><span>Container Server</span></a> plays a very important role in Storage Policies, it
is responsible for handling the assignment of a policy to a container and the
prevention of bad things like changing policies or picking the wrong policy to
use when nothing is specified (recall earlier discussion on Policy-0 versus
default).</p>
<p>The <a class="reference internal" href="container.html#container-updater"><span>Container Updater</span></a> is policy aware, however its job is very simple, to
pass the policy index along to the <a class="reference internal" href="account.html#account-server"><span>Account Server</span></a> via a request header.</p>
<p>The <a class="reference internal" href="container.html#container-backend"><span>Container Backend</span></a> is responsible for both altering existing DB
schema as well as assuring new DBs are created with a schema that supports
storage policies.  The &#8220;on-demand&#8221; migration of container schemas allows Swift
to upgrade without downtime (sqlite&#8217;s alter statements are fast regardless of
row count).  To support rolling upgrades (and downgrades) the incompatible
schema changes to the <code class="docutils literal"><span class="pre">container_stat</span></code> table are made to a
<code class="docutils literal"><span class="pre">container_info</span></code> table, and the <code class="docutils literal"><span class="pre">container_stat</span></code> table is replaced with a
view that includes an <code class="docutils literal"><span class="pre">INSTEAD</span> <span class="pre">OF</span> <span class="pre">UPDATE</span></code> trigger which makes it behave like
the old table.</p>
<p>The policy index is stored here for use in reporting information
about the container as well as managing split-brain scenario induced
discrepancies between containers and their storage policies.  Furthermore,
during split-brain, containers must be prepared to track object updates from
multiple policies so the object table also includes a
<code class="docutils literal"><span class="pre">storage_policy_index</span></code> column.  Per-policy object counts and bytes are
updated in the <code class="docutils literal"><span class="pre">policy_stat</span></code> table using <code class="docutils literal"><span class="pre">INSERT</span></code> and <code class="docutils literal"><span class="pre">DELETE</span></code> triggers
similar to the pre-policy triggers that updated <code class="docutils literal"><span class="pre">container_stat</span></code> directly.</p>
<p>The <a class="reference internal" href="container.html#container-replicator"><span>Container Replicator</span></a> daemon will pro-actively migrate legacy
schemas as part of its normal consistency checking process when it updates the
<code class="docutils literal"><span class="pre">reconciler_sync_point</span></code> entry in the <code class="docutils literal"><span class="pre">container_info</span></code> table.  This ensures
that read heavy containers which do not encounter any writes will still get
migrated to be fully compatible with the post-storage-policy queries without
having to fall back and retry queries with the legacy schema to service
container read requests.</p>
<p>The <a class="reference internal" href="container.html#container-sync-daemon"><span>Container Sync</span></a> functionality only needs to be policy aware in
that it accesses the object rings.  Therefore, it needs to pull the policy index
out of the container information and use it to select the appropriate object
ring from the <code class="xref py py-data docutils literal"><span class="pre">POLICIES</span></code> global.</p>
</div>
<div class="section" id="account-server">
<h3>Account Server<a class="headerlink" href="#account-server" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="account.html#account-server"><span>Account Server</span></a>&#8216;s role in Storage Policies is really limited to
reporting. When a HEAD request is made on an account (see example provided
earlier), the account server is provided with the storage policy index and
builds the <code class="docutils literal"><span class="pre">object_count</span></code> and <code class="docutils literal"><span class="pre">byte_count</span></code> information for the client on a
per policy basis.</p>
<p>The account servers are able to report per-storage-policy object and byte
counts because of some policy specific DB schema changes.  A policy specific
table, <code class="docutils literal"><span class="pre">policy_stat</span></code>, maintains information on a per policy basis (one row
per policy) in the same manner in which the <code class="docutils literal"><span class="pre">account_stat</span></code> table does.  The
<code class="docutils literal"><span class="pre">account_stat</span></code> table still serves the same purpose and is not replaced by
<code class="docutils literal"><span class="pre">policy_stat</span></code>, it holds the total account stats whereas <code class="docutils literal"><span class="pre">policy_stat</span></code> just
has the break downs.  The backend is also responsible for migrating
pre-storage-policy accounts by altering the DB schema and populating the
<code class="docutils literal"><span class="pre">policy_stat</span></code> table for Policy-0 with current <code class="docutils literal"><span class="pre">account_stat</span></code> data at that
point in time.</p>
<p>The per-storage-policy object and byte counts are not updated with each object
PUT and DELETE request, instead container updates to the account server are
performed asynchronously by the <code class="docutils literal"><span class="pre">swift-container-updater</span></code>.</p>
</div>
<div class="section" id="upgrading-and-confirming-functionality">
<span id="upgrade-policy"></span><h3>Upgrading and Confirming Functionality<a class="headerlink" href="#upgrading-and-confirming-functionality" title="Permalink to this headline">¶</a></h3>
<p>Upgrading to a version of Swift that has Storage Policy support is not
difficult, in fact, the cluster administrator isn&#8217;t required to make any special
configuration changes to get going.  Swift will automatically begin using the
existing object ring as both the default ring and the Policy-0 ring.  Adding the
declaration of policy 0 is totally optional and in its absence, the name given
to the implicit policy 0 will be &#8216;Policy-0&#8217;.  Let&#8217;s say for testing purposes
that you wanted to take an existing cluster that already has lots of data on it
and upgrade to Swift with Storage Policies. From there you want to go ahead and
create a policy and test a few things out.  All you need to do is:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Upgrade all of your Swift nodes to a policy-aware version of Swift</li>
<li>Define your policies in <code class="docutils literal"><span class="pre">/etc/swift/swift.conf</span></code></li>
<li>Create the corresponding object rings</li>
<li>Create containers and objects and confirm their placement is as expected</li>
</ol>
</div></blockquote>
<p>For a specific example that takes you through these steps, please see
<a class="reference internal" href="policies_saio.html"><em>Adding Storage Policies to an Existing SAIO</em></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you downgrade from a Storage Policy enabled version of Swift to an
older version that doesn&#8217;t support policies, you will not be able to
access any data stored in policies other than the policy with index 0 but
those objects WILL appear in container listings (possibly as duplicates if
there was a network partition and un-reconciled objects).  It is EXTREMELY
important that you perform any necessary integration testing on the
upgraded deployment before enabling an additional storage policy to ensure
a consistent API experience for your clients.  DO NOT downgrade to a
version of Swift that does not support storage policies once you expose
multiple storage policies.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Storage Policies</a><ul>
<li><a class="reference internal" href="#containers-and-policies">Containers and Policies</a></li>
<li><a class="reference internal" href="#container-reconciler">Container Reconciler</a></li>
<li><a class="reference internal" href="#default-versus-policy-0">Default versus &#8216;Policy-0&#8217;</a></li>
<li><a class="reference internal" href="#deprecating-policies">Deprecating Policies</a></li>
<li><a class="reference internal" href="#configuring-policies">Configuring Policies</a></li>
<li><a class="reference internal" href="#using-policies">Using Policies</a></li>
<li><a class="reference internal" href="#under-the-hood">Under the Hood</a><ul>
<li><a class="reference internal" href="#parsing-and-configuring">Parsing and Configuring</a></li>
<li><a class="reference internal" href="#middleware">Middleware</a></li>
<li><a class="reference internal" href="#proxy-server">Proxy Server</a></li>
<li><a class="reference internal" href="#on-disk-storage">On Disk Storage</a></li>
<li><a class="reference internal" href="#object-server">Object Server</a></li>
<li><a class="reference internal" href="#container-server">Container Server</a></li>
<li><a class="reference internal" href="#account-server">Account Server</a></li>
<li><a class="reference internal" href="#upgrading-and-confirming-functionality">Upgrading and Confirming Functionality</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="overview_ring.html"
                                  title="previous chapter">The Rings</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="overview_reaper.html"
                                  title="next chapter">The Account Reaper</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/swift
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/overview_policies.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="overview_reaper.html" title="The Account Reaper"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="overview_ring.html" title="The Rings"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">swift 2.12.1.dev102 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, OpenStack Foundation.
      Last updated on &#39;Tue Feb 14 07:57:22 2017, commit 7cb6882&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/swift");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>