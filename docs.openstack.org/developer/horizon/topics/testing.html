<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Testing Topic Guide &mdash; horizon 11.0.0.0rc2.dev56 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '11.0.0.0rc2.dev56',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="horizon 11.0.0.0rc2.dev56 documentation" href="../index.html" />
    <link rel="next" title="AngularJS Topic Guide" href="angularjs.html" />
    <link rel="prev" title="Horizon Policy Enforcement (RBAC: Role Based Access Control)" href="policy.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="testing-topic-guide">
<h1>Testing Topic Guide<a class="headerlink" href="#testing-topic-guide" title="Permalink to this headline">¶</a></h1>
<p>Having good tests in place is absolutely critical for ensuring a stable,
maintainable codebase. Hopefully that doesn&#8217;t need any more explanation.</p>
<p>However, what defines a &#8220;good&#8221; test is not always obvious, and there are
a lot of common pitfalls that can easily shoot your test suite in the
foot.</p>
<p>If you already know everything about testing but are fed up with trying to
debug why a specific test failed, you can skip the intro and jump
straight to <a class="reference internal" href="#debugging-unit-tests"><span>Debugging Unit Tests</span></a>.</p>
<div class="section" id="an-overview-of-testing">
<h2>An overview of testing<a class="headerlink" href="#an-overview-of-testing" title="Permalink to this headline">¶</a></h2>
<p>There are three main types of tests, each with their associated pros and cons:</p>
<div class="section" id="unit-tests">
<h3>Unit tests<a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h3>
<p>These are isolated, stand-alone tests with no external dependencies. They are
written from the perspective of &#8220;knowing the code&#8221;, and test the assumptions
of the codebase and the developer.</p>
<p>Pros:</p>
<ul class="simple">
<li>Generally lightweight and fast.</li>
<li>Can be run anywhere, anytime since they have no external dependencies.</li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li>Easy to be lax in writing them, or lazy in constructing them.</li>
<li>Can&#8217;t test interactions with live external services.</li>
</ul>
</div>
<div class="section" id="functional-tests">
<h3>Functional tests<a class="headerlink" href="#functional-tests" title="Permalink to this headline">¶</a></h3>
<p>These are generally also isolated tests, though sometimes they may interact
with other services running locally. The key difference between functional
tests and unit tests, however, is that functional tests are written from the
perspective of the user (who knows nothing about the code) and only knows
what they put in and what they get back. Essentially this is a higher-level
testing of &#8220;does the result match the spec?&#8221;.</p>
<p>Pros:</p>
<ul class="simple">
<li>Ensures that your code <em>always</em> meets the stated functional requirements.</li>
<li>Verifies things from an &#8220;end user&#8221; perspective, which helps to ensure
a high-quality experience.</li>
<li>Designing your code with a functional testing perspective in mind helps
keep a higher-level viewpoint in mind.</li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li>Requires an additional layer of thinking to define functional requirements
in terms of inputs and outputs.</li>
<li>Often requires writing a separate set of tests and/or using a different
testing framework from your unit tests.</li>
<li>Doesn&#8217;t offer any insight into the quality or status of the underlying code,
only verifies that it works or it doesn&#8217;t.</li>
</ul>
</div>
<div class="section" id="integration-tests">
<h3>Integration Tests<a class="headerlink" href="#integration-tests" title="Permalink to this headline">¶</a></h3>
<p>This layer of testing involves testing all of the components that your
codebase interacts with or relies on in conjunction. This is equivalent to
&#8220;live&#8221; testing, but in a repeatable manner.</p>
<p>Pros:</p>
<ul class="simple">
<li>Catches <em>many</em> bugs that unit and functional tests will not.</li>
<li>Doesn&#8217;t rely on assumptions about the inputs and outputs.</li>
<li>Will warn you when changes in external components break your code.</li>
<li>Will take screenshot of the current page on test fail for easy debug</li>
</ul>
<p>Cons:</p>
<ul class="simple">
<li>Difficult and time-consuming to create a repeatable test environment.</li>
<li>Did I mention that setting it up is a pain?</li>
</ul>
<dl class="docutils">
<dt>Screenshot directory could be set through horizon.conf file, default value:</dt>
<dd>&#8221;./integration_tests_screenshots&#8221;</dd>
</dl>
</div>
<div class="section" id="so-what-should-i-write">
<h3>So what should I write?<a class="headerlink" href="#so-what-should-i-write" title="Permalink to this headline">¶</a></h3>
<p>A few simple guidelines:</p>
<ol class="arabic simple">
<li>Every bug fix should have a regression test. Period.</li>
<li>When writing a new feature, think about writing unit tests to verify
the behavior step-by-step as you write the feature. Every time you&#8217;d
go to run your code by hand and verify it manually, think &#8220;could I
write a test to do this instead?&#8221;. That way when the feature is done
and you&#8217;re ready to commit it you&#8217;ve already got a whole set of tests
that are more thorough than anything you&#8217;d write after the fact.</li>
<li>Write tests that hit every view in your application. Even if they
don&#8217;t assert a single thing about the code, it tells you that your
users aren&#8217;t getting fatal errors just by interacting with your code.</li>
</ol>
</div>
</div>
<div class="section" id="what-makes-a-good-unit-test">
<h2>What makes a good unit test?<a class="headerlink" href="#what-makes-a-good-unit-test" title="Permalink to this headline">¶</a></h2>
<p>Limiting our focus just to unit tests, there are a number of things you can
do to make your unit tests as useful, maintainable, and unburdensome as
possible.</p>
<div class="section" id="test-data">
<h3>Test data<a class="headerlink" href="#test-data" title="Permalink to this headline">¶</a></h3>
<p>Use a single, consistent set of test data. Grow it over time, but do everything
you can not to fragment it. It quickly becomes unmaintainable and perniciously
out-of-sync with reality.</p>
<p>Make your test data as accurate to reality as possible. Supply <em>all</em> the
attributes of an object, provide objects in all the various states you may want
to test.</p>
<p>If you do the first suggestion above <em>first</em> it makes the second one far less
painful. Write once, use everywhere.</p>
<p>To make your life even easier, if your codebase doesn&#8217;t have a built-in
ORM-like function to manage your test data you can consider building (or
borrowing) one yourself. Being able to do simple retrieval queries on your
test data is incredibly valuable.</p>
</div>
<div class="section" id="mocking">
<h3>Mocking<a class="headerlink" href="#mocking" title="Permalink to this headline">¶</a></h3>
<p>Mocking is the practice of providing stand-ins for objects or pieces of code
you don&#8217;t need to test. While convenient, they should be used with <em>extreme</em>
caution.</p>
<p>Why? Because overuse of mocks can rapidly land you in a situation where you&#8217;re
not testing any real code. All you&#8217;ve done is verified that your mocking
framework returns what you tell it to. This problem can be very tricky to
recognize, since you may be mocking things in <code class="docutils literal"><span class="pre">setUp</span></code> methods, other modules,
etc.</p>
<p>A good rule of thumb is to mock as close to the source as possible. If you have
a function call that calls an external API in a view , mock out the external
API, not the whole function. If you mock the whole function you&#8217;ve suddenly
lost test coverage for an entire chunk of code <em>inside</em> your codebase. Cut the
ties cleanly right where your system ends and the external world begins.</p>
<p>Similarly, don&#8217;t mock return values when you could construct a real return
value of the correct type with the correct attributes. You&#8217;re just adding
another point of potential failure by exercising your mocking framework instead
of real code. Following the suggestions for testing above will make this a lot
less burdensome.</p>
</div>
<div class="section" id="assertions-and-verification">
<h3>Assertions and verification<a class="headerlink" href="#assertions-and-verification" title="Permalink to this headline">¶</a></h3>
<p>Think long and hard about what you really want to verify in your unit test. In
particular, think about what custom logic your code executes.</p>
<p>A common pitfall is to take a known test object, pass it through your code,
and then verify the properties of that object on the output. This is all well
and good, except if you&#8217;re verifying properties that were untouched by your
code. What you want to check are the pieces that were <em>changed</em>, <em>added</em>, or
<em>removed</em>. Don&#8217;t check the object&#8217;s id attribute unless you have reason to
suspect it&#8217;s not the object you started with. But if you added a new attribute
to it, be damn sure you verify that came out right.</p>
<p>It&#8217;s also very common to avoid testing things you really care about because
it&#8217;s more difficult. Verifying that the proper messages were displayed to the
user after an action, testing for form errors, making sure exception handling
is tested... these types of things aren&#8217;t always easy, but they&#8217;re extremely
necessary.</p>
<p>To that end, Horizon includes several custom assertions to make these tasks
easier. <a class="reference internal" href="../ref/test.html#openstack_dashboard.test.helpers.TestCase.assertNoFormErrors" title="openstack_dashboard.test.helpers.TestCase.assertNoFormErrors"><code class="xref py py-meth docutils literal"><span class="pre">assertNoFormErrors()</span></code></a>,
<a class="reference internal" href="../ref/test.html#horizon.test.helpers.TestCase.assertMessageCount" title="horizon.test.helpers.TestCase.assertMessageCount"><code class="xref py py-meth docutils literal"><span class="pre">assertMessageCount()</span></code></a>, and
<a class="reference internal" href="../ref/test.html#horizon.test.helpers.TestCase.assertNoMessages" title="horizon.test.helpers.TestCase.assertNoMessages"><code class="xref py py-meth docutils literal"><span class="pre">assertNoMessages()</span></code></a> all exist for exactly
these purposes. Moreover, they provide useful output when things go wrong so
you&#8217;re not left scratching your head wondering why your view test didn&#8217;t
redirect as expected when you posted a form.</p>
</div>
</div>
<div class="section" id="debugging-unit-tests">
<span id="id1"></span><h2>Debugging Unit Tests<a class="headerlink" href="#debugging-unit-tests" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tips-and-tricks">
<h3>Tips and tricks<a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Use <a class="reference internal" href="../ref/test.html#openstack_dashboard.test.helpers.TestCase.assertNoFormErrors" title="openstack_dashboard.test.helpers.TestCase.assertNoFormErrors"><code class="xref py py-meth docutils literal"><span class="pre">assertNoFormErrors()</span></code></a>
immediately after your <code class="docutils literal"><span class="pre">client.post</span></code> call for tests that handle form views.
This will immediately fail if your form POST failed due to a validation error
and tell you what the error was.</p>
</li>
<li><p class="first">Use <a class="reference internal" href="../ref/test.html#horizon.test.helpers.TestCase.assertMessageCount" title="horizon.test.helpers.TestCase.assertMessageCount"><code class="xref py py-meth docutils literal"><span class="pre">assertMessageCount()</span></code></a> and
<a class="reference internal" href="../ref/test.html#horizon.test.helpers.TestCase.assertNoMessages" title="horizon.test.helpers.TestCase.assertNoMessages"><code class="xref py py-meth docutils literal"><span class="pre">assertNoMessages()</span></code></a> when a piece of code
is failing inexplicably. Since the core error handlers attach user-facing
error messages (and since the core logging is silenced during test runs)
these methods give you the dual benefit of verifying the output you expect
while clearly showing you the problematic error message if they fail.</p>
</li>
<li><p class="first">Use Python&#8217;s <code class="docutils literal"><span class="pre">pdb</span></code> module liberally. Many people don&#8217;t realize it works
just as well in a test case as it does in a live view. Simply inserting
<code class="docutils literal"><span class="pre">import</span> <span class="pre">pdb;</span> <span class="pre">pdb.set_trace()</span></code> anywhere in your codebase will drop the
interpreter into an interactive shell so you can explore your test
environment and see which of your assumptions about the code isn&#8217;t,
in fact, flawlessly correct.</p>
</li>
<li><p class="first">If the error is in the Selenium test suite, you&#8217;re likely getting very little
information about the error. To increase the information provided to you,
edit <code class="docutils literal"><span class="pre">horizon/test/settings.py</span></code> to set <code class="docutils literal"><span class="pre">DEBUG</span> <span class="pre">=</span> <span class="pre">True</span></code> and set the logging
level to &#8216;DEBUG&#8217; for the default &#8216;test&#8217; logger. Also, add a logger config
for Django:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>     },
     &#39;loggers&#39;: {
+        &#39;django&#39;: {
+            &#39;handlers&#39;: [&#39;test&#39;],
+            &#39;propagate&#39;: False,
+        },
         &#39;django.db.backends&#39;: {
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="common-pitfalls">
<h3>Common pitfalls<a class="headerlink" href="#common-pitfalls" title="Permalink to this headline">¶</a></h3>
<p>There are a number of typical (and non-obvious) ways to break the unit tests.
Some common things to look for:</p>
<ol class="arabic simple">
<li>Make sure you stub out the method exactly as it&#8217;s called in the code
being tested. For example, if your real code calls
<code class="docutils literal"><span class="pre">api.keystone.tenant_get</span></code>, stubbing out <code class="docutils literal"><span class="pre">api.tenant_get</span></code> (available
for legacy reasons) will fail.</li>
<li>When defining the expected input to a stubbed call, make sure the
arguments are <em>identical</em>, this includes <code class="docutils literal"><span class="pre">str</span></code> vs. <code class="docutils literal"><span class="pre">int</span></code> differences.</li>
<li>Make sure your test data are completely in line with the expected inputs.
Again, <code class="docutils literal"><span class="pre">str</span></code> vs. <code class="docutils literal"><span class="pre">int</span></code> or missing properties on test objects will
kill your tests.</li>
<li>Make sure there&#8217;s nothing amiss in your templates (particularly the
<code class="docutils literal"><span class="pre">{%</span> <span class="pre">url</span> <span class="pre">%}</span></code> tag and its arguments). This often comes up when refactoring
views or renaming context variables. It can easily result in errors that
you might not stumble across while clicking around the development server.</li>
<li>Make sure you&#8217;re not redirecting to views that no longer exist, e.g.
the <code class="docutils literal"><span class="pre">index</span></code> view for a panel that got combined (such as instances &amp;
volumes).</li>
<li>Make sure your mock calls are in order before calling <code class="docutils literal"><span class="pre">mox.ReplayAll</span></code>.
The order matters.</li>
<li>Make sure you repeat any stubbed out method calls that happen more than
once. They don&#8217;t automatically repeat, you have to explicitly define them.
While this is a nuisance, it makes you acutely aware of how many API
calls are involved in a particular function.</li>
</ol>
</div>
<div class="section" id="understanding-the-output-from-mox">
<h3>Understanding the output from <code class="docutils literal"><span class="pre">mox</span></code><a class="headerlink" href="#understanding-the-output-from-mox" title="Permalink to this headline">¶</a></h3>
<p>Horizon uses <code class="docutils literal"><span class="pre">mox</span></code> as its mocking framework of choice, and while it
offers many nice features, its output when a test fails can be quite
mysterious.</p>
<div class="section" id="unexpected-method-call">
<h4>Unexpected Method Call<a class="headerlink" href="#unexpected-method-call" title="Permalink to this headline">¶</a></h4>
<p>This occurs when you stubbed out a piece of code, and it was subsequently
called in a way that you didn&#8217;t specify it would be. There are two reasons
this tends to come up:</p>
<ol class="arabic simple">
<li>You defined the expected call, but a subtle difference crept in. This
may be a string versus integer difference, a string versus unicode
difference, a slightly off date/time, or passing a name instead of an id.</li>
<li>The method is actually being called <em>multiple times</em>. Since mox uses
a call stack internally, it simply pops off the expected method calls to
verify them. That means once a call is used once, it&#8217;s gone. An easy way
to see if this is the case is simply to copy and paste your method call a
second time to see if the error changes. If it does, that means your method
is being called more times than you think it is.</li>
</ol>
</div>
<div class="section" id="expected-method-never-called">
<h4>Expected Method Never Called<a class="headerlink" href="#expected-method-never-called" title="Permalink to this headline">¶</a></h4>
<p>This one is the opposite of the unexpected method call. This one means you
told mox to expect a call and it didn&#8217;t happen. This is almost always the
result of an error in the conditions of the test. Using the
<a class="reference internal" href="../ref/test.html#openstack_dashboard.test.helpers.TestCase.assertNoFormErrors" title="openstack_dashboard.test.helpers.TestCase.assertNoFormErrors"><code class="xref py py-meth docutils literal"><span class="pre">assertNoFormErrors()</span></code></a> and
<a class="reference internal" href="../ref/test.html#horizon.test.helpers.TestCase.assertMessageCount" title="horizon.test.helpers.TestCase.assertMessageCount"><code class="xref py py-meth docutils literal"><span class="pre">assertMessageCount()</span></code></a> will make it readily
apparent what the problem is in the majority of cases. If not, then use <code class="docutils literal"><span class="pre">pdb</span></code>
and start interrupting the code flow to see where things are getting off track.</p>
</div>
</div>
</div>
<div class="section" id="integration-tests-in-horizon">
<h2>Integration tests in Horizon<a class="headerlink" href="#integration-tests-in-horizon" title="Permalink to this headline">¶</a></h2>
<p>The integration tests currently live in the Horizon repository, see <a class="reference external" href="https://github.com/openstack/horizon/tree/master/openstack_dashboard/test/integration_tests">here</a>,
which also contains instructions on how to run the tests. To make integration
tests more understandable and maintainable, the Page Object pattern is used
throughout them.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">To enable integration tests support before running them, please
copy openstack_dashboard/local/local_settings.d/_20_integration_tests_scaffolds.py.example
to openstack_dashboard/local/local_settings.d/_20_integration_tests_scaffolds.py
and then run ./manage.py collectstatic &#8211;clear &amp;&amp; ./manage.py compress.</p>
</div>
<p>Horizon repository also provides two shell <a class="reference external" href="https://github.com/openstack/horizon/tree/master/tools/gate/integration">scripts</a>, which are executed in
pre_test_hook and post_test_hook respectively. Pre hook is generally used for
modifying test environment, while post hook is used for running actual
integration tests with tox and collecting test artifacts. Thanks to the
incorporating all modifications to tests into Horizon repository, one can alter
both tests and test environment and see the immediate results in Jenkins job
output.</p>
<div class="section" id="page-object-pattern">
<h3>Page Object pattern<a class="headerlink" href="#page-object-pattern" title="Permalink to this headline">¶</a></h3>
<p>Within any web application&#8217;s user interface (UI) there are areas that the tests
interact with. A Page Object simply models these as objects within the test
code. This reduces the amount of duplicated code; if the UI changes, the fix
needs only be applied in one place.</p>
<p>Page Objects can be thought of as facing in two directions simultaneously.
Facing towards the developer of a test, they represent the services offered by
a particular page. Facing away from the developer, they should be the only
thing that has a deep knowledge of the structure of the HTML of a page (or
part of a page). It is simplest to think of the methods on a Page Object as
offering the &#8220;services&#8221; that a page offers rather than exposing the details
and mechanics of the page. As an example, think of the inbox of any web-based
email system. Amongst the services that it offers are typically the ability to
compose a new email, to choose to read a single email, and to list the subject
lines of the emails in the inbox. How these are implemented should not matter
to the test.</p>
</div>
<div class="section" id="writing-reusable-and-maintainable-page-objects">
<h3>Writing reusable and maintainable Page Objects<a class="headerlink" href="#writing-reusable-and-maintainable-page-objects" title="Permalink to this headline">¶</a></h3>
<p>Because the main idea is to encourage the developer of a test to try and think
about the services that they are interacting with rather than the
implementation, Page Objects should seldom expose the underlying WebDriver
instance. To facilitate this, methods on the Page Object should return other
Page Objects. This means that we can effectively model the user&#8217;s journey
through the application.</p>
<p>Another important thing to mention is that a Page Object need not represent an
entire page. It may represent a section that appears many times within a site
or page, such as site navigation. The essential principle is that there is
only one place in your test suite with knowledge of the structure of the HTML
of a particular (part of a) page. With this in mind, a test developer builds
up regions that become reusable components (<a class="reference external" href="https://github.com/openstack/horizon/blob/8.0.0/openstack_dashboard/test/integration_tests/regions/forms.py#L250">example of a base form</a>). These
properties can then be redefined or overridden (e.g. selectors) in the actual
pages (subclasses) (<a class="reference external" href="https://github.com/openstack/horizon/blob/8.0.0/openstack_dashboard/test/integration_tests/regions/forms.py#L322">example of a tabbed form</a>).</p>
<p>The page objects are read-only and define the read-only and clickable elements
of a page, which work to shield the tests. For instance, from the test
perspective, if &#8220;Logout&#8221; used to be a link but suddenly becomes an option in a
drop-down menu, there are no changes (in the test itself) because it still simply
calls the &#8220;click_on_logout&#8221; action method.</p>
<p>This approach has two main aspects:</p>
<ul class="simple">
<li>The classes with the actual tests should be as readable as possible</li>
<li>The other parts of the testing framework should be as much about data as
possible, so that if the CSS etc. changes you only need to change that one
property. If the flow changes, only the action method should need to change.</li>
</ul>
<p>There is little that is Selenium-specific in the Pages, except for the
properties. There is little coupling between the tests and the pages. Writing
the tests becomes like writing out a list of steps (by using the previously
mentioned action methods). One of the key points, particularly important for
this kind of UI driven testing is to isolate the tests from what is behind
them.</p>
</div>
<div class="section" id="list-of-references">
<h3>List of references<a class="headerlink" href="#list-of-references" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://wiki.openstack.org/wiki/Horizon/Testing/UI#Page_Object_Pattern_.28Selected_Approach.29">https://wiki.openstack.org/wiki/Horizon/Testing/UI#Page_Object_Pattern_.28Selected_Approach.29</a></li>
<li><a class="reference external" href="https://wiki.mozilla.org/QA/Execution/Web_Testing/Docs/Automation/StyleGuide#Page_Objects">https://wiki.mozilla.org/QA/Execution/Web_Testing/Docs/Automation/StyleGuide#Page_Objects</a></li>
<li><a class="reference external" href="https://code.google.com/p/selenium/wiki/PageObjects">https://code.google.com/p/selenium/wiki/PageObjects</a></li>
</ul>
</div>
</div>
<div class="section" id="debugging-integration-tests">
<h2>Debugging integration tests<a class="headerlink" href="#debugging-integration-tests" title="Permalink to this headline">¶</a></h2>
<p>Even perfectly designed Page Objects are not a guarantee that your integration
test will not ever fail. This can happen due to different causes:</p>
<p>The first and most anticipated kind of failure is the inability to perform a
testing scenario by a living person simply because some OpenStack service or
Horizon itself prevents them from doing so. This is exactly the kind that
integration tests are designed to catch. Let us call them &#8220;good&#8221; failures.</p>
<p>All other kinds of failures are unwanted and could be roughly split into the
two following categories:</p>
<ol class="arabic simple">
<li>The failures that occur due to changes in application&#8217;s DOM. some CSS/ Xpath selectors no longer matching
Horizon app&#8217;s DOM. The usual signature for that kind of failures is having
a DOM changing patch for which the test job fails with a message like
this <cite>selenium.common.exceptions.NoSuchElementException: Message: Unable to
locate element: {&#8220;method&#8221;:&#8221;css selector&#8221;,&#8221;selector&#8221;:&#8221;div.modal-dialog&#8221;}</cite>.
If you find yourself in such a situation, you should fix the Page Object
selectors according to the DOM changes you made.</li>
<li>Unfortunately it is still quite possible to get the above error for a patch
which didn&#8217;t implement any DOM changes. Among the reasons of such behavior
observed in past were:<ul>
<li>Integration tests relying on relative ordering of form fields and table
actions that broke with the addition of a new field. This issue should
be fixed by now, but may reappear in future for different entities.</li>
<li>Integration tests relying on popups disappearing by the time a specific
action needs to be taken (or not existing at all). This expectation
turned out to be very fragile, since the speed of tests execution by
Jenkins workers may change independently of integration test code (hence,
popups disappear too late to free the way for the next action). The
unexpected (both too long and too short) timeouts aren&#8217;t limited to just
popups, but apply to every situation when the element state transition
is not instant (like opening an external link, going to another page in
Horizon, waiting for button to become active, waiting for a table row to
change its state). Luckily, most transitions of &#8220;element becomes visible/
emerge to existence from non-existence&#8221; kind are already bulletproofed
using <cite>implicit_wait</cite> parameter in <cite>integration_tests/horizon.conf</cite> file.
Selenium just waits for specified amount of seconds for an element to
become visible (if it&#8217;s not already visible) giving up when it exceeds
(with the above error). Also it&#8217;s worth mentioning <cite>explicit_wait</cite> parameter
which is considered when the selenium <cite>wait_until</cite> method is involved (and
it is used, e.g. in waiting for spinner and messages popups to disappear).</li>
</ul>
</li>
</ol>
<p>An inconvenient thing about reading test results in the <cite>console.html</cite> file
attached to every <cite>gate-horizon-dsvm-integration</cite> finished job is that the test
failure may appear either as failure (assertion failed), or as error (expected
element didn&#8217;t show up). In both cases an inquirer should suspect a legitimate
failure first (i.e., treat errors as failures). Unfortunately, no clear method
exists for the separation of &#8220;good&#8221; from &#8220;bad&#8221; failures. Each case is
unique and full of mysteries.</p>
<p>The Horizon testing mechanism tries to alleviate this ambiguity by providing
several facilities to aid in failure investigation:</p>
<ul class="simple">
<li>First there comes a screenshot made for every failed test (in a separate
folder, on a same level as <cite>console.html</cite>) - almost instant snapshot of a
screen on the moment of failure (<em>almost</em> sometimes matters, especially in
a case of popups that hang on a screen for a limited time);</li>
<li>Then the patient inquirer may skim through the vast innards of
<cite>console.html</cite>, looking at browser log first (all javascript and css errors
should come there),</li>
<li>Then looking at a full textual snapshot of a page for which test failed
(sometimes it gives a more precise picture than a screenshot),</li>
<li>And finally looking at test error stacktrace (most useful) and a lengthy
output of requests/ responses with a selenium server. The last log sometimes
might tell us how long a specific web element was polled before failing (in
case of <cite>implicit_wait</cite> there should be a series of requests to the same
element).</li>
</ul>
<p>The best way to solve the cause of test failure is running and debugging the
troublesome test locally. You could use <cite>pdb</cite> or Python IDE of your choice to
stop test execution in arbitrary points and examining various Page Objects
attributes to understand what they missed. Looking at the real page structure
in browser developer tools also could explain why the test fails. Sometimes it
may be worth to place breakpoints in JavaScript code (provided that static is
served uncompressed) to examine the objects of interest. If it takes long, you
may also want to increase the webdriver&#8217;s timeout so it will not close browser
windows forcefully. Finally, sometimes it may make sense to examine the
contents of <cite>logs</cite> directory, especially apache logs - but that is mostly the
case for the &#8220;good&#8221; failures.</p>
</div>
<div class="section" id="writing-your-first-integration-test">
<h2>Writing your first integration test<a class="headerlink" href="#writing-your-first-integration-test" title="Permalink to this headline">¶</a></h2>
<p>So, you are going to write your first integration test and looking for some
guidelines on how to do it. The first and the most comprehensive source of
knowledge is the existing codebase of integration tests. Look how other tests
are written, which Page Objects they use and learn by copying. Accurate imitation
will eventually lead to a solid understanding. Yet there are few things that may
save you some time when you know them in advance.</p>
<div class="section" id="file-and-directory-layout-and-go-to-page-methods">
<h3>File and directory layout and go_to_*page() methods<a class="headerlink" href="#file-and-directory-layout-and-go-to-page-methods" title="Permalink to this headline">¶</a></h3>
<p>Below is the filesystem structure that test helpers rely on.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>horizon/
└─ openstack_dashboard/
   └─ test/
      └─ integration_tests/
         ├─ pages/
         │  ├─ admin/
         │  │  ├─ __init__.py
         │  │  └─ system/
         │  │     ├─ __init__.py
         │  │     └─ flavorspage.py
         │  ├─ project/
         │  │  └─ compute/
         │  │     ├─ __init__.py
         │  │     ├─ access_and_security/
         │  │     │  ├─ __init__.py
         │  │     │  └─ keypairspage.py
         │  │     └─ imagespage.py
         │  └─ navigation.py
         ├─ regions/
         ├─ tests/
         ├─ config.py
         └─ horizon.conf
</pre></div>
</div>
<p>New tests are put into integration_tests/tests, where they are grouped
by the kind of entities being tested (test_instances.py, test_networks.py, etc).
All Page Objects to be used by tests are inside pages/directory, the nested
directory structure you see within it obeys the value of <cite>Navigation.CORE_PAGE_STRUCTURE</cite>
you can find at pages/navigation.py module. The contents of the <cite>CORE_PAGE_STRUCTURE</cite>
variable should in turn mirror the structure of standard dashboard sidebar menu.
If this condition is not met, the go_to_&lt;pagename&gt;page() methods which are generated
automatically at runtime will have problems matching the real sidebar items. How are
these go_to_*page() methods are generated? From the sidebar&#8217;s point of view, dashboard
content could be at most four levels deep: Dashboard, Panel Group, Panel and Tab.
Given the mixture of these entities in existing dashboards, it was decided that:</p>
<ul class="simple">
<li>When panels need to be addressed with go_to_&lt;pagename&gt;page() methods, two components in
the method&#8217;s name are enough for distinguishing the right path to go along, namely a Panel
name and a Panel Group name (or a Dashboard name, if no Panel Group exists above Panel).
For example,<ul>
<li><cite>go_to_system_flavorspage()</cite> method to go to Admin-&gt;System-&gt;Flavors and</li>
<li><cite>go_to_identity_projectspage()</cite> method to go to Identity-&gt;Projects panel.</li>
</ul>
</li>
<li>When we need to go one level deeper, i.e. go to the specific TableTab on any panel that
has several tabs, three components are enough - Panel Group, Panel and Tab names. For
example, <cite>go_to_compute_accessandsecurity_floatingipspage()</cite> for navigating to
Project-&gt;Compute-&gt;Access &amp; Security-&gt;Floating IPs tab. Note that one cannot navigate
to a Panel level if that Panel has several tabs (i.e., only terminal levels could be
navigated to).</li>
</ul>
<p>As you might have noticed, method name components are chosen from normalized items of
the <cite>CORE_PAGE_STRUCTURE</cite> dictionary, where normalization means replacing spaces with <cite>_</cite>
symbol and <cite>&amp;</cite> symbol with <cite>and</cite>, then downcasing all symbols.</p>
<p>Once the <cite>go_to_*page()</cite> method&#8217;s name is parsed and the proper menu item is matched in
a dashboard, it should return the proper Page Object. For that to happen a properly
named class should reside in a properly named module located in the right place of the
filesystem. More specifically and top down:</p>
<ol class="arabic simple">
<li>Page Object class is located in:<ul>
<li>&lt;dashboard&gt;/&lt;panel_group&gt;/&lt;panel&gt;page.py file for non-tabbed pages</li>
<li>&lt;dashboard&gt;/&lt;panel_group&gt;/&lt;panel&gt;/&lt;tab&gt;page.py file for tabbed pages
Values &lt;dashboard&gt;, &lt;panel_group&gt;, &lt;panel&gt; and &lt;tab&gt; are the normalized versions of
the items from the <cite>CORE_PAGE_STRUCTURE</cite> dictionary.</li>
</ul>
</li>
<li>Within the above module a descendant of <cite>basepage.BaseNavigationPage</cite> should be
defined, its name should have the form &lt;Panel&gt;Page or &lt;Tab&gt;Page, where &lt;Panel&gt; and &lt;Tab&gt;
are capitalized versions of normalized &lt;panel&gt; and &lt;tab&gt; items respectively.</li>
</ol>
</div>
<div class="section" id="reusable-regions">
<h3>Reusable regions<a class="headerlink" href="#reusable-regions" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first"><cite>TableRegion</cite> binds to the HTML Horizon table using the <cite>TableRegion</cite>&#8216;s <cite>name</cite>
attribute. To bind to the proper table this attribute has to be the same as
the <cite>name</cite> attribute of a <cite>Meta</cite> subclass of a corresponding <cite>tables.DataTable</cite>
descendant in the Python code. <cite>TableRegion</cite> provides all the needed facilities for
solving the following table-related tasks.</p>
<ul class="simple">
<li>Getting a specific row from a table matched by the column name and a target
text within that column (use <cite>get_row()</cite> method) or taking all the existing
rows on a current table page with <cite>rows</cite> property.</li>
<li>Once you have a reference to a specific row, it can either be marked with
<cite>mark()</cite> for further batch actions or split to cells (using <cite>cells</cite> property
which is dictionary representing column name as a key to cell wrapper as a
value).</li>
<li>For interacting with actions <cite>TableRegion</cite> provides 2 decorators, namely
<cite>&#64;bind_table_action()</cite> and <cite>&#64;bind_row_action()</cite> which bind to the actual HTML
button widget and decorate the specific table methods. These methods in turn
should click a bound button (comes as these methods&#8217; second argument after <cite>self</cite>)
and usually return a new region which is most often bound to a modal form
being shown after clicking that button in real Horizon.</li>
<li>Another important part of <cite>TableRegion</cite> are the facilities for checking the
properties of a paged table - <cite>assert_definition()</cite>, <cite>is_next_link_available()</cite>
and <cite>is_prev_link_available()</cite> helpers and <cite>turn_next_page()</cite> / <cite>turn_prev_page()</cite>
which obviously cause the next / prev table page to be shown.</li>
</ul>
</li>
<li><p class="first">when interacting with modal and non-modal forms three flavors of form wrappers
can be used.</p>
<ul>
<li><p class="first"><cite>BaseFormRegion</cite> is used for simplest forms which are usually &#8216;Submit&#8217; /
&#8216;Cancel&#8217; dialogs with no fields to be filled.</p>
</li>
<li><p class="first"><cite>FormRegion</cite> is the most used wrapper which provides interaction with the
fields within that form. Every field is backed by its own wrapper class, while
the <cite>FormRegion</cite> acts as a container which initializes all the field wrappers in
its <cite>__init__()</cite> method. Field mappings passed to <cite>__init__()</cite> could be</p>
<blockquote>
<div><ul class="simple">
<li>either a tuple of string labels, in that case the same label is used for
referencing the field in test code and for binding to the HTML input (should be
the same as <cite>name</cite> attribute of that widget, could be seen in Django code defining
that form in Horizon)</li>
<li>or a dictionary, where the key will be used for referencing the test field
and the value will be used for binding to the HTML input. Also it is feasible
to provide values other than strings in that dictionary - in this case they are
meant to be a Python class. This Python class will be initialized as any
BaseRegion is usually initialized and then the value&#8217;s key will be used for
referencing this object. This is useful when dealing with non-standard widgets
in forms (like Membership widget in Create/​Edit Project form or Networks widget
in Launch Instance form).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><cite>TabbedFormRegion</cite> is a slight variation of <cite>FormRegion</cite>, it has several tabs
and thus can accept a tuple of tuples / dictionaries of field mappings, where
every tuple corresponds to a tab of a real form, binding order is that first
tuple binds to leftmost tab, which has index 0. Passing <cite>default_tab</cite> other than
0 to <cite>TabbedFormRegion.__init__</cite> we can make the test form to be created with
the tab other than the leftmost being shown immediately. Finally the method <cite>switch_to</cite>
allows us to switch to any existing form&#8217;s tab.</p>
</li>
</ul>
</li>
<li><p class="first"><cite>MessageRegion</cite> is a small region, but is very important for asserting that
everything goes well in Horizon under test. Technically, the <cite>find_message_and_dismiss</cite>
method belongs to <cite>BasePage</cite> class, but whenever it is called, <cite>regions.messages</cite>
module is imported as well to pass a <cite>messages.SUCCESS</cite> / <cite>messages.ERROR</cite>
argument into. The method returns <cite>True</cite> / <cite>False</cite> depending on if the specified
message was found and dismissed (which could be then asserted for).</p>
</li>
</ul>
</div>
<div class="section" id="customizing-tests-to-a-specific-gate-environment">
<h3>Customizing tests to a specific gate environment<a class="headerlink" href="#customizing-tests-to-a-specific-gate-environment" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Upstream gate environment is not the only possible environment where Horizon
integration tests can be run. Various downstream distributions may also
want to run them. To ease the adoption of upstream tests to possibly
different conditions of a downstream gate environment, integration tests use
a configuration machinery backed by oslo.config library. It includes the
following pieces of knowledge:<ul>
<li>integration_tests/config.py file where all possible setting groups and
settings are defined along with their descriptions and defaults. If you are
going to add a new setting to Horizon integration tests, you should add it
first to this file.</li>
<li>integration_tests/horizon.conf file - where all the overrides are
actually located. For clarity its contents mirrors the default values
in config.py (although technically they could be completely commented out
with the same result).</li>
<li>To make developers&#8217; lives easier a local-only (not tracked by git)
counterpart of horizon.conf could exist at the same directory, named
&#8216;local-horizon.conf&#8217;. It is meant solely for overriding values from
horizon.conf that a developer&#8217;s environment might differ from the gate
environment (like Horizon url or admin user password).</li>
</ul>
</li>
<li>When integration tests are run by openstack-infra/devstack-gate scripts they
use 2 hooks to alter the devstack gate environment, namely pre_test_hook and
post_test_hook. Contents of both hooks are defined inside the corresponding
shell scripts located at &#8216;tools/gate/integration&#8217; at the top-level of horizon
repo. If you find yourself asking which of the hooks you need to modify - pre
or post, keep the following things in mind.<ul>
<li>Pre hook is executed before the Devstack is deployed, that essentially
means that almost none of packages that are installed as OpenStack services
dependencies during Devstack deployment are going to be present in the
system. Yet all the repositories contained with <cite>PROJECTS</cite> variable defined
in <a class="reference external" href="https://github.com/openstack-infra/devstack-gate/blob/master/devstack-vm-gate-wrap.sh">devstack-vm-gate-wrap.sh</a> script will be already cloned by the moment
pre hook is executed. So the natural use for it is to customize some Horizon
settings before they are used in operations like compressing statics etc.
That is how it is actually used now: it sets settings variable
<cite>INTEGRATION_TESTS_SUPPORT</cite> to <cite>True</cite>, so all the support code for integration
tests is included into Horizon static assets. If this variable was set to
<cite>False</cite>, we would not be able to run integration tests.</li>
<li>Post hook is executed after Devstack is deployed, so integration tests
themselves are run inside that hook, as well as various test artifacts
collection. When you modify it, do not forget to save the exit code of
a tox integration tests run and emit at the end of the script - or you may
lose the SUCCESS/FAILURE status of the whole tests suite and tamper with the
job results!</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="writing-integration-tests-for-horizon-plugins">
<h3>Writing integration tests for Horizon plugins<a class="headerlink" href="#writing-integration-tests-for-horizon-plugins" title="Permalink to this headline">¶</a></h3>
<p>First, for more details on writing a Horizon plugin please refer to
<a class="reference internal" href="../tutorials/plugin.html"><em>Horizon Plugin</em></a>. Second, there are 2 possible setups when running
integration tests for Horizon plugins.</p>
<p>The first setup, which is suggested to be used in gate of *-dashboard plugins
is to get horizon as a dependency of a plugin and then run integration tests
using horizon.conf config file inside the plugin repo. This way the plugin augments
the location of Horizon built-in Page Objects with the location of its own
Page Objects, contained within the <cite>plugin_page_path</cite> option and the Horizon
built-in nav structure with its own nav structure contained within
<cite>plugin_page_structure</cite>. Then the plugin integration tests are run against core
Horizon augmented with just this particular plugin content.</p>
<p>The second setup may be used when it is needed to run integration tests for
Horizon + several plugins. In other words, content from several plugins is
merged into core Horizon content, then the combined integration tests from core
Horizon and all the involved plugins are run against the resulting dashboards.
To make this possible both options <cite>plugin_page_path</cite> and
<cite>plugin_page_structure</cite> have MultiStrOpt type. This means that they may be
defined several times and all the specified values will be gathered in a list,
which is iterated over when running integration tests. In this setup it&#8217;s easier to
run the tests from Horizon repo, using the horizon.conf file within it.</p>
<p>Also keep in mind that <cite>plugin_page_structure</cite> needs to be a strict JSON
string, w/o trailing commas etc.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Testing Topic Guide</a><ul>
<li><a class="reference internal" href="#an-overview-of-testing">An overview of testing</a><ul>
<li><a class="reference internal" href="#unit-tests">Unit tests</a></li>
<li><a class="reference internal" href="#functional-tests">Functional tests</a></li>
<li><a class="reference internal" href="#integration-tests">Integration Tests</a></li>
<li><a class="reference internal" href="#so-what-should-i-write">So what should I write?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#what-makes-a-good-unit-test">What makes a good unit test?</a><ul>
<li><a class="reference internal" href="#test-data">Test data</a></li>
<li><a class="reference internal" href="#mocking">Mocking</a></li>
<li><a class="reference internal" href="#assertions-and-verification">Assertions and verification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging-unit-tests">Debugging Unit Tests</a><ul>
<li><a class="reference internal" href="#tips-and-tricks">Tips and tricks</a></li>
<li><a class="reference internal" href="#common-pitfalls">Common pitfalls</a></li>
<li><a class="reference internal" href="#understanding-the-output-from-mox">Understanding the output from <code class="docutils literal"><span class="pre">mox</span></code></a><ul>
<li><a class="reference internal" href="#unexpected-method-call">Unexpected Method Call</a></li>
<li><a class="reference internal" href="#expected-method-never-called">Expected Method Never Called</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#integration-tests-in-horizon">Integration tests in Horizon</a><ul>
<li><a class="reference internal" href="#page-object-pattern">Page Object pattern</a></li>
<li><a class="reference internal" href="#writing-reusable-and-maintainable-page-objects">Writing reusable and maintainable Page Objects</a></li>
<li><a class="reference internal" href="#list-of-references">List of references</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging-integration-tests">Debugging integration tests</a></li>
<li><a class="reference internal" href="#writing-your-first-integration-test">Writing your first integration test</a><ul>
<li><a class="reference internal" href="#file-and-directory-layout-and-go-to-page-methods">File and directory layout and go_to_*page() methods</a></li>
<li><a class="reference internal" href="#reusable-regions">Reusable regions</a></li>
<li><a class="reference internal" href="#customizing-tests-to-a-specific-gate-environment">Customizing tests to a specific gate environment</a></li>
<li><a class="reference internal" href="#writing-integration-tests-for-horizon-plugins">Writing integration tests for Horizon plugins</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="policy.html"
                                  title="previous chapter">Horizon Policy Enforcement (RBAC: Role Based Access Control)</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="angularjs.html"
                                  title="next chapter">AngularJS Topic Guide</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/horizon
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/topics/testing.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="angularjs.html" title="AngularJS Topic Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="policy.html" title="Horizon Policy Enforcement (RBAC: Role Based Access Control)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">horizon 11.0.0.0rc2.dev56 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, OpenStack Foundation.
      Last updated on &#39;Tue Feb 14 01:44:33 2017, commit d07a02a&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/horizon");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>