<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Setting Up a Development Environment &mdash; neutron 10.0.0.0rc2.dev58 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '10.0.0.0rc2.dev58',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="neutron 10.0.0.0rc2.dev58 documentation" href="../index.html" />
    <link rel="up" title="Developer Guide" href="index.html" />
    <link rel="next" title="Contributing new extensions to Neutron" href="contribute.html" />
    <link rel="prev" title="Effective Neutron: 100 specific ways to improve your Neutron contributions" href="effective_neutron.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="setting-up-a-development-environment">
<h1>Setting Up a Development Environment<a class="headerlink" href="#setting-up-a-development-environment" title="Permalink to this headline">¶</a></h1>
<p>This page describes how to setup a working Python development
environment that can be used in developing Neutron on Ubuntu, Fedora or
Mac OS X. These instructions assume you&#8217;re already familiar with
Git and Gerrit, which is a code repository mirror and code review toolset
, however if you aren&#8217;t please see <a class="reference external" href="http://git-scm.com/book/en/Getting-Started">this Git tutorial</a> for an introduction
to using Git and <a class="reference external" href="http://docs.openstack.org/infra/manual/developers.html#development-workflow">this guide</a> for a tutorial on using Gerrit and Git for
code contribution to OpenStack projects.</p>
<p>Following these instructions will allow you to run the Neutron unit
tests. If you want to be able to run Neutron in a full OpenStack environment,
you can use the excellent <a class="reference external" href="https://git.openstack.org/cgit/openstack-dev/devstack">DevStack</a> project to do so. There is a wiki page
that describes <a class="reference external" href="https://wiki.openstack.org/wiki/NeutronDevstack">setting up Neutron using DevStack</a>.</p>
<div class="section" id="getting-the-code">
<h2>Getting the code<a class="headerlink" href="#getting-the-code" title="Permalink to this headline">¶</a></h2>
<p>Grab the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>git clone git://git.openstack.org/openstack/neutron.git
cd neutron
</pre></div>
</div>
</div>
</div>
<div class="section" id="testing-neutron">
<h1>Testing Neutron<a class="headerlink" href="#testing-neutron" title="Permalink to this headline">¶</a></h1>
<div class="section" id="why-should-you-care">
<h2>Why Should You Care<a class="headerlink" href="#why-should-you-care" title="Permalink to this headline">¶</a></h2>
<p>There&#8217;s two ways to approach testing:</p>
<ol class="arabic simple">
<li>Write unit tests because they&#8217;re required to get your patch merged.
This typically involves mock heavy tests that assert that your code is as
written.</li>
<li>Putting as much thought into your testing strategy as you do to the rest
of your code. Use different layers of testing as appropriate to provide
high <em>quality</em> coverage. Are you touching an agent? Test it against an
actual system! Are you adding a new API? Test it for race conditions
against a real database! Are you adding a new cross-cutting feature?
Test that it does what it&#8217;s supposed to do when run on a real cloud!</li>
</ol>
<p>Do you feel the need to verify your change manually? If so, the next few
sections attempt to guide you through Neutron&#8217;s different test infrastructures
to help you make intelligent decisions and best exploit Neutron&#8217;s test
offerings.</p>
</div>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>We will talk about three classes of tests: unit, functional and integration.
Each respective category typically targets a larger scope of code. Other than
that broad categorization, here are a few more characteristic:</p>
<blockquote>
<div><ul class="simple">
<li>Unit tests - Should be able to run on your laptop, directly following a
&#8216;git clone&#8217; of the project. The underlying system must not be mutated,
mocks can be used to achieve this. A unit test typically targets a function
or class.</li>
<li>Functional tests - Run against a pre-configured environment
(tools/configure_for_func_testing.sh). Typically test a component
such as an agent using no mocks.</li>
<li>Integration tests - Run against a running cloud, often target the API level,
but also &#8216;scenarios&#8217; or &#8216;user stories&#8217;. You may find such tests under
tests/tempest/api, tests/tempest/scenario, tests/fullstack, and in the
Tempest and Rally projects.</li>
</ul>
</div></blockquote>
<p>Tests in the Neutron tree are typically organized by the testing infrastructure
used, and not by the scope of the test. For example, many tests under the
&#8216;unit&#8217; directory invoke an API call and assert that the expected output was
received. The scope of such a test is the entire Neutron server stack,
and clearly not a specific function such as in a typical unit test.</p>
</div>
<div class="section" id="testing-frameworks">
<h2>Testing Frameworks<a class="headerlink" href="#testing-frameworks" title="Permalink to this headline">¶</a></h2>
<p>The different frameworks are listed below. The intent is to list the
capabilities of each testing framework as to help the reader understand when
should each tool be used. Remember that when adding code that touches many
areas of Neutron, each area should be tested with the appropriate framework.
Overlap between different test layers is often desirable and encouraged.</p>
<div class="section" id="unit-tests">
<h3>Unit Tests<a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h3>
<p>Unit tests (neutron/tests/unit/) are meant to cover as much code as
possible. They are designed to test the various pieces of the Neutron tree to
make sure any new changes don&#8217;t break existing functionality. Unit tests have
no requirements nor make changes to the system they are running on. They use
an in-memory sqlite database to test DB interaction.</p>
<p>At the start of each test run:</p>
<ul class="simple">
<li>RPC listeners are mocked away.</li>
<li>The fake Oslo messaging driver is used.</li>
</ul>
<p>At the end of each test run:</p>
<ul class="simple">
<li>Mocks are automatically reverted.</li>
<li>The in-memory database is cleared of content, but its schema is maintained.</li>
<li>The global Oslo configuration object is reset.</li>
</ul>
<p>The unit testing framework can be used to effectively test database interaction,
for example, distributed routers allocate a MAC address for every host running
an OVS agent. One of DVR&#8217;s DB mixins implements a method that lists all host
MAC addresses. Its test looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_get_dvr_mac_address_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_create_dvr_mac_entry</span><span class="p">(</span><span class="s1">&#39;host_1&#39;</span><span class="p">,</span> <span class="s1">&#39;mac_1&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_create_dvr_mac_entry</span><span class="p">(</span><span class="s1">&#39;host_2&#39;</span><span class="p">,</span> <span class="s1">&#39;mac_2&#39;</span><span class="p">)</span>
    <span class="n">mac_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixin</span><span class="o">.</span><span class="n">get_dvr_mac_address_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mac_list</span><span class="p">))</span>
</pre></div>
</div>
<p>It inserts two new host MAC address, invokes the method under test and asserts
its output. The test has many things going for it:</p>
<ul class="simple">
<li>It targets the method under test correctly, not taking on a larger scope
than is necessary.</li>
<li>It does not use mocks to assert that methods were called, it simply
invokes the method and asserts its output (In this case, that the list
method returns two records).</li>
</ul>
<p>This is allowed by the fact that the method was built to be testable -
The method has clear input and output with no side effects.</p>
<p>You can get oslo.db to generate a file-based sqlite database by setting
OS_TEST_DBAPI_ADMIN_CONNECTION to a file based URL as described in <a class="reference external" href="http://lists.openstack.org/pipermail/openstack-dev/2016-July/099861.html">this
mailing list post</a>. This file will be created but (confusingly) won&#8217;t be the
actual file used for the database. To find the actual file, set a break point
in your test method and inspect self.engine.url.</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ <span class="nv">OS_TEST_DBAPI_ADMIN_CONNECTION</span><span class="o">=</span>sqlite:///sqlite.db .tox/py27/bin/python -m <span class="se">\</span>
    testtools.run neutron.tests.unit...
...
<span class="o">(</span>Pdb<span class="o">)</span> self.engine.url
sqlite:////tmp/iwbgvhbshp.db
</pre></div>
</div>
<p>Now, you can inspect this file using sqlite3.</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ sqlite3 /tmp/iwbgvhbshp.db
</pre></div>
</div>
</div>
<div class="section" id="functional-tests">
<h3>Functional Tests<a class="headerlink" href="#functional-tests" title="Permalink to this headline">¶</a></h3>
<p>Functional tests (neutron/tests/functional/) are intended to
validate actual system interaction. Mocks should be used sparingly,
if at all. Care should be taken to ensure that existing system
resources are not modified and that resources created in tests are
properly cleaned up both on test success and failure. Note that when run
at the gate, the functional tests compile OVS from source. Check out
neutron/tests/contrib/gate_hook.sh. Other jobs presently use OVS from
packages.</p>
<p>Let&#8217;s examine the benefits of the functional testing framework.
Neutron offers a library called &#8216;ip_lib&#8217; that wraps around the &#8216;ip&#8217; binary.
One of its methods is called &#8216;device_exists&#8217; which accepts a device name
and a namespace and returns True if the device exists in the given namespace.
It&#8217;s easy building a test that targets the method directly, and such a test
would be considered a &#8216;unit&#8217; test. However, what framework should such a test
use? A test using the unit tests framework could not mutate state on the system,
and so could not actually create a device and assert that it now exists. Such
a test would look roughly like this:</p>
<ul class="simple">
<li>It would mock &#8216;execute&#8217;, a method that executes shell commands against the
system to return an IP device named &#8216;foo&#8217;.</li>
<li>It would then assert that when &#8216;device_exists&#8217; is called with &#8216;foo&#8217;, it
returns True, but when called with a different device name it returns False.</li>
<li>It would most likely assert that &#8216;execute&#8217; was called using something like:
&#8216;ip link show foo&#8217;.</li>
</ul>
<p>The value of such a test is arguable. Remember that new tests are not free,
they need to be maintained. Code is often refactored, reimplemented and
optimized.</p>
<ul class="simple">
<li>There are other ways to find out if a device exists (Such as
by looking at &#8216;/sys/class/net&#8217;), and in such a case the test would have
to be updated.</li>
<li>Methods are mocked using their name. When methods are renamed, moved or
removed, their mocks must be updated. This slows down development for
avoidable reasons.</li>
<li>Most importantly, the test does not assert the behavior of the method. It
merely asserts that the code is as written.</li>
</ul>
<p>When adding a functional test for &#8216;device_exists&#8217;, several framework level
methods were added. These methods may now be used by other tests as well.
One such method creates a virtual device in a namespace,
and ensures that both the namespace and the device are cleaned up at the
end of the test run regardless of success or failure using the &#8216;addCleanup&#8217;
method. The test generates details for a temporary device, asserts that
a device by that name does not exist, create that device, asserts that
it now exists, deletes it, and asserts that it no longer exists.
Such a test avoids all three issues mentioned above if it were written
using the unit testing framework.</p>
<p>Functional tests are also used to target larger scope, such as agents.
Many good examples exist: See the OVS, L3 and DHCP agents functional tests.
Such tests target a top level agent method and assert that the system
interaction that was supposed to be perform was indeed performed.
For example, to test the DHCP agent&#8217;s top level method that accepts network
attributes and configures dnsmasq for that network, the test:</p>
<ul class="simple">
<li>Instantiates an instance of the DHCP agent class (But does not start its
process).</li>
<li>Calls its top level function with prepared data.</li>
<li>Creates a temporary namespace and device, and calls &#8216;dhclient&#8217; from that
namespace.</li>
<li>Assert that the device successfully obtained the expected IP address.</li>
</ul>
</div>
<div class="section" id="fullstack-tests">
<h3>Fullstack Tests<a class="headerlink" href="#fullstack-tests" title="Permalink to this headline">¶</a></h3>
<div class="section" id="why">
<h4>Why?<a class="headerlink" href="#why" title="Permalink to this headline">¶</a></h4>
<p>The idea behind &#8220;fullstack&#8221; testing is to fill a gap between unit + functional
tests and Tempest. Tempest tests are expensive to run, and target black box API
tests exclusively. Tempest requires an OpenStack deployment to be run against,
which can be difficult to configure and setup. Full stack testing addresses
these issues by taking care of the deployment itself, according to the topology
that the test requires. Developers further benefit from full stack testing as
it can sufficiently simulate a real environment and provide a rapidly
reproducible way to verify code while you&#8217;re still writing it.</p>
</div>
<div class="section" id="how">
<h4>How?<a class="headerlink" href="#how" title="Permalink to this headline">¶</a></h4>
<p>Full stack tests set up their own Neutron processes (Server &amp; agents). They
assume a working Rabbit and MySQL server before the run starts. Instructions
on how to run fullstack tests on a VM are available below.</p>
<p>Each test defines its own topology (What and how many servers and agents should
be running).</p>
<p>Since the test runs on the machine itself, full stack testing enables
&#8220;white box&#8221; testing. This means that you can, for example, create a router
through the API and then assert that a namespace was created for it.</p>
<p>Full stack tests run in the Neutron tree with Neutron resources alone. You
may use the Neutron API (The Neutron server is set to NOAUTH so that Keystone
is out of the picture). VMs may be simulated with a container-like class:
neutron.tests.fullstack.resources.machine.FakeFullstackMachine.
An example of its usage may be found at:
neutron/tests/fullstack/test_connectivity.py.</p>
<p>Full stack testing can simulate multi node testing by starting an agent
multiple times. Specifically, each node would have its own copy of the
OVS/LinuxBridge/DHCP/L3 agents, all configured with the same &#8220;host&#8221; value.
Each OVS agent is connected to its own pair of br-int/br-ex, and those bridges
are then interconnected.
For LinuxBridge agent each agent is started in its own namespace, called
&#8220;host-&lt;some_random_value&gt;&#8221;. Such namespaces are connected with OVS &#8220;central&#8221;
bridge to each other.</p>
<img alt="../_images/fullstack_multinode_simulation.png" src="../_images/fullstack_multinode_simulation.png" />
<p>Segmentation at the database layer is guaranteed by creating a database
per test. The messaging layer achieves segmentation by utilizing a RabbitMQ
feature called &#8216;vhosts&#8217;. In short, just like a MySQL server serve multiple
databases, so can a RabbitMQ server serve multiple messaging domains.
Exchanges and queues in one &#8216;vhost&#8217; are segmented from those in another
&#8216;vhost&#8217;.</p>
<p>Please note that if the change you would like to test using fullstack tests
involves a change to python-neutronclient as well as neutron, then you should
make sure your fullstack tests are in a separate third change that depends on
the python-neutronclient change using the &#8216;Depends-On&#8217; tag in the commit
message.  You will need to wait for the next release of python-neutronclient,
and a minimum version bump for python-neutronclient in the global requirements,
before your fullstack tests will work in the gate.  This is because tox uses
the version of python-neutronclient listed in the upper-constraints.txt file in
the openstack/requirements repository.</p>
</div>
<div class="section" id="when">
<h4>When?<a class="headerlink" href="#when" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>You&#8217;d like to test the interaction between Neutron components (Server
and agents) and have already tested each component in isolation via unit or
functional tests. You should have many unit tests, fewer tests to test
a component and even fewer to test their interaction. Edge cases should
not be tested with full stack testing.</li>
<li>You&#8217;d like to increase coverage by testing features that require multi node
testing such as l2pop, L3 HA and DVR.</li>
<li>You&#8217;d like to test agent restarts. We&#8217;ve found bugs in the OVS, DHCP and
L3 agents and haven&#8217;t found an effective way to test these scenarios. Full
stack testing can help here as the full stack infrastructure can restart an
agent during the test.</li>
</ol>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>Neutron offers a Quality of Service API, initially offering bandwidth
capping at the port level. In the reference implementation, it does this by
utilizing an OVS feature.
neutron.tests.fullstack.test_qos.TestQoSWithOvsAgent.test_qos_policy_rule_lifecycle
is a positive example of how the fullstack testing infrastructure should be used.
It creates a network, subnet, QoS policy &amp; rule and a port utilizing that policy.
It then asserts that the expected bandwidth limitation is present on the OVS
bridge connected to that port. The test is a true integration test, in the
sense that it invokes the API and then asserts that Neutron interacted with
the hypervisor appropriately.</p>
</div>
</div>
<div class="section" id="api-tests">
<h3>API Tests<a class="headerlink" href="#api-tests" title="Permalink to this headline">¶</a></h3>
<p>API tests (neutron/tests/tempest/api/) are intended to ensure the function
and stability of the Neutron API. As much as possible, changes to
this path should not be made at the same time as changes to the code
to limit the potential for introducing backwards-incompatible changes,
although the same patch that introduces a new API should include an API
test.</p>
<p>Since API tests target a deployed Neutron daemon that is not test-managed,
they should not depend on controlling the runtime configuration
of the target daemon. API tests should be black-box - no assumptions should
be made about implementation. Only the contract defined by Neutron&#8217;s REST API
should be validated, and all interaction with the daemon should be via
a REST client.</p>
<p>The neutron/tests/tempest/api directory was copied from the Tempest project around
the Kilo timeframe. At the time, there was an overlap of tests between the Tempest
and Neutron repositories. This overlap was then eliminated by carving out a subset
of resources that belong to Tempest, with the rest in Neutron.</p>
<p>API tests that belong to Tempest deal with a subset of Neutron&#8217;s resources:</p>
<ul class="simple">
<li>Port</li>
<li>Network</li>
<li>Subnet</li>
<li>Security Group</li>
<li>Router</li>
<li>Floating IP</li>
</ul>
<p>These resources were chosen for their ubiquity. They are found in most
Neutron deployments regardless of plugin, and are directly involved in the
networking and security of an instance. Together, they form the bare minimum
needed by Neutron.</p>
<p>This is excluding extensions to these resources (For example: Extra DHCP
options to subnets, or snat_gateway mode to routers) that are not mandatory
in the majority of cases.</p>
<p>Tests for other resources should be contributed to the Neutron repository.
Scenario tests should be similarly split up between Tempest and Neutron
according to the API they&#8217;re targeting.</p>
</div>
<div class="section" id="scenario-tests">
<h3>Scenario Tests<a class="headerlink" href="#scenario-tests" title="Permalink to this headline">¶</a></h3>
<p>Scenario tests (neutron/tests/tempest/scenario), like API tests, use the
Tempest test infrastructure and have the same requirements. Guidelines for
writing a good scenario test may be found at the Tempest developer guide:
<a class="reference external" href="http://docs.openstack.org/developer/tempest/field_guide/scenario.html">http://docs.openstack.org/developer/tempest/field_guide/scenario.html</a></p>
<p>Scenario tests, like API tests, are split between the Tempest and Neutron
repositories according to the Neutron API the test is targeting.</p>
</div>
<div class="section" id="rally-tests">
<h3>Rally Tests<a class="headerlink" href="#rally-tests" title="Permalink to this headline">¶</a></h3>
<p>Rally tests (rally-jobs/plugins) use the <a class="reference external" href="http://rally.readthedocs.io/">rally</a>
infrastructure to exercise a neutron deployment. Guidelines for writing a
good rally test can be found in the <a class="reference external" href="http://rally.readthedocs.io/en/latest/plugins.html">rally plugin documentation</a>.
There are also some examples in tree; the process for adding rally plugins to
neutron requires three steps: 1) write a plugin and place it under rally-jobs/plugins/.
This is your rally scenario; 2) (optional) add a setup file under rally-jobs/extra/.
This is any devstack configuration required to make sure your environment can
successfully process your scenario requests; 3) edit neutron-neutron.yaml. This
is your scenario &#8216;contract&#8217; or SLA.</p>
</div>
</div>
<div class="section" id="development-process">
<h2>Development Process<a class="headerlink" href="#development-process" title="Permalink to this headline">¶</a></h2>
<p>It is expected that any new changes that are proposed for merge
come with tests for that feature or code area. Any bugs
fixes that are submitted must also have tests to prove that they stay
fixed! In addition, before proposing for merge, all of the
current tests should be passing.</p>
<div class="section" id="structure-of-the-unit-test-tree">
<h3>Structure of the Unit Test Tree<a class="headerlink" href="#structure-of-the-unit-test-tree" title="Permalink to this headline">¶</a></h3>
<p>The structure of the unit test tree should match the structure of the
code tree, e.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- target module: neutron.agent.utils

- test module: neutron.tests.unit.agent.test_utils
</pre></div>
</div>
<p>Unit test modules should have the same path under neutron/tests/unit/
as the module they target has under neutron/, and their name should be
the name of the target module prefixed by <cite>test_</cite>. This requirement
is intended to make it easier for developers to find the unit tests
for a given module.</p>
<p>Similarly, when a test module targets a package, that module&#8217;s name
should be the name of the package prefixed by <cite>test_</cite> with the same
path as when a test targets a module, e.g.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>- target package: neutron.ipam

- test module: neutron.tests.unit.test_ipam
</pre></div>
</div>
<p>The following command can be used to validate whether the unit test
tree is structured according to the above requirements:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>./tools/check_unit_test_structure.sh
</pre></div>
</div>
<p>Where appropriate, exceptions can be added to the above script. If
code is not part of the Neutron namespace, for example, it&#8217;s probably
reasonable to exclude their unit tests from the check.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At no time should the production code import anything from testing subtree
(neutron.tests). There are distributions that split out neutron.tests
modules in a separate package that is not installed by default, making any
code that relies on presence of the modules to fail. For example, RDO is one
of those distributions.</p>
</div>
</div>
</div>
<div class="section" id="running-tests">
<h2>Running Tests<a class="headerlink" href="#running-tests" title="Permalink to this headline">¶</a></h2>
<p>Before submitting a patch for review you should always ensure all tests pass; a
tox run is triggered by the jenkins gate executed on gerrit for each patch
pushed for review.</p>
<p>Neutron, like other OpenStack projects, uses <a class="reference external" href="http://tox.readthedocs.org/en/latest/">tox</a> for managing the virtual
environments for running test cases. It uses <a class="reference external" href="https://wiki.openstack.org/wiki/Testr">Testr</a> for managing the running
of the test cases.</p>
<p>Tox handles the creation of a series of <a class="reference external" href="https://pypi.python.org/pypi/virtualenv">virtualenvs</a> that target specific
versions of Python.</p>
<p>Testr handles the parallel execution of series of test cases as well as
the tracking of long-running tests and other things.</p>
<p>For more information on the standard Tox-based test infrastructure used by
OpenStack and how to do some common test/debugging procedures with Testr,
see this wiki page:</p>
<blockquote>
<div><a class="reference external" href="https://wiki.openstack.org/wiki/Testr">https://wiki.openstack.org/wiki/Testr</a></div></blockquote>
<div class="section" id="pep8-and-unit-tests">
<h3>PEP8 and Unit Tests<a class="headerlink" href="#pep8-and-unit-tests" title="Permalink to this headline">¶</a></h3>
<p>Running pep8 and unit tests is as easy as executing this in the root
directory of the Neutron source code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">tox</span>
</pre></div>
</div>
<p>To run only pep8:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e pep8
</pre></div>
</div>
<p>Since pep8 includes running pylint on all files, it can take quite some time to run.
To restrict the pylint check to only the files altered by the latest patch changes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e pep8 HEAD~1
</pre></div>
</div>
<p>To run only the unit tests:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e py27
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Functional Tests<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>To run functional tests that do not require sudo privileges or
specific-system dependencies:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e functional
</pre></div>
</div>
<p>To run all the functional tests, including those requiring sudo
privileges and system-specific dependencies, the procedure defined by
tools/configure_for_func_testing.sh should be followed.</p>
<p>IMPORTANT: configure_for_func_testing.sh relies on DevStack to perform
extensive modification to the underlying host. Execution of the
script requires sudo privileges and it is recommended that the
following commands be invoked only on a clean and disposeable VM.
A VM that has had DevStack previously installed on it is also fine.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>git clone https://git.openstack.org/openstack-dev/devstack ../devstack
./tools/configure_for_func_testing.sh ../devstack -i
tox -e dsvm-functional
</pre></div>
</div>
<p>The &#8216;-i&#8217; option is optional and instructs the script to use DevStack
to install and configure all of Neutron&#8217;s package dependencies. It is
not necessary to provide this option if DevStack has already been used
to deploy Neutron to the target host.</p>
</div>
<div class="section" id="id3">
<h3>Fullstack Tests<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>To run all the full-stack tests, you may use:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e dsvm-fullstack
</pre></div>
</div>
<p>Since full-stack tests often require the same resources and
dependencies as the functional tests, using the configuration script
tools/configure_for_func_testing.sh is advised (As described above).
When running full-stack tests on a clean VM for the first time, we
advise to run ./stack.sh successfully to make sure all Neutron&#8217;s
dependencies are met. Full-stack based Neutron daemons produce logs to a
sub-folder in /opt/stack/logs/dsvm-fullstack-logs (for example, a test named
&#8220;test_example&#8221; will produce logs to /opt/stack/logs/dsvm-fullstack-logs/test_example/),
so that will be a good place to look if your test is failing.
Logging from the test infrastructure itself is placed in:
/opt/stack/logs/dsvm-fullstack-logs/test_example.log.
Fullstack test suite assumes 240.0.0.0/4 (Class E) range in root namespace of
the test machine is available for its usage.</p>
</div>
<div class="section" id="api-scenario-tests">
<h3>API &amp; Scenario Tests<a class="headerlink" href="#api-scenario-tests" title="Permalink to this headline">¶</a></h3>
<p>To run the api or scenario tests, deploy Tempest and Neutron with DevStack and
then run the following command, from the tempest directory:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>tox -e all-plugin
</pre></div>
</div>
<p>If you want to limit the amount of tests that you would like to run, you
can do, for instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>export DEVSTACK_GATE_TEMPEST_REGEX=&quot;&lt;you-regex&gt;&quot; # e.g. &quot;neutron&quot;
tox -e all-plugin $DEVSTACK_GATE_TEMPEST_REGEX
</pre></div>
</div>
</div>
<div class="section" id="running-individual-tests">
<h3>Running Individual Tests<a class="headerlink" href="#running-individual-tests" title="Permalink to this headline">¶</a></h3>
<p>For running individual test modules, cases or tests, you just need to pass
the dot-separated path you want as an argument to it.</p>
<p>For example, the following would run only a single test or test case:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ tox -e py27 neutron.tests.unit.test_manager
$ tox -e py27 neutron.tests.unit.test_manager.NeutronManagerTestCase
$ tox -e py27 neutron.tests.unit.test_manager.NeutronManagerTestCase.test_service_plugin_is_loaded
</pre></div>
</div>
<dl class="docutils">
<dt>If you want to pass other arguments to ostestr, you can do the following::</dt>
<dd>$ tox -e -epy27 &#8211; &#8211;regex neutron.tests.unit.test_manager &#8211;serial</dd>
</dl>
</div>
</div>
<div class="section" id="coverage">
<h2>Coverage<a class="headerlink" href="#coverage" title="Permalink to this headline">¶</a></h2>
<p>Neutron has a fast growing code base and there are plenty of areas that
need better coverage.</p>
<p>To get a grasp of the areas where tests are needed, you can check
current unit tests coverage by running:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ tox -ecover
</pre></div>
</div>
<p>Since the coverage command can only show unit test coverage, a coverage
document is maintained that shows test coverage per area of code in:
doc/source/devref/testing_coverage.rst. You could also rely on Zuul
logs, that are generated post-merge (not every project builds coverage
results). To access them, do the following:</p>
<blockquote>
<div><ul class="simple">
<li>Check out the latest <a class="reference external" href="https://review.openstack.org/gitweb?p=openstack/neutron.git;a=search;s=Jenkins;st=author">merge commit</a></li>
<li>Go to: <a class="reference external" href="http://logs.openstack.org">http://logs.openstack.org</a>/&lt;first-2-digits-of-sha1&gt;/&lt;sha1&gt;/post/neutron-coverage/.</li>
<li><a class="reference external" href="https://review.openstack.org/#/c/221494/">Spec</a> is a work in progress to
provide a better landing page.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h2>
<p>By default, calls to pdb.set_trace() will be ignored when tests
are run. For pdb statements to work, invoke tox as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ tox -e venv -- python -m testtools.run [test module path]
</pre></div>
</div>
<p>Tox-created virtual environments (venv&#8217;s) can also be activated
after a tox run and reused for debugging:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>$ tox -e venv
$ . .tox/venv/bin/activate
$ python -m testtools.run [test module path]
</pre></div>
</div>
<p>Tox packages and installs the Neutron source tree in a given venv
on every invocation, but if modifications need to be made between
invocation (e.g. adding more pdb statements), it is recommended
that the source tree be installed in the venv in editable mode:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span># run this only after activating the venv
$ pip install --editable .
</pre></div>
</div>
<p>Editable mode ensures that changes made to the source tree are
automatically reflected in the venv, and that such changes are not
overwritten during the next tox run.</p>
<div class="section" id="post-mortem-debugging">
<h3>Post-mortem Debugging<a class="headerlink" href="#post-mortem-debugging" title="Permalink to this headline">¶</a></h3>
<p>TBD: how to do this with tox.</p>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<table class="docutils footnote" frame="void" id="pudb" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>PUDB debugger:
<a class="reference external" href="https://pypi.python.org/pypi/pudb">https://pypi.python.org/pypi/pudb</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Setting Up a Development Environment</a><ul>
<li><a class="reference internal" href="#getting-the-code">Getting the code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#testing-neutron">Testing Neutron</a><ul>
<li><a class="reference internal" href="#why-should-you-care">Why Should You Care</a></li>
<li><a class="reference internal" href="#definitions">Definitions</a></li>
<li><a class="reference internal" href="#testing-frameworks">Testing Frameworks</a><ul>
<li><a class="reference internal" href="#unit-tests">Unit Tests</a></li>
<li><a class="reference internal" href="#functional-tests">Functional Tests</a></li>
<li><a class="reference internal" href="#fullstack-tests">Fullstack Tests</a><ul>
<li><a class="reference internal" href="#why">Why?</a></li>
<li><a class="reference internal" href="#how">How?</a></li>
<li><a class="reference internal" href="#when">When?</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-tests">API Tests</a></li>
<li><a class="reference internal" href="#scenario-tests">Scenario Tests</a></li>
<li><a class="reference internal" href="#rally-tests">Rally Tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#development-process">Development Process</a><ul>
<li><a class="reference internal" href="#structure-of-the-unit-test-tree">Structure of the Unit Test Tree</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-tests">Running Tests</a><ul>
<li><a class="reference internal" href="#pep8-and-unit-tests">PEP8 and Unit Tests</a></li>
<li><a class="reference internal" href="#id2">Functional Tests</a></li>
<li><a class="reference internal" href="#id3">Fullstack Tests</a></li>
<li><a class="reference internal" href="#api-scenario-tests">API &amp; Scenario Tests</a></li>
<li><a class="reference internal" href="#running-individual-tests">Running Individual Tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coverage">Coverage</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a><ul>
<li><a class="reference internal" href="#post-mortem-debugging">Post-mortem Debugging</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="effective_neutron.html"
                                  title="previous chapter">Effective Neutron: 100 specific ways to improve your Neutron contributions</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="contribute.html"
                                  title="next chapter">Contributing new extensions to Neutron</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/neutron
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/devref/development.environment.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="contribute.html" title="Contributing new extensions to Neutron"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="effective_neutron.html" title="Effective Neutron: 100 specific ways to improve your Neutron contributions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">neutron 10.0.0.0rc2.dev58 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Developer Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-present, OpenStack Foundation..
      Last updated on Feb 14, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/neutron");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>