<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ironic.conductor.manager &mdash; Ironic 7.0.1.dev7 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/toggle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '7.0.1.dev7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/toggle.js"></script>
    <link rel="top" title="Ironic 7.0.1.dev7 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ironic.conductor.manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>

<span class="c1"># Copyright 2013 Hewlett-Packard Development Company, L.P.</span>
<span class="c1"># Copyright 2013 International Business Machines Corporation</span>
<span class="c1"># All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1">#    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may</span>
<span class="c1">#    not use this file except in compliance with the License. You may obtain</span>
<span class="c1">#    a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#         http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1">#    Unless required by applicable law or agreed to in writing, software</span>
<span class="c1">#    distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT</span>
<span class="c1">#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="c1">#    License for the specific language governing permissions and limitations</span>
<span class="c1">#    under the License.</span>
<span class="sd">&quot;&quot;&quot;Conduct all activity related to bare-metal deployments.</span>

<span class="sd">A single instance of :py:class:`ironic.conductor.manager.ConductorManager` is</span>
<span class="sd">created within the *ironic-conductor* process, and is responsible for</span>
<span class="sd">performing all actions on bare metal resources (Chassis, Nodes, and Ports).</span>
<span class="sd">Commands are received via RPCs. The conductor service also performs periodic</span>
<span class="sd">tasks, eg.  to monitor the status of active deployments.</span>

<span class="sd">Drivers are loaded via entrypoints by the</span>
<span class="sd">:py:class:`ironic.common.driver_factory` class. Each driver is instantiated</span>
<span class="sd">only once, when the ConductorManager service starts.  In this way, a single</span>
<span class="sd">ConductorManager may use multiple drivers, and manage heterogeneous hardware.</span>

<span class="sd">When multiple :py:class:`ConductorManager` are run on different hosts, they are</span>
<span class="sd">all active and cooperatively manage all nodes in the deployment.  Nodes are</span>
<span class="sd">locked by each conductor when performing actions which change the state of that</span>
<span class="sd">node; these locks are represented by the</span>
<span class="sd">:py:class:`ironic.conductor.task_manager.TaskManager` class.</span>

<span class="sd">A `tooz.hashring.HashRing</span>
<span class="sd">&lt;https://git.openstack.org/cgit/openstack/tooz/tree/tooz/hashring.py&gt;`_</span>
<span class="sd">is used to distribute nodes across the set of active conductors which support</span>
<span class="sd">each node&#39;s driver.  Rebalancing this ring can trigger various actions by each</span>
<span class="sd">conductor, such as building or tearing down the TFTP environment for a node,</span>
<span class="sd">notifying Neutron of a change, etc.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="n">queue</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">import</span> <span class="nn">eventlet</span>
<span class="kn">from</span> <span class="nn">futurist</span> <span class="kn">import</span> <span class="n">periodics</span>
<span class="kn">from</span> <span class="nn">futurist</span> <span class="kn">import</span> <span class="n">waiters</span>
<span class="kn">from</span> <span class="nn">ironic_lib</span> <span class="kn">import</span> <span class="n">metrics_utils</span>
<span class="kn">from</span> <span class="nn">oslo_log</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">import</span> <span class="nn">oslo_messaging</span> <span class="kn">as</span> <span class="nn">messaging</span>
<span class="kn">from</span> <span class="nn">oslo_utils</span> <span class="kn">import</span> <span class="n">excutils</span>
<span class="kn">from</span> <span class="nn">oslo_utils</span> <span class="kn">import</span> <span class="n">uuidutils</span>

<span class="kn">from</span> <span class="nn">ironic.common</span> <span class="kn">import</span> <span class="n">driver_factory</span>
<span class="kn">from</span> <span class="nn">ironic.common</span> <span class="kn">import</span> <span class="n">exception</span>
<span class="kn">from</span> <span class="nn">ironic.common.glance_service</span> <span class="kn">import</span> <span class="n">service_utils</span> <span class="k">as</span> <span class="n">glance_utils</span>
<span class="kn">from</span> <span class="nn">ironic.common.i18n</span> <span class="kn">import</span> <span class="n">_</span><span class="p">,</span> <span class="n">_LE</span><span class="p">,</span> <span class="n">_LI</span><span class="p">,</span> <span class="n">_LW</span>
<span class="kn">from</span> <span class="nn">ironic.common</span> <span class="kn">import</span> <span class="n">images</span>
<span class="kn">from</span> <span class="nn">ironic.common</span> <span class="kn">import</span> <span class="n">states</span>
<span class="kn">from</span> <span class="nn">ironic.common</span> <span class="kn">import</span> <span class="n">swift</span>
<span class="kn">from</span> <span class="nn">ironic.conductor</span> <span class="kn">import</span> <span class="n">base_manager</span>
<span class="kn">from</span> <span class="nn">ironic.conductor</span> <span class="kn">import</span> <span class="n">notification_utils</span> <span class="k">as</span> <span class="n">notify_utils</span>
<span class="kn">from</span> <span class="nn">ironic.conductor</span> <span class="kn">import</span> <span class="n">task_manager</span>
<span class="kn">from</span> <span class="nn">ironic.conductor</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">ironic.conf</span> <span class="kn">import</span> <span class="n">CONF</span>
<span class="kn">from</span> <span class="nn">ironic.drivers</span> <span class="kn">import</span> <span class="n">base</span> <span class="k">as</span> <span class="n">drivers_base</span>
<span class="kn">from</span> <span class="nn">ironic.drivers</span> <span class="kn">import</span> <span class="n">hardware_type</span>
<span class="kn">from</span> <span class="nn">ironic</span> <span class="kn">import</span> <span class="n">objects</span>
<span class="kn">from</span> <span class="nn">ironic.objects</span> <span class="kn">import</span> <span class="n">base</span> <span class="k">as</span> <span class="n">objects_base</span>
<span class="kn">from</span> <span class="nn">ironic.objects</span> <span class="kn">import</span> <span class="n">fields</span>

<span class="n">MANAGER_TOPIC</span> <span class="o">=</span> <span class="s1">&#39;ironic.conductor_manager&#39;</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">METRICS</span> <span class="o">=</span> <span class="n">metrics_utils</span><span class="o">.</span><span class="n">get_metrics_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">SYNC_EXCLUDED_STATES</span> <span class="o">=</span> <span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">DEPLOYWAIT</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">ENROLL</span><span class="p">)</span>


<div class="viewcode-block" id="ConductorManager"><a class="viewcode-back" href="../../../api/ironic.conductor.manager.html#ironic.conductor.manager.ConductorManager">[docs]</a><span class="k">class</span> <span class="nc">ConductorManager</span><span class="p">(</span><span class="n">base_manager</span><span class="o">.</span><span class="n">BaseConductorManager</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ironic Conductor manager main class.&quot;&quot;&quot;</span>

    <span class="c1"># NOTE(rloo): This must be in sync with rpcapi.ConductorAPI&#39;s.</span>
    <span class="n">RPC_API_VERSION</span> <span class="o">=</span> <span class="s1">&#39;1.40&#39;</span>

    <span class="n">target</span> <span class="o">=</span> <span class="n">messaging</span><span class="o">.</span><span class="n">Target</span><span class="p">(</span><span class="n">version</span><span class="o">=</span><span class="n">RPC_API_VERSION</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">topic</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConductorManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">topic</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power_state_sync_count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.create_node&#39;</span><span class="p">)</span>
    <span class="c1"># No need to add these since they are subclasses of InvalidParameterValue:</span>
    <span class="c1">#     InterfaceNotFoundInEntrypoint</span>
    <span class="c1">#     IncompatibleInterface,</span>
    <span class="c1">#     NoValidDefaultForInterface</span>
    <span class="c1">#     MustBeNone</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">DriverNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a node in database.</span>

<span class="sd">        :param context: an admin context</span>
<span class="sd">        :param node_obj: a created (but not saved to the database) node object.</span>
<span class="sd">        :returns: created node object.</span>
<span class="sd">        :raises: InterfaceNotFoundInEntrypoint if validation fails for any</span>
<span class="sd">                 dynamic interfaces (e.g. network_interface).</span>
<span class="sd">        :raises: IncompatibleInterface if one or more of the requested</span>
<span class="sd">                 interfaces are not compatible with the hardware type.</span>
<span class="sd">        :raises: NoValidDefaultForInterface if no default can be calculated</span>
<span class="sd">                 for some interfaces, and explicit values must be provided.</span>
<span class="sd">        :raises: InvalidParameterValue if some fields fail validation.</span>
<span class="sd">        :raises: MustBeNone if one or more of the node&#39;s interface</span>
<span class="sd">                 fields were specified when they should not be.</span>
<span class="sd">        :raises: DriverNotFound if the driver or hardware type is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC create_node called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
        <span class="n">driver_factory</span><span class="o">.</span><span class="n">check_and_update_node_interfaces</span><span class="p">(</span><span class="n">node_obj</span><span class="p">)</span>
        <span class="n">node_obj</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node_obj</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.update_node&#39;</span><span class="p">)</span>
    <span class="c1"># No need to add these since they are subclasses of InvalidParameterValue:</span>
    <span class="c1">#     InterfaceNotFoundInEntrypoint</span>
    <span class="c1">#     IncompatibleInterface,</span>
    <span class="c1">#     NoValidDefaultForInterface</span>
    <span class="c1">#     MustBeNone</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">DriverNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a node with the supplied data.</span>

<span class="sd">        This method is the main &quot;hub&quot; for PUT and PATCH requests in the API.</span>
<span class="sd">        It ensures that the requested change is safe to perform,</span>
<span class="sd">        validates the parameters with the node&#39;s driver, if necessary.</span>

<span class="sd">        :param context: an admin context</span>
<span class="sd">        :param node_obj: a changed (but not saved) node object.</span>
<span class="sd">        :raises: NoValidDefaultForInterface if no default can be calculated</span>
<span class="sd">                 for some interfaces, and explicit values must be provided.</span>
<span class="sd">        :raises: MustBeNone if one or more of the node&#39;s interface</span>
<span class="sd">                 fields were specified when they should not be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">uuid</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC update_node called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># NOTE(jroll) clear maintenance_reason if node.update sets</span>
        <span class="c1"># maintenance to False for backwards compatibility, for tools</span>
        <span class="c1"># not using the maintenance endpoint.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">obj_what_changed</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;maintenance&#39;</span> <span class="ow">in</span> <span class="n">delta</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">maintenance</span><span class="p">:</span>
            <span class="n">node_obj</span><span class="o">.</span><span class="n">maintenance_reason</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># TODO(dtantsur): reconsider allowing changing some (but not all)</span>
        <span class="c1"># interfaces for active nodes in the future.</span>
        <span class="n">allowed_update_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">states</span><span class="o">.</span><span class="n">ENROLL</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">,</span>
                                 <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iface</span> <span class="ow">in</span> <span class="n">drivers_base</span><span class="o">.</span><span class="n">ALL_INTERFACES</span><span class="p">:</span>
            <span class="n">interface_field</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_interface&#39;</span> <span class="o">%</span> <span class="n">iface</span>
            <span class="k">if</span> <span class="n">interface_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">delta</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node_obj</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">in</span> <span class="n">allowed_update_states</span> <span class="ow">or</span>
                    <span class="n">node_obj</span><span class="o">.</span><span class="n">maintenance</span><span class="p">):</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">%(node)s</span><span class="s2"> can not have </span><span class="si">%(iface)s</span><span class="s2"> &quot;</span>
                           <span class="s2">&quot;updated unless it is in one of allowed &quot;</span>
                           <span class="s2">&quot;(</span><span class="si">%(allowed)s</span><span class="s2">) states or in maintenance mode.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">(</span>
                    <span class="n">action</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                              <span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_update_states</span><span class="p">),</span>
                              <span class="s1">&#39;iface&#39;</span><span class="p">:</span> <span class="n">interface_field</span><span class="p">})</span>

        <span class="n">driver_factory</span><span class="o">.</span><span class="n">check_and_update_node_interfaces</span><span class="p">(</span><span class="n">node_obj</span><span class="p">)</span>

        <span class="n">driver_name</span> <span class="o">=</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">driver</span> <span class="k">if</span> <span class="s1">&#39;driver&#39;</span> <span class="ow">in</span> <span class="n">delta</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">driver_name</span><span class="o">=</span><span class="n">driver_name</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node update&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="c1"># Prevent instance_uuid overwriting</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;instance_uuid&#39;</span> <span class="ow">in</span> <span class="n">delta</span> <span class="ow">and</span> <span class="n">node_obj</span><span class="o">.</span><span class="n">instance_uuid</span> <span class="ow">and</span>
                <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeAssociated</span><span class="p">(</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">node_id</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">)</span>

            <span class="n">node_obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">node_obj</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.change_node_power_state&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">change_node_power_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">new_state</span><span class="p">,</span>
                                <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to encapsulate changes to a node&#39;s state.</span>

<span class="sd">        Perform actions such as power on, power off. The validation is</span>
<span class="sd">        performed synchronously, and if successful, the power action is</span>
<span class="sd">        updated in the background (asynchronously). Once the power action</span>
<span class="sd">        is finished and successful, it updates the power_state for the</span>
<span class="sd">        node with the new power state.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :param new_state: the desired power state of the node.</span>
<span class="sd">        :param timeout: timeout (in seconds) positive integer (&gt; 0) for any</span>
<span class="sd">          power state. ``None`` indicates to use default timeout.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task.</span>
<span class="sd">        :raises: InvalidParameterValue</span>
<span class="sd">        :raises: MissingParameterValue</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC change_node_power_state called for node </span><span class="si">%(node)s</span><span class="s2">. &quot;</span>
                  <span class="s2">&quot;The desired new state is </span><span class="si">%(state)s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">new_state</span><span class="p">})</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;changing node power state&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="ow">not</span> <span class="ow">in</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">get_supported_power_states</span><span class="p">(</span><span class="n">task</span><span class="p">)):</span>
                <span class="c1"># FIXME(naohirot):</span>
                <span class="c1"># After driver composition, we should print power interface</span>
                <span class="c1"># name here instead of driver.</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;The driver </span><span class="si">%(driver)s</span><span class="s1"> does not support the power state,&#39;</span>
                      <span class="s1">&#39; </span><span class="si">%(state)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">{</span><span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">new_state</span><span class="p">})</span>

            <span class="k">if</span> <span class="n">new_state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">SOFT_REBOOT</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">SOFT_POWER_OFF</span><span class="p">):</span>
                <span class="n">power_timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="ow">or</span>
                                 <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">soft_power_off_timeout</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">power_timeout</span> <span class="o">=</span> <span class="n">timeout</span>

            <span class="c1"># Set the target_power_state and clear any last_error, since we&#39;re</span>
            <span class="c1"># starting a new operation. This will expose to other processes</span>
            <span class="c1"># and clients that work is in progress.</span>
            <span class="k">if</span> <span class="n">new_state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">POWER_ON</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">REBOOT</span><span class="p">,</span>
                             <span class="n">states</span><span class="o">.</span><span class="n">SOFT_REBOOT</span><span class="p">):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">target_power_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">POWER_ON</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">target_power_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">POWER_OFF</span>

            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_spawn_error_hook</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">power_state_error_handler</span><span class="p">,</span>
                                      <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">node_power_action</span><span class="p">,</span>
                             <span class="n">task</span><span class="p">,</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">power_timeout</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.vendor_passthru&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vendor_passthru</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">driver_method</span><span class="p">,</span>
                        <span class="n">http_method</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to encapsulate vendor action.</span>

<span class="sd">        Synchronously validate driver specific info, and if successful invoke</span>
<span class="sd">        the vendor method. If the method mode is &#39;async&#39; the conductor will</span>
<span class="sd">        start background worker to perform vendor action.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :param driver_method: the name of the vendor method.</span>
<span class="sd">        :param http_method: the HTTP method used for the request.</span>
<span class="sd">        :param info: vendor method args.</span>
<span class="sd">        :raises: InvalidParameterValue if supplied info is not valid.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info</span>
<span class="sd">        :raises: UnsupportedDriverExtension if current driver does not have</span>
<span class="sd">                 vendor interface or method is unsupported.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task.</span>
<span class="sd">        :raises: NodeLocked if the vendor passthru method requires an exclusive</span>
<span class="sd">                 lock but the node is locked by another conductor</span>
<span class="sd">        :returns: A dictionary containing:</span>

<span class="sd">            :return: The response of the invoked vendor method</span>
<span class="sd">            :async: Boolean value. Whether the method was invoked</span>
<span class="sd">                asynchronously (True) or synchronously (False). When invoked</span>
<span class="sd">                asynchronously the response will be always None.</span>
<span class="sd">            :attach: Boolean value. Whether to attach the response of</span>
<span class="sd">                the invoked vendor method to the HTTP response object (True)</span>
<span class="sd">                or return it in the response body (False).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC vendor_passthru called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="c1"># NOTE(mariojv): Not all vendor passthru methods require an exclusive</span>
        <span class="c1"># lock on a node, so we acquire a shared lock initially. If a method</span>
        <span class="c1"># requires an exclusive lock, we&#39;ll acquire one after checking</span>
        <span class="c1"># vendor_opts before starting validation.</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;calling vendor passthru&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                    <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;vendor interface&#39;</span><span class="p">)</span>

            <span class="n">vendor_iface</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">vendor</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">vendor_opts</span> <span class="o">=</span> <span class="n">vendor_iface</span><span class="o">.</span><span class="n">vendor_routes</span><span class="p">[</span><span class="n">driver_method</span><span class="p">]</span>
                <span class="n">vendor_func</span> <span class="o">=</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;No handler for method </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">driver_method</span><span class="p">)</span>

            <span class="n">http_method</span> <span class="o">=</span> <span class="n">http_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">http_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;http_methods&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="si">%(method)s</span><span class="s1"> does not support HTTP </span><span class="si">%(http)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">driver_method</span><span class="p">,</span> <span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="n">http_method</span><span class="p">})</span>

            <span class="c1"># Change shared lock to exclusive if a vendor method requires</span>
            <span class="c1"># it. Vendor methods default to requiring an exclusive lock.</span>
            <span class="k">if</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;require_exclusive_lock&#39;</span><span class="p">]:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">upgrade_lock</span><span class="p">()</span>

            <span class="n">vendor_iface</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">driver_method</span><span class="p">,</span>
                                  <span class="n">http_method</span><span class="o">=</span><span class="n">http_method</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

            <span class="c1"># Inform the vendor method which HTTP method it was invoked with</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;http_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">http_method</span>

            <span class="c1"># Invoke the vendor method accordingly with the mode</span>
            <span class="n">is_async</span> <span class="o">=</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;async&#39;</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">is_async</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span> <span class="n">vendor_func</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">vendor_func</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="n">ret</span><span class="p">,</span>
                    <span class="s1">&#39;async&#39;</span><span class="p">:</span> <span class="n">is_async</span><span class="p">,</span>
                    <span class="s1">&#39;attach&#39;</span><span class="p">:</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;attach&#39;</span><span class="p">]}</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.driver_vendor_passthru&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">DriverNotFound</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoValidDefaultForInterface</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InterfaceNotFoundInEntrypoint</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">driver_vendor_passthru</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">driver_method</span><span class="p">,</span>
                               <span class="n">http_method</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle top-level vendor actions.</span>

<span class="sd">        RPC method which handles driver-level vendor passthru calls. These</span>
<span class="sd">        calls don&#39;t require a node UUID and are executed on a random</span>
<span class="sd">        conductor with the specified driver. If the method mode is</span>
<span class="sd">        async the conductor will start background worker to perform</span>
<span class="sd">        vendor action.</span>

<span class="sd">        For dynamic drivers, the calculated default vendor interface is used.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param driver_name: name of the driver or hardware type on which to</span>
<span class="sd">                            call the method.</span>
<span class="sd">        :param driver_method: name of the vendor method, for use by the driver.</span>
<span class="sd">        :param http_method: the HTTP method used for the request.</span>
<span class="sd">        :param info: user-supplied data to pass through to the driver.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info</span>
<span class="sd">        :raises: InvalidParameterValue if supplied info is not valid.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if current driver does not have</span>
<span class="sd">                 vendor interface, if the vendor interface does not implement</span>
<span class="sd">                 driver-level vendor passthru or if the passthru method is</span>
<span class="sd">                 unsupported.</span>
<span class="sd">        :raises: DriverNotFound if the supplied driver is not loaded.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task.</span>
<span class="sd">        :raises: NoValidDefaultForInterface if no default interface</span>
<span class="sd">                 implementation can be found for this driver&#39;s vendor</span>
<span class="sd">                 interface.</span>
<span class="sd">        :raises: InterfaceNotFoundInEntrypoint if the default interface for a</span>
<span class="sd">                 hardware type is invalid.</span>
<span class="sd">        :returns: A dictionary containing:</span>

<span class="sd">            :return: The response of the invoked vendor method</span>
<span class="sd">            :async: Boolean value. Whether the method was invoked</span>
<span class="sd">                asynchronously (True) or synchronously (False). When invoked</span>
<span class="sd">                asynchronously the response will be always None.</span>
<span class="sd">            :attach: Boolean value. Whether to attach the response of</span>
<span class="sd">                the invoked vendor method to the HTTP response object (True)</span>
<span class="sd">                or return it in the response body (False).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Any locking in a top-level vendor action will need to be done by the</span>
        <span class="c1"># implementation, as there is little we could reasonably lock on here.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC driver_vendor_passthru for driver </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">)</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_driver_or_hardware_type</span><span class="p">(</span><span class="n">driver_name</span><span class="p">)</span>
        <span class="n">vendor</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">.</span><span class="n">AbstractHardwareType</span><span class="p">):</span>
            <span class="n">vendor_name</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">default_interface</span><span class="p">(</span>
                <span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="n">driver_name</span><span class="o">=</span><span class="n">driver_name</span><span class="p">)</span>
            <span class="n">vendor</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_interface</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span>
                                                  <span class="n">vendor_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vendor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vendor</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">driver_name</span><span class="p">,</span>
                    <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;vendor interface&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">vendor_opts</span> <span class="o">=</span> <span class="n">vendor</span><span class="o">.</span><span class="n">driver_routes</span><span class="p">[</span><span class="n">driver_method</span><span class="p">]</span>
            <span class="n">vendor_func</span> <span class="o">=</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;No handler for method </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">driver_method</span><span class="p">)</span>

        <span class="n">http_method</span> <span class="o">=</span> <span class="n">http_method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">http_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;http_methods&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span>
                <span class="n">_</span><span class="p">(</span><span class="s1">&#39;The method </span><span class="si">%(method)s</span><span class="s1"> does not support HTTP </span><span class="si">%(http)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">driver_method</span><span class="p">,</span> <span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="n">http_method</span><span class="p">})</span>

        <span class="c1"># Inform the vendor method which HTTP method it was invoked with</span>
        <span class="n">info</span><span class="p">[</span><span class="s1">&#39;http_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">http_method</span>

        <span class="c1"># Invoke the vendor method accordingly with the mode</span>
        <span class="n">is_async</span> <span class="o">=</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;async&#39;</span><span class="p">]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">vendor</span><span class="o">.</span><span class="n">driver_validate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">driver_method</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_async</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">(</span><span class="n">vendor_func</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">vendor_func</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="n">ret</span><span class="p">,</span>
                <span class="s1">&#39;async&#39;</span><span class="p">:</span> <span class="n">is_async</span><span class="p">,</span>
                <span class="s1">&#39;attach&#39;</span><span class="p">:</span> <span class="n">vendor_opts</span><span class="p">[</span><span class="s1">&#39;attach&#39;</span><span class="p">]}</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_node_vendor_passthru_methods&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_node_vendor_passthru_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve information about vendor methods of the given node.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :returns: dictionary of &lt;method name&gt;:&lt;method metadata&gt; entries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC get_node_vendor_passthru_methods called for node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="n">node_id</span><span class="p">)</span>
        <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;listing vendor passthru methods&#39;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                    <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;vendor interface&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">get_vendor_passthru_metadata</span><span class="p">(</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">vendor</span><span class="o">.</span><span class="n">vendor_routes</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_driver_vendor_passthru_methods&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">DriverNotFound</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoValidDefaultForInterface</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InterfaceNotFoundInEntrypoint</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_driver_vendor_passthru_methods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve information about vendor methods of the given driver.</span>

<span class="sd">        For dynamic drivers, the default vendor interface is used.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param driver_name: name of the driver or hardware_type</span>
<span class="sd">        :raises: UnsupportedDriverExtension if current driver does not have</span>
<span class="sd">                 vendor interface.</span>
<span class="sd">        :raises: DriverNotFound if the supplied driver is not loaded.</span>
<span class="sd">        :raises: NoValidDefaultForInterface if no default interface</span>
<span class="sd">                 implementation can be found for this driver&#39;s vendor</span>
<span class="sd">                 interface.</span>
<span class="sd">        :raises: InterfaceNotFoundInEntrypoint if the default interface for a</span>
<span class="sd">                 hardware type is invalid.</span>
<span class="sd">        :returns: dictionary of &lt;method name&gt;:&lt;method metadata&gt; entries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Any locking in a top-level vendor action will need to be done by the</span>
        <span class="c1"># implementation, as there is little we could reasonably lock on here.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC get_driver_vendor_passthru_methods for driver </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                  <span class="n">driver_name</span><span class="p">)</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_driver_or_hardware_type</span><span class="p">(</span><span class="n">driver_name</span><span class="p">)</span>
        <span class="n">vendor</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">.</span><span class="n">AbstractHardwareType</span><span class="p">):</span>
            <span class="n">vendor_name</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">default_interface</span><span class="p">(</span>
                <span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="n">driver_name</span><span class="o">=</span><span class="n">driver_name</span><span class="p">)</span>
            <span class="n">vendor</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_interface</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span>
                                                  <span class="n">vendor_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vendor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;vendor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vendor</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">driver_name</span><span class="p">,</span>
                    <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;vendor interface&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_vendor_passthru_metadata</span><span class="p">(</span><span class="n">vendor</span><span class="o">.</span><span class="n">driver_routes</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.do_node_deploy&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeInMaintenance</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InstanceDeployFailure</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">do_node_deploy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">rebuild</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">configdrive</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to initiate deployment to a node.</span>

<span class="sd">        Initiate the deployment of a node. Validations are done</span>
<span class="sd">        synchronously and the actual deploy work is performed in</span>
<span class="sd">        background (asynchronously).</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :param rebuild: True if this is a rebuild request. A rebuild will</span>
<span class="sd">                        recreate the instance on the same node, overwriting</span>
<span class="sd">                        all disk. The ephemeral partition, if it exists, can</span>
<span class="sd">                        optionally be preserved.</span>
<span class="sd">        :param configdrive: Optional. A gzipped and base64 encoded configdrive.</span>
<span class="sd">        :raises: InstanceDeployFailure</span>
<span class="sd">        :raises: NodeInMaintenance if the node is in maintenance mode.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task.</span>
<span class="sd">        :raises: InvalidStateRequested when the requested state is not a valid</span>
<span class="sd">                 target from the current state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC do_node_deploy called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># NOTE(comstud): If the _sync_power_states() periodic task happens</span>
        <span class="c1"># to have locked this node, we&#39;ll fail to acquire the lock. The</span>
        <span class="c1"># client should perhaps retry in this case unless we decide we</span>
        <span class="c1"># want to add retries or extra synchronization here.</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node deployment&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeInMaintenance</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;provisioning&#39;</span><span class="p">),</span>
                                                  <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rebuild</span><span class="p">:</span>
                <span class="n">event</span> <span class="o">=</span> <span class="s1">&#39;rebuild&#39;</span>

                <span class="c1"># Note(gilliard) Clear these to force the driver to</span>
                <span class="c1"># check whether they have been changed in glance</span>
                <span class="c1"># NOTE(vdrok): If image_source is not from Glance we should</span>
                <span class="c1"># not clear kernel and ramdisk as they&#39;re input manually</span>
                <span class="k">if</span> <span class="n">glance_utils</span><span class="o">.</span><span class="n">is_glance_image</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;image_source&#39;</span><span class="p">)):</span>
                    <span class="n">instance_info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span>
                    <span class="n">instance_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kernel&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">instance_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ramdisk&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span> <span class="o">=</span> <span class="n">instance_info</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">event</span> <span class="o">=</span> <span class="s1">&#39;deploy&#39;</span>

            <span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span>
            <span class="c1"># Infer the image type to make sure the deploy driver</span>
            <span class="c1"># validates only the necessary variables for different</span>
            <span class="c1"># image types.</span>
            <span class="c1"># NOTE(sirushtim): The iwdi variable can be None. It&#39;s up to</span>
            <span class="c1"># the deploy driver to validate this.</span>
            <span class="n">iwdi</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">is_whole_disk_image</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span><span class="p">)</span>
            <span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;is_whole_disk_image&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iwdi</span>
            <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">driver_internal_info</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InstanceDeployFailure</span><span class="p">(</span>
                    <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Failed to validate deploy or power info for node &quot;</span>
                      <span class="s2">&quot;</span><span class="si">%(node_uuid)s</span><span class="s2">. Error: </span><span class="si">%(msg)s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">{</span><span class="s1">&#39;node_uuid&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>

            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;do_node_deploy Calling event: </span><span class="si">%(event)s</span><span class="s2"> for node: &quot;</span>
                      <span class="s2">&quot;</span><span class="si">%(node)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;event&#39;</span><span class="p">:</span> <span class="n">event</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="n">event</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="n">do_node_deploy</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                               <span class="n">configdrive</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="n">event</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.do_node_tear_down&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InstanceDeployFailure</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">do_node_tear_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to tear down an existing node deployment.</span>

<span class="sd">        Validate driver specific information synchronously, and then</span>
<span class="sd">        spawn a background worker to tear down the node asynchronously.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :raises: InstanceDeployFailure</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task</span>
<span class="sd">        :raises: InvalidStateRequested when the requested state is not a valid</span>
<span class="sd">                 target from the current state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC do_node_tear_down called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node tear down&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># NOTE(ghe): Valid power driver values are needed to perform</span>
                <span class="c1"># a tear-down. Deploy info is useful to purge the cache but not</span>
                <span class="c1"># required for this method.</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InstanceDeployFailure</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s2">&quot;Failed to validate power driver interface. &quot;</span>
                    <span class="s2">&quot;Can not delete instance. Error: </span><span class="si">%(msg)s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;delete&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_tear_down</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">)</span>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_node_tear_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal RPC method to tear down an existing node deployment.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">clean_up</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">tear_down</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Error in tear_down of node </span><span class="si">%(node)s</span><span class="s1">: &#39;</span>
                                  <span class="s1">&#39;</span><span class="si">%(err)s</span><span class="s1">&#39;</span><span class="p">),</span>
                              <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
                <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Failed to tear down. Error: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">e</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NOTE(deva): When tear_down finishes, the deletion is done,</span>
            <span class="c1"># cleaning will start next</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully unprovisioned node </span><span class="si">%(node)s</span><span class="s1"> with &#39;</span>
                         <span class="s1">&#39;instance </span><span class="si">%(instance)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;instance&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">})</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># NOTE(deva): there is no need to unset conductor_affinity</span>
            <span class="c1"># because it is a reference to the most recent conductor which</span>
            <span class="c1"># deployed a node, and does not limit any future actions.</span>
            <span class="c1"># But we do need to clear the instance-related fields.</span>
            <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span>
            <span class="n">driver_internal_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;instance&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">driver_internal_info</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="c1"># Begin cleaning</span>
        <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;clean&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_node_clean</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_node_next_clean_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">skip_current_step</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the task&#39;s node&#39;s next clean steps.</span>

<span class="sd">        This determines what the next (remaining) clean steps are, and</span>
<span class="sd">        returns the index into the clean steps list that corresponds to the</span>
<span class="sd">        next clean step. The remaining clean steps are determined as follows:</span>

<span class="sd">        * If no clean steps have been started yet, all the clean steps</span>
<span class="sd">          must be executed</span>
<span class="sd">        * If skip_current_step is False, the remaining clean steps start</span>
<span class="sd">          with the current clean step. Otherwise, the remaining clean steps</span>
<span class="sd">          start with the clean step after the current one.</span>

<span class="sd">        All the clean steps for an automated or manual cleaning are in</span>
<span class="sd">        node.driver_internal_info[&#39;clean_steps&#39;]. node.clean_step is the</span>
<span class="sd">        current clean step that was just executed (or None, {} if no steps</span>
<span class="sd">        have been executed yet). node.driver_internal_info[&#39;clean_step_index&#39;]</span>
<span class="sd">        is the index into the clean steps list (or None, doesn&#39;t exist if no</span>
<span class="sd">        steps have been executed yet) and corresponds to node.clean_step.</span>

<span class="sd">        :param task: A TaskManager object</span>
<span class="sd">        :param skip_current_step: True to skip the current clean step; False to</span>
<span class="sd">                                  include it.</span>
<span class="sd">        :raises: NodeCleaningFailure if an internal error occurred when</span>
<span class="sd">                 getting the next clean steps</span>
<span class="sd">        :returns: index of the next clean step; None if there are no clean</span>
<span class="sd">                  steps to execute.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="p">:</span>
            <span class="c1"># first time through, all steps need to be done. Return the</span>
            <span class="c1"># index of the first step in the list.</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clean_step_index&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">skip_current_step</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;clean_steps&#39;</span><span class="p">]):</span>
            <span class="c1"># no steps left to do</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">ind</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.do_node_clean&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeInMaintenance</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">do_node_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">clean_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to initiate manual cleaning.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the ID or UUID of a node.</span>
<span class="sd">        :param clean_steps: an ordered list of clean steps that will be</span>
<span class="sd">            performed on the node. A clean step is a dictionary with required</span>
<span class="sd">            keys &#39;interface&#39; and &#39;step&#39;, and optional key &#39;args&#39;. If</span>
<span class="sd">            specified, the &#39;args&#39; arguments are passed to the clean step</span>
<span class="sd">            method.::</span>

<span class="sd">              { &#39;interface&#39;: &lt;driver_interface&gt;,</span>
<span class="sd">                &#39;step&#39;: &lt;name_of_clean_step&gt;,</span>
<span class="sd">                &#39;args&#39;: {&lt;arg1&gt;: &lt;value1&gt;, ..., &lt;argn&gt;: &lt;valuen&gt;} }</span>

<span class="sd">            For example (this isn&#39;t a real example, this clean step</span>
<span class="sd">            doesn&#39;t exist)::</span>

<span class="sd">              { &#39;interface&#39;: deploy&#39;,</span>
<span class="sd">                &#39;step&#39;: &#39;upgrade_firmware&#39;,</span>
<span class="sd">                &#39;args&#39;: {&#39;force&#39;: True} }</span>
<span class="sd">        :raises: InvalidParameterValue if power validation fails.</span>
<span class="sd">        :raises: InvalidStateRequested if the node is not in manageable state.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node manual cleaning&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeInMaintenance</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;cleaning&#39;</span><span class="p">),</span>
                                                  <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

            <span class="c1"># NOTE(rloo): _do_node_clean() will also make similar calls to</span>
            <span class="c1"># validate power &amp; network, but we are doing it again here so that</span>
            <span class="c1"># the user gets immediate feedback of any issues. This behaviour</span>
            <span class="c1"># (of validating) is consistent with other methods like</span>
            <span class="c1"># self.do_node_deploy().</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Validation failed. Cannot clean node </span><span class="si">%(node)s</span><span class="s1">. &#39;</span>
                         <span class="s1">&#39;Error: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                       <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;clean&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_clean</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">clean_steps</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">,</span>
                    <span class="n">target_state</span><span class="o">=</span><span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="s1">&#39;manual clean&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.continue_node_clean&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="ConductorManager.continue_node_clean"><a class="viewcode-back" href="../../../api/ironic.conductor.manager.html#ironic.conductor.manager.ConductorManager.continue_node_clean">[docs]</a>    <span class="k">def</span> <span class="nf">continue_node_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to continue cleaning a node.</span>

<span class="sd">        This is useful for cleaning tasks that are async. When they complete,</span>
<span class="sd">        they call back via RPC, a new worker and lock are set up, and cleaning</span>
<span class="sd">        continues. This can also be used to resume cleaning on take_over.</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :raises: InvalidStateRequested if the node is not in CLEANWAIT state</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: NodeNotFound if the node no longer appears in the database</span>
<span class="sd">        :raises: NodeCleaningFailure if an internal error occurred when</span>
<span class="sd">                 getting the next clean steps</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC continue_node_clean called for node </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;continue node cleaning&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">target_provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">:</span>
                <span class="n">target_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_state</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">!=</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot continue cleaning on </span><span class="si">%(node)s</span><span class="s1">, node is in &#39;</span>
                    <span class="s1">&#39;</span><span class="si">%(state)s</span><span class="s1"> state, should be </span><span class="si">%(clean_state)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                     <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">,</span>
                     <span class="s1">&#39;clean_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">})</span>

            <span class="n">info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">skip_current_step</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;skip_current_clean_step&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">skip_current_step</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">info</span>
                <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

            <span class="n">next_step_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_next_clean_steps</span><span class="p">(</span>
                <span class="n">task</span><span class="p">,</span> <span class="n">skip_current_step</span><span class="o">=</span><span class="n">skip_current_step</span><span class="p">)</span>

            <span class="c1"># If this isn&#39;t the final clean step in the cleaning operation</span>
            <span class="c1"># and it is flagged to abort after the clean step that just</span>
            <span class="c1"># finished, we abort the cleaning operation.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;abort_after&#39;</span><span class="p">):</span>
                <span class="n">step_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">next_step_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The cleaning operation for node </span><span class="si">%(node)s</span><span class="s1"> was &#39;</span>
                              <span class="s1">&#39;marked to be aborted after step &quot;</span><span class="si">%(step)s</span><span class="s1"> &#39;</span>
                              <span class="s1">&#39;completed. Aborting now that it has completed.&#39;</span><span class="p">,</span>
                              <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step_name</span><span class="p">})</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                        <span class="s1">&#39;abort&#39;</span><span class="p">,</span>
                        <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                        <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_clean_abort</span><span class="p">,</span>
                                   <span class="n">task</span><span class="p">,</span> <span class="n">step_name</span><span class="p">),</span>
                        <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">,</span>
                        <span class="n">target_state</span><span class="o">=</span><span class="n">target_state</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The cleaning operation for node </span><span class="si">%(node)s</span><span class="s1"> was &#39;</span>
                          <span class="s1">&#39;marked to be aborted after step &quot;</span><span class="si">%(step)s</span><span class="s1">&quot; &#39;</span>
                          <span class="s1">&#39;completed. However, since there are no more &#39;</span>
                          <span class="s1">&#39;clean steps after this, the abort is not going &#39;</span>
                          <span class="s1">&#39;to be done.&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                          <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step_name</span><span class="p">})</span>

            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;resume&#39;</span><span class="p">,</span> <span class="n">target_state</span><span class="o">=</span><span class="n">target_state</span><span class="p">)</span>

            <span class="n">task</span><span class="o">.</span><span class="n">set_spawn_error_hook</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">spawn_cleaning_error_handler</span><span class="p">,</span>
                                      <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_do_next_clean_step</span><span class="p">,</span>
                <span class="n">task</span><span class="p">,</span> <span class="n">next_step_index</span><span class="p">)</span></div>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_node_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">clean_steps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal RPC method to perform cleaning of a node.</span>

<span class="sd">        :param task: a TaskManager instance with an exclusive lock on its node</span>
<span class="sd">        :param clean_steps: For a manual clean, the list of clean steps to</span>
<span class="sd">                            perform. Is None For automated cleaning (default).</span>
<span class="sd">                            For more information, see the clean_steps parameter</span>
<span class="sd">                            of :func:`ConductorManager.do_node_clean`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="n">manual_clean</span> <span class="o">=</span> <span class="n">clean_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
        <span class="n">clean_type</span> <span class="o">=</span> <span class="s1">&#39;manual&#39;</span> <span class="k">if</span> <span class="n">manual_clean</span> <span class="k">else</span> <span class="s1">&#39;automated&#39;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Starting </span><span class="si">%(type)s</span><span class="s1"> cleaning for node </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">clean_type</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">manual_clean</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">automated_clean</span><span class="p">:</span>
            <span class="c1"># Skip cleaning, move to AVAILABLE.</span>
            <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Automated cleaning is disabled, node </span><span class="si">%s</span><span class="s1"> has been &#39;</span>
                         <span class="s1">&#39;successfully moved to AVAILABLE state.&#39;</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># NOTE(ghe): Valid power and network values are needed to perform</span>
            <span class="c1"># a cleaning.</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Validation failed. Cannot clean node </span><span class="si">%(node)s</span><span class="s1">. &#39;</span>
                     <span class="s1">&#39;Error: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                   <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">manual_clean</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;clean_steps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clean_steps</span>
            <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">info</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

        <span class="c1"># Allow the deploy driver to set up the ramdisk again (necessary for</span>
        <span class="c1"># IPA cleaning)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">prepare_result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">prepare_cleaning</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to prepare node </span><span class="si">%(node)s</span><span class="s1"> for cleaning: </span><span class="si">%(e)s</span><span class="s1">&#39;</span><span class="p">)</span>
                   <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prepare_result</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">:</span>
            <span class="c1"># Prepare is asynchronous, the deploy driver will need to</span>
            <span class="c1"># set node.driver_internal_info[&#39;clean_steps&#39;] and</span>
            <span class="c1"># node.clean_step and then make an RPC call to</span>
            <span class="c1"># continue_node_cleaning to start cleaning.</span>

            <span class="c1"># For manual cleaning, the target provision state is MANAGEABLE,</span>
            <span class="c1"># whereas for automated cleaning, it is AVAILABLE (the default).</span>
            <span class="n">target_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span> <span class="k">if</span> <span class="n">manual_clean</span> <span class="k">else</span> <span class="bp">None</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;wait&#39;</span><span class="p">,</span> <span class="n">target_state</span><span class="o">=</span><span class="n">target_state</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">set_node_cleaning_steps</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                <span class="n">exception</span><span class="o">.</span><span class="n">NodeCleaningFailure</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Cannot clean node </span><span class="si">%(node)s</span><span class="s1">. Error: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span>
                   <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="n">steps</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;clean_steps&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">step_index</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">steps</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_next_clean_step</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">step_index</span><span class="p">)</span>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_next_clean_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">step_index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do cleaning, starting from the specified clean step.</span>

<span class="sd">        :param task: a TaskManager instance with an exclusive lock</span>
<span class="sd">        :param step_index: The first clean step in the list to execute. This</span>
<span class="sd">            is the index (from 0) into the list of clean steps in the node&#39;s</span>
<span class="sd">            driver_internal_info[&#39;clean_steps&#39;]. Is None if there are no steps</span>
<span class="sd">            to execute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="c1"># For manual cleaning, the target provision state is MANAGEABLE,</span>
        <span class="c1"># whereas for automated cleaning, it is AVAILABLE.</span>
        <span class="n">manual_clean</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">target_provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span>

        <span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span>
        <span class="k">if</span> <span class="n">step_index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;clean_steps&#39;</span><span class="p">][</span><span class="n">step_index</span><span class="p">:]</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Executing </span><span class="si">%(state)s</span><span class="s1"> on node </span><span class="si">%(node)s</span><span class="s1">, remaining steps: &#39;</span>
                     <span class="s1">&#39;</span><span class="si">%(steps)s</span><span class="s1">&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="n">steps</span><span class="p">,</span>
                                    <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">})</span>

        <span class="c1"># Execute each step until we hit an async step or run out of steps</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
            <span class="c1"># Save which step we&#39;re about to start so we can restart</span>
            <span class="c1"># if necessary</span>
            <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="o">=</span> <span class="n">step</span>
            <span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;clean_step_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">step_index</span> <span class="o">+</span> <span class="n">ind</span>
            <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">driver_internal_info</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">interface</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;interface&#39;</span><span class="p">))</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Executing </span><span class="si">%(step)s</span><span class="s1"> on node </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">execute_clean_step</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Node </span><span class="si">%(node)s</span><span class="s1"> failed step </span><span class="si">%(step)s</span><span class="s1">: &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(exc)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                       <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;exc&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span>
                        <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="p">})</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="c1"># Check if the step is done or not. The step should return</span>
            <span class="c1"># states.CLEANWAIT if the step is still being executed, or</span>
            <span class="c1"># None if the step is done.</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">:</span>
                <span class="c1"># Kill this worker, the async step will make an RPC call to</span>
                <span class="c1"># continue_node_clean to continue cleaning</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Clean step </span><span class="si">%(step)s</span><span class="s1"> on node </span><span class="si">%(node)s</span><span class="s1"> being &#39;</span>
                             <span class="s1">&#39;executed asynchronously, waiting for driver.&#39;</span><span class="p">),</span>
                         <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">})</span>
                <span class="n">target_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span> <span class="k">if</span> <span class="n">manual_clean</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;wait&#39;</span><span class="p">,</span> <span class="n">target_state</span><span class="o">=</span><span class="n">target_state</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;While executing step </span><span class="si">%(step)s</span><span class="s1"> on node &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">, step returned invalid value: </span><span class="si">%(val)s</span><span class="s1">&#39;</span><span class="p">)</span>
                       <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">})</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Node </span><span class="si">%(node)s</span><span class="s1"> finished clean step </span><span class="si">%(step)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">step</span><span class="p">})</span>

        <span class="c1"># Clear clean_step</span>
        <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;clean_steps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">driver_internal_info</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;clean_step_index&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span> <span class="o">=</span> <span class="n">driver_internal_info</span>
        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">tear_down_cleaning</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to tear down from cleaning for node </span><span class="si">%(node)s</span><span class="s1">, &#39;</span>
                     <span class="s1">&#39;reason: </span><span class="si">%(err)s</span><span class="s1">&#39;</span><span class="p">)</span>
                   <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
                                                <span class="n">tear_down_cleaning</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Node </span><span class="si">%s</span><span class="s1"> cleaning complete&#39;</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
        <span class="n">event</span> <span class="o">=</span> <span class="s1">&#39;manage&#39;</span> <span class="k">if</span> <span class="n">manual_clean</span> <span class="k">else</span> <span class="s1">&#39;done&#39;</span>
        <span class="c1"># NOTE(rloo): No need to specify target prov. state; we&#39;re done</span>
        <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_node_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal method to perform power credentials verification.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Starting power credentials verification for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to validate power driver interface for node &#39;</span>
                       <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">. Error: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">power_state</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">get_power_state</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to get power state for node &#39;</span>
                           <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">. Error: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                         <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">error</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">power_state</span> <span class="o">!=</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">:</span>
                <span class="n">old_power_state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span>
                <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">power_state</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
                <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_power_state_corrected_notification</span><span class="p">(</span>
                    <span class="n">task</span><span class="p">,</span> <span class="n">old_power_state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">error</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)</span>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_node_clean_abort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">step_name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal method to abort an ongoing operation.</span>

<span class="sd">        :param task: a TaskManager instance with an exclusive lock</span>
<span class="sd">        :param step_name: The name of the clean step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">tear_down_cleaning</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Failed to tear down cleaning for node </span><span class="si">%(node)s</span><span class="s1"> &#39;</span>
                              <span class="s1">&#39;after aborting the operation. Error: </span><span class="si">%(err)s</span><span class="s1">&#39;</span><span class="p">),</span>
                          <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to tear down cleaning after aborting &#39;</span>
                          <span class="s1">&#39;the operation&#39;</span><span class="p">)</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">cleaning_error_handler</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">,</span>
                                         <span class="n">tear_down_cleaning</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                         <span class="n">set_fail_state</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">info_message</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Clean operation aborted for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span>
        <span class="n">last_error</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;By request, the clean operation was aborted&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step_name</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39; after the completion of step &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">step_name</span>
            <span class="n">last_error</span> <span class="o">+=</span> <span class="n">msg</span>
            <span class="n">info_message</span> <span class="o">+=</span> <span class="n">msg</span>

        <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">last_error</span>
        <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info_message</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.do_provisioning_action&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">do_provisioning_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;RPC method to initiate certain provisioning state transitions.</span>

<span class="sd">        Initiate a provisioning state change through the state machine,</span>
<span class="sd">        rather than through an RPC call to do_node_deploy / do_node_tear_down</span>

<span class="sd">        :param context: an admin context.</span>
<span class="sd">        :param node_id: the id or uuid of a node.</span>
<span class="sd">        :param action: an action. One of ironic.common.states.VERBS</span>
<span class="sd">        :raises: InvalidParameterValue</span>
<span class="sd">        :raises: InvalidStateRequested</span>
<span class="sd">        :raises: NoFreeConductorWorker</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;provision action </span><span class="si">%s</span><span class="s1">&#39;</span>
                                  <span class="o">%</span> <span class="n">action</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">VERBS</span><span class="p">[</span><span class="s1">&#39;provide&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;provide&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_clean</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">VERBS</span><span class="p">[</span><span class="s1">&#39;manage&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">ENROLL</span><span class="p">):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;manage&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_verify</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">VERBS</span><span class="p">[</span><span class="s1">&#39;adopt&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">,</span>
                <span class="n">states</span><span class="o">.</span><span class="n">ADOPTFAIL</span><span class="p">)):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;adopt&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_adoption</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">VERBS</span><span class="p">[</span><span class="s1">&#39;abort&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">):</span>

                <span class="c1"># Check if the clean step is abortable; if so abort it.</span>
                <span class="c1"># Otherwise, indicate in that clean step, that cleaning</span>
                <span class="c1"># should be aborted after that step is done.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;abortable&#39;</span><span class="p">)):</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;The current clean step &quot;</span><span class="si">%(clean_step)s</span><span class="s1">&quot; for &#39;</span>
                                 <span class="s1">&#39;node </span><span class="si">%(node)s</span><span class="s1"> is not abortable. Adding a &#39;</span>
                                 <span class="s1">&#39;flag to abort the cleaning after the clean &#39;</span>
                                 <span class="s1">&#39;step is completed.&#39;</span><span class="p">),</span>
                             <span class="p">{</span><span class="s1">&#39;clean_step&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">],</span>
                              <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
                    <span class="n">clean_step</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">clean_step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;abort_after&#39;</span><span class="p">):</span>
                        <span class="n">clean_step</span><span class="p">[</span><span class="s1">&#39;abort_after&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span> <span class="o">=</span> <span class="n">clean_step</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
                    <span class="k">return</span>

                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Aborting the cleaning operation during clean step &#39;</span>
                          <span class="s1">&#39;&quot;</span><span class="si">%(step)s</span><span class="s1">&quot; for node </span><span class="si">%(node)s</span><span class="s1"> in provision state &#39;</span>
                          <span class="s1">&#39;&quot;</span><span class="si">%(prov)s</span><span class="s1">&quot;.&#39;</span><span class="p">,</span>
                          <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                           <span class="s1">&#39;prov&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">,</span>
                           <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">clean_step</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">)})</span>
                <span class="n">target_state</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">target_provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">:</span>
                    <span class="n">target_state</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;abort&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_do_node_clean_abort</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">,</span>
                    <span class="n">target_state</span><span class="o">=</span><span class="n">target_state</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="n">action</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._sync_power_states&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">sync_power_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_sync_power_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodic task to sync power states for the nodes.</span>

<span class="sd">        Attempt to grab a lock and sync only if the following</span>
<span class="sd">        conditions are met:</span>

<span class="sd">        1) Node is mapped to this conductor.</span>
<span class="sd">        2) Node is not in maintenance mode.</span>
<span class="sd">        3) Node is not in DEPLOYWAIT/CLEANWAIT provision state.</span>
<span class="sd">        4) Node doesn&#39;t have a reservation</span>

<span class="sd">        NOTE: Grabbing a lock here can cause other methods to fail to</span>
<span class="sd">        grab it. We want to avoid trying to grab a lock while a node</span>
<span class="sd">        is in the DEPLOYWAIT/CLEANWAIT state so we don&#39;t unnecessarily</span>
<span class="sd">        cause a deploy/cleaning callback to fail. There&#39;s not much we</span>
<span class="sd">        can do here to avoid failing a brand new deploy to a node that</span>
<span class="sd">        we&#39;ve locked here, though.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME(comstud): Since our initial state checks are outside</span>
        <span class="c1"># of the lock (to try to avoid the lock), some checks are</span>
        <span class="c1"># repeated after grabbing the lock so we can unlock quickly.</span>
        <span class="c1"># The node mapping is not re-checked because it doesn&#39;t much</span>
        <span class="c1"># matter if things happened to re-balance.</span>
        <span class="c1">#</span>
        <span class="c1"># This is inefficient and racey. We end up with calling DB API&#39;s</span>
        <span class="c1"># get_node() twice (once here, and once in acquire(). Ideally we</span>
        <span class="c1"># add a way to pass constraints to task_manager.acquire()</span>
        <span class="c1"># (through to its DB API call) so that we can eliminate our call</span>
        <span class="c1"># and first set of checks below.</span>

        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;maintenance&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>
        <span class="n">node_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">node_uuid</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">node_iter</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># NOTE(dtantsur): start with a shared lock, upgrade if needed</span>
                <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_uuid</span><span class="p">,</span>
                                          <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;power state sync&#39;</span><span class="p">,</span>
                                          <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
                    <span class="c1"># NOTE(deva): we should not acquire a lock on a node in</span>
                    <span class="c1">#             DEPLOYWAIT/CLEANWAIT, as this could cause</span>
                    <span class="c1">#             an error within a deploy ramdisk POSTing back</span>
                    <span class="c1">#             at the same time.</span>
                    <span class="c1"># NOTE(dtantsur): it&#39;s also pointless (and dangerous) to</span>
                    <span class="c1"># sync power state when a power action is in progress</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">in</span> <span class="n">SYNC_EXCLUDED_STATES</span> <span class="ow">or</span>
                            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">maintenance</span> <span class="ow">or</span>
                            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">target_power_state</span> <span class="ow">or</span>
                            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">reservation</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">do_sync_power_state</span><span class="p">(</span>
                        <span class="n">task</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_state_sync_count</span><span class="p">[</span><span class="n">node_uuid</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">power_state_sync_count</span><span class="p">[</span><span class="n">node_uuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># don&#39;t bloat the dict with non-failing nodes</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_state_sync_count</span><span class="p">[</span><span class="n">node_uuid</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, node </span><span class="si">%(node)s</span><span class="s2"> was not &quot;</span>
                             <span class="s2">&quot;found and presumed deleted by another process.&quot;</span><span class="p">),</span>
                         <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">})</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, node </span><span class="si">%(node)s</span><span class="s2"> was &quot;</span>
                             <span class="s2">&quot;already locked by another process. Skip.&quot;</span><span class="p">),</span>
                         <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">})</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Yield on every iteration</span>
                <span class="n">eventlet</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._check_deploy_timeouts&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">check_provision_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_check_deploy_timeouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodically checks whether a deploy RPC call has timed out.</span>

<span class="sd">        If a deploy call has timed out, the deploy failed and we clean up.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback_timeout</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">deploy_callback_timeout</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback_timeout</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reserved&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provision_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYWAIT</span><span class="p">,</span>
                   <span class="s1">&#39;maintenance&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provisioned_before&#39;</span><span class="p">:</span> <span class="n">callback_timeout</span><span class="p">}</span>
        <span class="n">sort_key</span> <span class="o">=</span> <span class="s1">&#39;provision_updated_at&#39;</span>
        <span class="n">callback_method</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">cleanup_after_timeout</span>
        <span class="n">err_handler</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fail_if_in_state</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYWAIT</span><span class="p">,</span>
                               <span class="n">sort_key</span><span class="p">,</span> <span class="n">callback_method</span><span class="p">,</span> <span class="n">err_handler</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._check_deploying_status&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">check_provision_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_check_deploying_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodically checks the status of nodes in DEPLOYING state.</span>

<span class="sd">        Periodically checks the nodes in DEPLOYING and the state of the</span>
<span class="sd">        conductor deploying them. If we find out that a conductor that</span>
<span class="sd">        was provisioning the node has died we then break release the</span>
<span class="sd">        node and gracefully mark the deployment as failed.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offline_conductors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">get_offline_conductors</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offline_conductors</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">node_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span>
            <span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;reservation&#39;</span><span class="p">],</span>
            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;provision_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYING</span><span class="p">,</span>
                     <span class="s1">&#39;maintenance&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                     <span class="s1">&#39;reserved_by_any_of&#39;</span><span class="p">:</span> <span class="n">offline_conductors</span><span class="p">})</span>

        <span class="k">for</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">conductor_hostname</span> <span class="ow">in</span> <span class="n">node_iter</span><span class="p">:</span>
            <span class="c1"># NOTE(lucasagomes): Although very rare, this may lead to a</span>
            <span class="c1"># race condition. By the time we release the lock the conductor</span>
            <span class="c1"># that was previously managing the node could be back online.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">objects</span><span class="o">.</span><span class="n">Node</span><span class="o">.</span><span class="n">release</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">conductor_hostname</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During checking for deploying state, node &quot;</span>
                                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> was not found and presumed deleted by &quot;</span>
                                <span class="s2">&quot;another process. Skipping.&quot;</span><span class="p">),</span> <span class="n">node_uuid</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During checking for deploying state, when &quot;</span>
                                <span class="s2">&quot;releasing the lock of the node </span><span class="si">%s</span><span class="s2">, it was &quot;</span>
                                <span class="s2">&quot;locked by another process. Skipping.&quot;</span><span class="p">),</span>
                            <span class="n">node_uuid</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotLocked</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During checking for deploying state, when &quot;</span>
                                <span class="s2">&quot;releasing the lock of the node </span><span class="si">%s</span><span class="s2">, it was &quot;</span>
                                <span class="s2">&quot;already unlocked.&quot;</span><span class="p">),</span> <span class="n">node_uuid</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fail_if_in_state</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">},</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYING</span><span class="p">,</span>
                <span class="s1">&#39;provision_updated_at&#39;</span><span class="p">,</span>
                <span class="n">callback_method</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">cleanup_after_timeout</span><span class="p">,</span>
                <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._do_adoption&#39;</span><span class="p">)</span>
    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_do_adoption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adopt the node.</span>

<span class="sd">        Similar to node takeover, adoption performs a driver boot</span>
<span class="sd">        validation and then triggers node takeover in order to make the</span>
<span class="sd">        conductor responsible for the node. Upon completion of takeover,</span>
<span class="sd">        the node is moved to ACTIVE state.</span>

<span class="sd">        The goal of this method is to set the conditions for the node to</span>
<span class="sd">        be managed by Ironic as an ACTIVE node without having performed</span>
<span class="sd">        a deployment operation.</span>

<span class="sd">        :param task: a TaskManager instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Conductor </span><span class="si">%(cdr)s</span><span class="s1"> attempting to adopt node </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;cdr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># NOTE(TheJulia): A number of drivers expect to know if a</span>
            <span class="c1"># whole disk image was used prior to their takeover logic</span>
            <span class="c1"># being triggered, as such we need to populate the</span>
            <span class="c1"># internal info based on the configuration the user has</span>
            <span class="c1"># supplied.</span>
            <span class="n">iwdi</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">is_whole_disk_image</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                                              <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">instance_info</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;is_whole_disk_image&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iwdi</span>
            <span class="c1"># Calling boot validate to ensure that sufficient information</span>
            <span class="c1"># is supplied to allow the node to be able to boot if takeover</span>
            <span class="c1"># writes items such as kernel/ramdisk data to disk.</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">boot</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="c1"># NOTE(TheJulia): While task.driver.boot.validate() is called</span>
            <span class="c1"># above, and task.driver.power.validate() could be called, it</span>
            <span class="c1"># is called as part of the transition from ENROLL to MANAGEABLE</span>
            <span class="c1"># states. As such it is redundant to call here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_takeover</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;Successfully adopted node </span><span class="si">%(node)s</span><span class="s2">&quot;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Error while attempting to adopt node </span><span class="si">%(node)s</span><span class="s1">: &#39;</span>
                     <span class="s1">&#39;</span><span class="si">%(err)s</span><span class="s1">.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">err</span><span class="p">})</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._do_takeover&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_do_takeover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take over this node.</span>

<span class="sd">        Prepares a node for takeover by this conductor, performs the takeover,</span>
<span class="sd">        and changes the conductor associated with the node. The node with the</span>
<span class="sd">        new conductor affiliation is saved to the DB.</span>

<span class="sd">        :param task: a TaskManager instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">((</span><span class="s1">&#39;Conductor </span><span class="si">%(cdr)s</span><span class="s1"> taking over node </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                  <span class="p">{</span><span class="s1">&#39;cdr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
        <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">take_over</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="c1"># NOTE(zhenguo): If console enabled, take over the console session</span>
        <span class="c1"># as well.</span>
        <span class="n">console_error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span><span class="p">:</span>
            <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_restore&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">START</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">start_console</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to start console while taking over the &#39;</span>
                         <span class="s1">&#39;node </span><span class="si">%(node)s</span><span class="s1">: </span><span class="si">%(err)s</span><span class="s1">.&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                                       <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">err</span><span class="p">})</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1"># If taking over console failed, set node&#39;s console_enabled</span>
                <span class="c1"># back to False and set node&#39;s last error.</span>
                <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">msg</span>
                <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">console_error</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                    <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_restore&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">END</span><span class="p">)</span>
        <span class="c1"># NOTE(lucasagomes): Set the ID of the new conductor managing</span>
        <span class="c1">#                    this node</span>
        <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">conductor_affinity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">id</span>
        <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">console_error</span><span class="p">:</span>
            <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_restore&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._check_cleanwait_timeouts&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">check_provision_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_check_cleanwait_timeouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodically checks for nodes being cleaned.</span>

<span class="sd">        If a node doing cleaning is unresponsive (detected when it stops</span>
<span class="sd">        heart beating), the operation should be aborted.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback_timeout</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">clean_callback_timeout</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback_timeout</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reserved&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provision_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">,</span>
                   <span class="s1">&#39;maintenance&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provisioned_before&#39;</span><span class="p">:</span> <span class="n">callback_timeout</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fail_if_in_state</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">CLEANWAIT</span><span class="p">,</span>
                               <span class="s1">&#39;provision_updated_at&#39;</span><span class="p">,</span>
                               <span class="n">keep_target_state</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">callback_method</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">cleanup_cleanwait_timeout</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._sync_local_state&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">sync_local_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_sync_local_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform any actions necessary to sync local state.</span>

<span class="sd">        This is called periodically to refresh the conductor&#39;s copy of the</span>
<span class="sd">        consistent hash ring. If any mappings have changed, this method then</span>
<span class="sd">        determines which, if any, nodes need to be &quot;taken over&quot;.</span>
<span class="sd">        The ensuing actions could include preparing a PXE environment,</span>
<span class="sd">        updating the DHCP server, and so on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reserved&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;maintenance&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provision_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">}</span>
        <span class="n">node_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;conductor_affinity&#39;</span><span class="p">],</span>
                                    <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">)</span>

        <span class="n">workers_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">conductor_affinity</span> <span class="ow">in</span> <span class="n">node_iter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conductor_affinity</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Node is mapped here, but not updated by this conductor last</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_uuid</span><span class="p">,</span>
                                          <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node take over&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
                    <span class="c1"># NOTE(deva): now that we have the lock, check again to</span>
                    <span class="c1"># avoid racing with deletes and other state changes</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">maintenance</span> <span class="ow">or</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">conductor_affinity</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">id</span> <span class="ow">or</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">!=</span> <span class="n">states</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_do_takeover</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">workers_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">workers_count</span> <span class="o">==</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">periodic_max_workers</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.validate_driver_interfaces&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">validate_driver_interfaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate the `core` and `standardized` interfaces for drivers.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :returns: a dictionary containing the results of each</span>
<span class="sd">                  interface validation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC validate_driver_interfaces called for node </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span>
                  <span class="n">node_id</span><span class="p">)</span>
        <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;driver interface validation&#39;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="c1"># NOTE(sirushtim): the is_whole_disk_image variable is needed by</span>
            <span class="c1"># deploy drivers for doing their validate(). Since the deploy</span>
            <span class="c1"># isn&#39;t being done yet and the driver information could change in</span>
            <span class="c1"># the meantime, we don&#39;t know if the is_whole_disk_image value will</span>
            <span class="c1"># change or not. It isn&#39;t saved to the DB, but only used with this</span>
            <span class="c1"># node instance for the current validations.</span>
            <span class="n">iwdi</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">is_whole_disk_image</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
                                              <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">instance_info</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver_internal_info</span><span class="p">[</span><span class="s1">&#39;is_whole_disk_image&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iwdi</span>
            <span class="k">for</span> <span class="n">iface_name</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">non_vendor_interfaces</span><span class="p">:</span>
                <span class="n">iface</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">iface_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">iface</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">iface</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">except</span> <span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                            <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">reason</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">reason</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Unexpected exception, traceback saved &#39;</span>
                                    <span class="s1">&#39;into log by ironic conductor service &#39;</span>
                                    <span class="s1">&#39;that is running on </span><span class="si">%(host)s</span><span class="s1">: </span><span class="si">%(error)s</span><span class="s1">&#39;</span><span class="p">)</span>
                                  <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
                        <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span>
                            <span class="s1">&#39;Unexpected exception occurred while validating &#39;</span>
                            <span class="s1">&#39;</span><span class="si">%(iface)s</span><span class="s1"> driver interface for driver &#39;</span>
                            <span class="s1">&#39;</span><span class="si">%(driver)s</span><span class="s1">: </span><span class="si">%(err)s</span><span class="s1"> on node </span><span class="si">%(node)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                            <span class="p">{</span><span class="s1">&#39;iface&#39;</span><span class="p">:</span> <span class="n">iface_name</span><span class="p">,</span> <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                             <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reason</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;not supported&#39;</span><span class="p">)</span>

                <span class="n">ret_dict</span><span class="p">[</span><span class="n">iface_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">ret_dict</span><span class="p">[</span><span class="n">iface_name</span><span class="p">][</span><span class="s1">&#39;result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">if</span> <span class="n">reason</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">ret_dict</span><span class="p">[</span><span class="n">iface_name</span><span class="p">][</span><span class="s1">&#39;reason&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reason</span>
        <span class="k">return</span> <span class="n">ret_dict</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.destroy_node&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeAssociated</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">destroy_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a node.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: NodeAssociated if the node contains an instance</span>
<span class="sd">            associated with it.</span>
<span class="sd">        :raises: InvalidState if the node is in the wrong provision</span>
<span class="sd">            state to perform deletion.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE(dtantsur): we allow deleting a node in maintenance mode even if</span>
        <span class="c1"># we would disallow it otherwise. That&#39;s done for recovering hopelessly</span>
        <span class="c1"># broken nodes (e.g. with broken BMC).</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;node deletion&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeAssociated</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                               <span class="n">instance</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">)</span>

            <span class="c1"># NOTE(lucasagomes): For the *FAIL states we users should</span>
            <span class="c1"># move it to a safe state prior to deletion. This is because we</span>
            <span class="c1"># should try to avoid deleting a node in a dirty/whacky state,</span>
            <span class="c1"># e.g: A node in DEPLOYFAIL, if deleted without passing through</span>
            <span class="c1"># tear down/cleaning may leave data from the previous tenant</span>
            <span class="c1"># in the disk. So nodes in *FAIL states should first be moved to:</span>
            <span class="c1"># CLEANFAIL -&gt; MANAGEABLE</span>
            <span class="c1"># INSPECTIONFAIL -&gt; MANAGEABLE</span>
            <span class="c1"># DEPLOYFAIL -&gt; DELETING</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span> <span class="ow">and</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">states</span><span class="o">.</span><span class="n">DELETE_ALLOWED_STATES</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Can not delete node &quot;</span><span class="si">%(node)s</span><span class="s1">&quot; while it is in &#39;</span>
                         <span class="s1">&#39;provision state &quot;</span><span class="si">%(state)s</span><span class="s1">&quot;. Valid provision states &#39;</span>
                         <span class="s1">&#39;to perform deletion are: &quot;</span><span class="si">%(valid_states)s</span><span class="s1">&quot;&#39;</span><span class="p">)</span> <span class="o">%</span>
                       <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">,</span>
                        <span class="s1">&#39;valid_states&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">DELETE_ALLOWED_STATES</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span><span class="p">:</span>
                <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                    <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">START</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">stop_console</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Failed to stop console while deleting &#39;</span>
                                  <span class="s1">&#39;the node </span><span class="si">%(node)s</span><span class="s1">: </span><span class="si">%(err)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                              <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">err</span><span class="p">})</span>
                    <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                        <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                        <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">END</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deleted node </span><span class="si">%(node)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.destroy_port&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">destroy_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a port.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param port: port object</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the port does not</span>
<span class="sd">                 exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC destroy_port called for port </span><span class="si">%(port)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="n">port</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">port</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;port deletion&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">port</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deleted port </span><span class="si">%(port)s</span><span class="s1">. &#39;</span>
                         <span class="s1">&#39;The node associated with the port was &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="n">port</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.destroy_portgroup&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">PortgroupNotEmpty</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">destroy_portgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">portgroup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a portgroup.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param portgroup: portgroup object</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the portgroup does</span>
<span class="sd">                 not exist.</span>
<span class="sd">        :raises: PortgroupNotEmpty if portgroup is not empty</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC destroy_portgroup called for portgroup </span><span class="si">%(portgroup)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;portgroup&#39;</span><span class="p">:</span> <span class="n">portgroup</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">portgroup</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;portgroup deletion&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">portgroup</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deleted portgroup </span><span class="si">%(portgroup)s</span><span class="s1">. &#39;</span>
                         <span class="s1">&#39;The node associated with the portgroup was &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;portgroup&#39;</span><span class="p">:</span> <span class="n">portgroup</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.destroy_volume_connector&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">VolumeConnectorNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">destroy_volume_connector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a volume connector.</span>

<span class="sd">        :param context: request context</span>
<span class="sd">        :param connector: volume connector object</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the connector does</span>
<span class="sd">                 not exist</span>
<span class="sd">        :raises: VolumeConnectorNotFound if the volume connector cannot be</span>
<span class="sd">                 found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC destroy_volume_connector called for volume connector &#39;</span>
                  <span class="s1">&#39;</span><span class="si">%(connector)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;connector&#39;</span><span class="p">:</span> <span class="n">connector</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">connector</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;volume connector deletion&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deleted volume connector &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(connector)s</span><span class="s1">. &#39;</span>
                         <span class="s1">&#39;The node associated with the connector was &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;connector&#39;</span><span class="p">:</span> <span class="n">connector</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.destroy_volume_target&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">VolumeTargetNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">destroy_volume_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a volume target.</span>

<span class="sd">        :param context: request context</span>
<span class="sd">        :param target: volume target object</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the target does</span>
<span class="sd">                 not exist</span>
<span class="sd">        :raises: VolumeTargetNotFound if the volume target cannot be found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC destroy_volume_target called for volume target &#39;</span>
                  <span class="s1">&#39;</span><span class="si">%(target)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;volume target deletion&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deleted volume target </span><span class="si">%(target)s</span><span class="s1">. &#39;</span>
                         <span class="s1">&#39;The node associated with the target was </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_console_information&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeConsoleNotEnabled</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_console_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get connection information about the console.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support console.</span>
<span class="sd">        :raises: NodeConsoleNotEnabled if the console is not enabled.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC get_console_information called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;getting console information&#39;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;console&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span><span class="n">driver</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                                                           <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;console&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeConsoleNotEnabled</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">get_console</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.set_console_mode&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_console_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable/Disable the console.</span>

<span class="sd">        Validate driver specific information synchronously, and then</span>
<span class="sd">        spawn a background worker to set console mode asynchronously.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :param enabled: Boolean value; whether the console is enabled or</span>
<span class="sd">                        disabled.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support console.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC set_console_mode called for node </span><span class="si">%(node)s</span><span class="s1"> with &#39;</span>
                  <span class="s1">&#39;enabled </span><span class="si">%(enabled)s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span> <span class="s1">&#39;enabled&#39;</span><span class="p">:</span> <span class="n">enabled</span><span class="p">})</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;setting console mode&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;console&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span><span class="n">driver</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span>
                                                           <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;console&#39;</span><span class="p">)</span>

            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">enabled</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;disabled&#39;</span><span class="p">)</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;No console action was triggered because the &quot;</span>
                             <span class="s2">&quot;console is already </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">),</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
                <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_set_console_mode</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">enabled</span><span class="p">)</span>

    <span class="nd">@task_manager.require_exclusive_lock</span>
    <span class="k">def</span> <span class="nf">_set_console_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">enabled</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal method to set console mode on a node.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
        <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
            <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">START</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">enabled</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">start_console</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="c1"># TODO(deva): We should be updating conductor_affinity here</span>
                <span class="c1"># but there is no support for console sessions in</span>
                <span class="c1"># take_over() right now.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">console</span><span class="o">.</span><span class="n">stop_console</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;enabling&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="n">_</span><span class="p">(</span><span class="s1">&#39;disabling&#39;</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Error </span><span class="si">%(op)s</span><span class="s1"> the console on node </span><span class="si">%(node)s</span><span class="s1">. &#39;</span>
                     <span class="s1">&#39;Reason: </span><span class="si">%(error)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="n">op</span><span class="p">,</span>
                                             <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                             <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
            <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">console_enabled</span> <span class="o">=</span> <span class="n">enabled</span>
            <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_console_notification</span><span class="p">(</span>
                <span class="n">task</span><span class="p">,</span> <span class="s1">&#39;console_set&#39;</span><span class="p">,</span> <span class="n">fields</span><span class="o">.</span><span class="n">NotificationStatus</span><span class="o">.</span><span class="n">END</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.update_port&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">FailedToUpdateMacOnPort</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">MACAlreadyExists</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">FailedToUpdateDHCPOptOnPort</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">Conflict</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NetworkError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">port_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a port.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param port_obj: a changed (but not saved) port object.</span>
<span class="sd">        :raises: DHCPLoadError if the dhcp_provider cannot be loaded.</span>
<span class="sd">        :raises: FailedToUpdateMacOnPort if MAC address changed and update</span>
<span class="sd">                 failed.</span>
<span class="sd">        :raises: MACAlreadyExists if the update is setting a MAC which is</span>
<span class="sd">                 registered on another port already.</span>
<span class="sd">        :raises: InvalidState if port connectivity attributes</span>
<span class="sd">                 are updated while node not in a MANAGEABLE or ENROLL or</span>
<span class="sd">                 INSPECTING state or not in MAINTENANCE mode.</span>
<span class="sd">        :raises: Conflict if trying to set extra/vif_port_id or</span>
<span class="sd">                 pxe_enabled=True on port which is a member of portgroup with</span>
<span class="sd">                 standalone_ports_supported=False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">port_uuid</span> <span class="o">=</span> <span class="n">port_obj</span><span class="o">.</span><span class="n">uuid</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC update_port called for port </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">port_uuid</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">port_obj</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;port update&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="c1"># Only allow updating MAC addresses for active nodes if maintenance</span>
            <span class="c1"># mode is on.</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">ACTIVE</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">)</span>
                <span class="ow">and</span> <span class="s1">&#39;address&#39;</span> <span class="ow">in</span> <span class="n">port_obj</span><span class="o">.</span><span class="n">obj_what_changed</span><span class="p">()</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">):</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Cannot update hardware address for port &quot;</span>
                               <span class="s2">&quot;</span><span class="si">%(port)s</span><span class="s2"> as node </span><span class="si">%(node)s</span><span class="s2"> is active or has &quot;</span>
                               <span class="s2">&quot;instance UUID assigned&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">(</span><span class="n">action</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                                           <span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="n">port_uuid</span><span class="p">})</span>

            <span class="c1"># If port update is modifying the portgroup membership of the port</span>
            <span class="c1"># or modifying the local_link_connection or pxe_enabled flags then</span>
            <span class="c1"># node should be in MANAGEABLE/INSPECTING/ENROLL provisioning state</span>
            <span class="c1"># or in maintenance mode.</span>
            <span class="c1"># Otherwise InvalidState exception is raised.</span>
            <span class="n">connectivity_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;portgroup_id&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;pxe_enabled&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;local_link_connection&#39;</span><span class="p">}</span>
            <span class="n">allowed_update_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">states</span><span class="o">.</span><span class="n">ENROLL</span><span class="p">,</span>
                                     <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">,</span>
                                     <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">port_obj</span><span class="o">.</span><span class="n">obj_what_changed</span><span class="p">())</span> <span class="o">&amp;</span> <span class="n">connectivity_attr</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">in</span> <span class="n">allowed_update_states</span>
                             <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">)):</span>
                <span class="n">action</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Port </span><span class="si">%(port)s</span><span class="s2"> can not have any connectivity &quot;</span>
                           <span class="s2">&quot;attributes (</span><span class="si">%(connect)s</span><span class="s2">) updated unless &quot;</span>
                           <span class="s2">&quot;node </span><span class="si">%(node)s</span><span class="s2"> is in a </span><span class="si">%(allowed)s</span><span class="s2"> state &quot;</span>
                           <span class="s2">&quot;or in maintenance mode.&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">(</span>
                    <span class="n">action</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="n">port_uuid</span><span class="p">,</span>
                              <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                              <span class="s1">&#39;connect&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">connectivity_attr</span><span class="p">),</span>
                              <span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_update_states</span><span class="p">)})</span>

            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="c1"># Handle mac_address update and VIF attach/detach stuff.</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">port_changed</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">port_obj</span><span class="p">)</span>

            <span class="n">port_obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">port_obj</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.update_portgroup&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">FailedToUpdateMacOnPort</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">PortgroupMACAlreadyExists</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">PortgroupNotEmpty</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">Conflict</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NetworkError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_portgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">portgroup_obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a portgroup.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param portgroup_obj: a changed (but not saved) portgroup object.</span>
<span class="sd">        :raises: DHCPLoadError if the dhcp_provider cannot be loaded.</span>
<span class="sd">        :raises: FailedToUpdateMacOnPort if MAC address changed and update</span>
<span class="sd">                 failed.</span>
<span class="sd">        :raises: PortgroupMACAlreadyExists if the update is setting a MAC which</span>
<span class="sd">                 is registered on another portgroup already.</span>
<span class="sd">        :raises: InvalidState if portgroup-node association is updated while</span>
<span class="sd">                 node not in a MANAGEABLE or ENROLL or INSPECTING state or not</span>
<span class="sd">                 in MAINTENANCE mode.</span>
<span class="sd">        :raises: PortgroupNotEmpty if there are ports associated with this</span>
<span class="sd">                 portgroup.</span>
<span class="sd">        :raises: Conflict when trying to set standalone_ports_supported=False</span>
<span class="sd">                 on portgroup with ports that has pxe_enabled=True and vice</span>
<span class="sd">                 versa.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">portgroup_uuid</span> <span class="o">=</span> <span class="n">portgroup_obj</span><span class="o">.</span><span class="n">uuid</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC update_portgroup called for portgroup </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="n">portgroup_uuid</span><span class="p">)</span>
        <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;update portgroup&#39;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
                                  <span class="n">portgroup_obj</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

            <span class="k">if</span> <span class="s1">&#39;node_id&#39;</span> <span class="ow">in</span> <span class="n">portgroup_obj</span><span class="o">.</span><span class="n">obj_what_changed</span><span class="p">():</span>
                <span class="c1"># NOTE(zhenguo): If portgroup update is modifying the</span>
                <span class="c1"># portgroup-node association then node should be in</span>
                <span class="c1"># MANAGEABLE/INSPECTING/ENROLL provisioning state or in</span>
                <span class="c1"># maintenance mode, otherwise InvalidState is raised.</span>
                <span class="n">allowed_update_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">states</span><span class="o">.</span><span class="n">ENROLL</span><span class="p">,</span>
                                         <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">,</span>
                                         <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_update_states</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">):</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Portgroup </span><span class="si">%(portgroup)s</span><span class="s2"> can not be associated &quot;</span>
                               <span class="s2">&quot;to node </span><span class="si">%(node)s</span><span class="s2"> unless the node is in a &quot;</span>
                               <span class="s2">&quot;</span><span class="si">%(allowed)s</span><span class="s2"> state or in maintenance mode.&quot;</span><span class="p">)</span>

                    <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">(</span>
                        <span class="n">action</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;portgroup&#39;</span><span class="p">:</span> <span class="n">portgroup_uuid</span><span class="p">,</span>
                                  <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                                  <span class="s1">&#39;allowed&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_update_states</span><span class="p">)})</span>

                <span class="c1"># NOTE(zhenguo): If portgroup update is modifying the</span>
                <span class="c1"># portgroup-node association then there should not be</span>
                <span class="c1"># any Port associated to the PortGroup, otherwise</span>
                <span class="c1"># PortgroupNotEmpty exception is raised.</span>
                <span class="n">associated_ports</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dbapi</span><span class="o">.</span><span class="n">get_ports_by_portgroup_id</span><span class="p">(</span>
                    <span class="n">portgroup_uuid</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">associated_ports</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Portgroup </span><span class="si">%(portgroup)s</span><span class="s2"> can not be associated &quot;</span>
                               <span class="s2">&quot;with node </span><span class="si">%(node)s</span><span class="s2"> because there are ports &quot;</span>
                               <span class="s2">&quot;associated with this portgroup.&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">PortgroupNotEmpty</span><span class="p">(</span>
                        <span class="n">action</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;portgroup&#39;</span><span class="p">:</span> <span class="n">portgroup_uuid</span><span class="p">,</span>
                                  <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="c1"># Handle mac_address update and VIF attach/detach stuff.</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">portgroup_changed</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">portgroup_obj</span><span class="p">)</span>

            <span class="n">portgroup_obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">portgroup_obj</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.update_volume_connector&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">VolumeConnectorNotFound</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">VolumeConnectorTypeAndIdAlreadyExists</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_volume_connector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a volume connector.</span>

<span class="sd">        :param context: request context</span>
<span class="sd">        :param connector: a changed (but not saved) volume connector object</span>
<span class="sd">        :returns: an updated volume connector object</span>
<span class="sd">        :raises: InvalidParameterValue if the volume connector&#39;s UUID is being</span>
<span class="sd">                 changed</span>
<span class="sd">        :raises: NodeLocked if the node is already locked</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the conductor does</span>
<span class="sd">                 not exist</span>
<span class="sd">        :raises: VolumeConnectorNotFound if the volume connector cannot be</span>
<span class="sd">                 found</span>
<span class="sd">        :raises: VolumeConnectorTypeAndIdAlreadyExists if another connector</span>
<span class="sd">                 already exists with the same values for type and connector_id</span>
<span class="sd">                 fields</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC update_volume_connector called for connector &quot;</span>
                  <span class="s2">&quot;</span><span class="si">%(connector)s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;connector&#39;</span><span class="p">:</span> <span class="n">connector</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">connector</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;volume connector update&#39;</span><span class="p">):</span>
            <span class="n">connector</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;Successfully updated volume connector &quot;</span>
                         <span class="s2">&quot;</span><span class="si">%(connector)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;connector&#39;</span><span class="p">:</span> <span class="n">connector</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">connector</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.update_volume_target&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">VolumeTargetNotFound</span><span class="p">,</span>
        <span class="n">exception</span><span class="o">.</span><span class="n">VolumeTargetBootIndexAlreadyExists</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_volume_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update a volume target.</span>

<span class="sd">        :param context: request context</span>
<span class="sd">        :param target: a changed (but not saved) volume target object</span>
<span class="sd">        :returns: an updated volume target object</span>
<span class="sd">        :raises: InvalidParameterValue if the volume target&#39;s UUID is being</span>
<span class="sd">                 changed</span>
<span class="sd">        :raises: NodeLocked if the node is already locked</span>
<span class="sd">        :raises: NodeNotFound if the node associated with the volume target</span>
<span class="sd">                 does not exist</span>
<span class="sd">        :raises: VolumeTargetNotFound if the volume target cannot be found</span>
<span class="sd">        :raises: VolumeTargetBootIndexAlreadyExists if a volume target already</span>
<span class="sd">                 exists with the same node ID and boot index values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC update_volume_target called for target </span><span class="si">%(target)s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;volume target update&#39;</span><span class="p">):</span>
            <span class="n">target</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;Successfully updated volume target </span><span class="si">%(target)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">target</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_driver_properties&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">DriverNotFound</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_driver_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the properties of the driver.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param driver_name: name of the driver.</span>
<span class="sd">        :returns: a dictionary with &lt;property name&gt;:&lt;property description&gt;</span>
<span class="sd">                  entries.</span>
<span class="sd">        :raises: DriverNotFound if the driver is not loaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC get_driver_properties called for driver </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="n">driver_name</span><span class="p">)</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_driver_or_hardware_type</span><span class="p">(</span><span class="n">driver_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">driver</span><span class="o">.</span><span class="n">get_properties</span><span class="p">()</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._sensors_nodes_task&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_sensors_nodes_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sends sensors data for nodes from synchronized queue.&quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node_uuid</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">instance_uuid</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">queue</span><span class="o">.</span><span class="n">Empty</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># populate the message which will be sent to ceilometer</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;message_id&#39;</span><span class="p">:</span> <span class="n">uuidutils</span><span class="o">.</span><span class="n">generate_uuid</span><span class="p">(),</span>
                       <span class="s1">&#39;instance_uuid&#39;</span><span class="p">:</span> <span class="n">instance_uuid</span><span class="p">,</span>
                       <span class="s1">&#39;node_uuid&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">,</span>
                       <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">(),</span>
                       <span class="s1">&#39;event_type&#39;</span><span class="p">:</span> <span class="s1">&#39;hardware.ipmi.metrics.update&#39;</span><span class="p">}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;getting sensors data&#39;</span>
                <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>
                                          <span class="n">node_uuid</span><span class="p">,</span>
                                          <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                          <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;management&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                    <span class="n">sensors_data</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">get_sensors_data</span><span class="p">(</span>
                        <span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span>
                    <span class="s1">&#39;get_sensors_data is not implemented for driver&#39;</span>
                    <span class="s1">&#39; </span><span class="si">%(driver)s</span><span class="s1">, node_uuid is </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="n">driver</span><span class="p">})</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">FailedToParseSensorData</span> <span class="k">as</span> <span class="n">fps</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span>
                    <span class="s2">&quot;During get_sensors_data, could not parse &quot;</span>
                    <span class="s2">&quot;sensor data for node </span><span class="si">%(node)s</span><span class="s2">. Error: </span><span class="si">%(err)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">fps</span><span class="p">)})</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">FailedToGetSensorData</span> <span class="k">as</span> <span class="n">fgs</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span>
                    <span class="s2">&quot;During get_sensors_data, could not get &quot;</span>
                    <span class="s2">&quot;sensor data for node </span><span class="si">%(node)s</span><span class="s2">. Error: </span><span class="si">%(err)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">fgs</span><span class="p">)})</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span>
                    <span class="s2">&quot;During send_sensor_data, node </span><span class="si">%(node)s</span><span class="s2"> was not &quot;</span>
                    <span class="s2">&quot;found and presumed deleted by another process.&quot;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span>
                    <span class="s2">&quot;Failed to get sensor data for node </span><span class="si">%(node)s</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;Error: </span><span class="si">%(error)s</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_uuid</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span><span class="p">[</span><span class="s1">&#39;payload&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_filter_out_unsupported_types</span><span class="p">(</span><span class="n">sensors_data</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">message</span><span class="p">[</span><span class="s1">&#39;payload&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sensors_notifier</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;hardware.ipmi.metrics&quot;</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Yield on every iteration</span>
                <span class="n">eventlet</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._send_sensor_data&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">send_sensor_data_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_send_sensor_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodically sends sensor data to Ceilometer.&quot;&quot;&quot;</span>

        <span class="c1"># do nothing if send_sensor_data option is False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">send_sensor_data</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;associated&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nodes</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;instance_uuid&#39;</span><span class="p">],</span>
                                         <span class="n">filters</span><span class="o">=</span><span class="n">filters</span><span class="p">):</span>
            <span class="n">nodes</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">node_info</span><span class="p">)</span>

        <span class="n">number_of_threads</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">send_sensor_data_workers</span><span class="p">,</span>
                                <span class="n">nodes</span><span class="o">.</span><span class="n">qsize</span><span class="p">())</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">thread_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_threads</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sensors_nodes_task</span><span class="p">,</span>
                                       <span class="n">context</span><span class="p">,</span> <span class="n">nodes</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;There is no more conductor workers for &quot;</span>
                                <span class="s2">&quot;task of sending sensors data. </span><span class="si">%(workers)d</span><span class="s2"> &quot;</span>
                                <span class="s2">&quot;workers has been already spawned.&quot;</span><span class="p">),</span>
                            <span class="p">{</span><span class="s1">&#39;workers&#39;</span><span class="p">:</span> <span class="n">thread_number</span><span class="p">})</span>
                <span class="k">break</span>

        <span class="n">done</span><span class="p">,</span> <span class="n">not_done</span> <span class="o">=</span> <span class="n">waiters</span><span class="o">.</span><span class="n">wait_for_all</span><span class="p">(</span>
            <span class="n">futures</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">send_sensor_data_wait_timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">not_done</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> workers for send sensors data did not &quot;</span>
                            <span class="s2">&quot;complete&quot;</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_done</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_filter_out_unsupported_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sensors_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Filters out sensor data types that aren&#39;t specified in the config.</span>

<span class="sd">        Removes sensor data types that aren&#39;t specified in</span>
<span class="sd">        CONF.conductor.send_sensor_data_types.</span>

<span class="sd">        :param sensors_data: dict containing sensor types and the associated</span>
<span class="sd">               data</span>
<span class="sd">        :returns: dict with unsupported sensor types removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">send_sensor_data_types</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sensors_data</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">sensor_type</span><span class="p">,</span> <span class="n">sensor_value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">sensor_type</span><span class="p">,</span> <span class="n">sensor_value</span><span class="p">)</span>
                    <span class="ow">in</span> <span class="n">sensors_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">sensor_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.set_boot_device&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_boot_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">persistent</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the boot device for a node.</span>

<span class="sd">        Set the boot device to use on next reboot of the node.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :param device: the boot device, one of</span>
<span class="sd">                       :mod:`ironic.common.boot_devices`.</span>
<span class="sd">        :param persistent: Whether to set next-boot, or make the change</span>
<span class="sd">                           permanent. Default: False.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support management.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is</span>
<span class="sd">                 specified or an invalid boot device is specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC set_boot_device called for node </span><span class="si">%(node)s</span><span class="s1"> with &#39;</span>
                  <span class="s1">&#39;device </span><span class="si">%(device)s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span> <span class="s1">&#39;device&#39;</span><span class="p">:</span> <span class="n">device</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;setting boot device&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;management&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;management&#39;</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">set_boot_device</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span>
                                                   <span class="n">persistent</span><span class="o">=</span><span class="n">persistent</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_boot_device&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_boot_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the current boot device.</span>

<span class="sd">        Returns the current boot device of a node.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support management.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is</span>
<span class="sd">                 specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        :returns: a dictionary containing:</span>

<span class="sd">            :boot_device: the boot device, one of</span>
<span class="sd">                :mod:`ironic.common.boot_devices` or None if it is unknown.</span>
<span class="sd">            :persistent: Whether the boot device will persist to all</span>
<span class="sd">                future boots or not, None if it is unknown.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC get_boot_device called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;getting boot device&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;management&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;management&#39;</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">get_boot_device</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.inject_nmi&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inject_nmi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inject NMI for a node.</span>

<span class="sd">        Inject NMI (Non Maskable Interrupt) for a node immediately.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support management or management.inject_nmi.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is</span>
<span class="sd">                 specified or an invalid boot device is specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC inject_nmi called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;inject nmi&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;management&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;management&#39;</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">inject_nmi</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_supported_boot_devices&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_supported_boot_devices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the list of supported devices.</span>

<span class="sd">        Returns the list of supported boot devices of a node.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support management.</span>
<span class="sd">        :raises: InvalidParameterValue when the wrong driver info is</span>
<span class="sd">                 specified.</span>
<span class="sd">        :raises: MissingParameterValue if missing supplied info.</span>
<span class="sd">        :returns: A list with the supported boot devices defined</span>
<span class="sd">                  in :mod:`ironic.common.boot_devices`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC get_supported_boot_devices called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="n">lock_purpose</span> <span class="o">=</span> <span class="s1">&#39;getting supported boot devices&#39;</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="n">lock_purpose</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;management&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;management&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">management</span><span class="o">.</span><span class="n">get_supported_boot_devices</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.inspect_hardware&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">HardwareInspectionFailure</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">inspect_hardware</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inspect hardware to obtain hardware properties.</span>

<span class="sd">        Initiate the inspection of a node. Validations are done</span>
<span class="sd">        synchronously and the actual inspection work is performed in</span>
<span class="sd">        background (asynchronously).</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        :raises: UnsupportedDriverExtension if the node&#39;s driver doesn&#39;t</span>
<span class="sd">                 support inspect.</span>
<span class="sd">        :raises: NoFreeConductorWorker when there is no free worker to start</span>
<span class="sd">                 async task</span>
<span class="sd">        :raises: HardwareInspectionFailure when unable to get</span>
<span class="sd">                 essential scheduling properties from hardware.</span>
<span class="sd">        :raises: InvalidStateRequested if &#39;inspect&#39; is not a</span>
<span class="sd">                 valid action to do in the current state.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC inspect_hardware called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;hardware inspection&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;inspect&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;inspect&#39;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">inspect</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s2">&quot;Failed to validate inspection or power info. &quot;</span>
                           <span class="s2">&quot;Error: </span><span class="si">%(msg)s</span><span class="s2">&quot;</span><span class="p">)</span>
                         <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">HardwareInspectionFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span>
                    <span class="s1">&#39;inspect&#39;</span><span class="p">,</span>
                    <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span>
                    <span class="n">call_args</span><span class="o">=</span><span class="p">(</span><span class="n">_do_inspect_hardware</span><span class="p">,</span> <span class="n">task</span><span class="p">),</span>
                    <span class="n">err_handler</span><span class="o">=</span><span class="n">utils</span><span class="o">.</span><span class="n">provisioning_error_handler</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidState</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidStateRequested</span><span class="p">(</span>
                    <span class="n">action</span><span class="o">=</span><span class="s1">&#39;inspect&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="n">state</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">provision_state</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager._check_inspect_timeouts&#39;</span><span class="p">)</span>
    <span class="nd">@periodics.periodic</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">check_provision_state_interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_check_inspect_timeouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Periodically checks inspect_timeout and fails upon reaching it.</span>

<span class="sd">        :param: context: request context</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback_timeout</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">inspect_timeout</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback_timeout</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reserved&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                   <span class="s1">&#39;provision_state&#39;</span><span class="p">:</span> <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">,</span>
                   <span class="s1">&#39;inspection_started_before&#39;</span><span class="p">:</span> <span class="n">callback_timeout</span><span class="p">}</span>
        <span class="n">sort_key</span> <span class="o">=</span> <span class="s1">&#39;inspection_started_at&#39;</span>
        <span class="n">last_error</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;timeout reached while inspecting the node&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fail_if_in_state</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">,</span>
                               <span class="n">sort_key</span><span class="p">,</span> <span class="n">last_error</span><span class="o">=</span><span class="n">last_error</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.set_target_raid_config&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_target_raid_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">target_raid_config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stores the target RAID configuration on the node.</span>

<span class="sd">        Stores the target RAID configuration on node.target_raid_config</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :param target_raid_config: Dictionary containing the target RAID</span>
<span class="sd">            configuration. It may be an empty dictionary as well.</span>
<span class="sd">        :raises: UnsupportedDriverExtension, if the node&#39;s driver doesn&#39;t</span>
<span class="sd">            support RAID configuration.</span>
<span class="sd">        :raises: InvalidParameterValue, if validation of target raid config</span>
<span class="sd">            fails.</span>
<span class="sd">        :raises: MissingParameterValue, if some required parameters are</span>
<span class="sd">            missing.</span>
<span class="sd">        :raises: NodeLocked if node is locked by another conductor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC set_target_raid_config called for node </span><span class="si">%(node)s</span><span class="s1"> with &#39;</span>
                  <span class="s1">&#39;RAID configuration </span><span class="si">%(target_raid_config)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span> <span class="s1">&#39;target_raid_config&#39;</span><span class="p">:</span> <span class="n">target_raid_config</span><span class="p">})</span>

        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span>
                <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;setting target RAID config&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;raid&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">driver</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;raid&#39;</span><span class="p">)</span>
            <span class="c1"># Operator may try to unset node.target_raid_config.  So, try to</span>
            <span class="c1"># validate only if it is not empty.</span>
            <span class="k">if</span> <span class="n">target_raid_config</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">raid</span><span class="o">.</span><span class="n">validate_raid_config</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">target_raid_config</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">target_raid_config</span> <span class="o">=</span> <span class="n">target_raid_config</span>
            <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.get_raid_logical_disk_properties&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoValidDefaultForInterface</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InterfaceNotFoundInEntrypoint</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_raid_logical_disk_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the logical disk properties for RAID configuration.</span>

<span class="sd">        Gets the information about logical disk properties which can</span>
<span class="sd">        be specified in the input RAID configuration. For dynamic drivers,</span>
<span class="sd">        the default vendor interface is used.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param driver_name: name of the driver</span>
<span class="sd">        :raises: UnsupportedDriverExtension, if the driver doesn&#39;t</span>
<span class="sd">            support RAID configuration.</span>
<span class="sd">        :raises: NoValidDefaultForInterface if no default interface</span>
<span class="sd">                 implementation can be found for this driver&#39;s RAID</span>
<span class="sd">                 interface.</span>
<span class="sd">        :raises: InterfaceNotFoundInEntrypoint if the default interface for a</span>
<span class="sd">                 hardware type is invalid.</span>
<span class="sd">        :returns: A dictionary containing the properties and a textual</span>
<span class="sd">            description for them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC get_raid_logical_disk_properties &quot;</span>
                  <span class="s2">&quot;called for driver </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">)</span>

        <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_driver_or_hardware_type</span><span class="p">(</span><span class="n">driver_name</span><span class="p">)</span>
        <span class="n">raid_iface</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">.</span><span class="n">AbstractHardwareType</span><span class="p">):</span>
            <span class="n">raid_iface_name</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">default_interface</span><span class="p">(</span>
                <span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;raid&#39;</span><span class="p">,</span> <span class="n">driver_name</span><span class="o">=</span><span class="n">driver_name</span><span class="p">)</span>
            <span class="n">raid_iface</span> <span class="o">=</span> <span class="n">driver_factory</span><span class="o">.</span><span class="n">get_interface</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;raid&#39;</span><span class="p">,</span>
                                                      <span class="n">raid_iface_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raid_iface</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="s1">&#39;raid&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">raid_iface</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">UnsupportedDriverExtension</span><span class="p">(</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">driver_name</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s1">&#39;raid&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">raid_iface</span><span class="o">.</span><span class="n">get_logical_disk_properties</span><span class="p">()</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.heartbeat&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NoFreeConductorWorker</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">heartbeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">callback_url</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a heartbeat from the ramdisk.</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node id or uuid.</span>
<span class="sd">        :param callback_url: URL to reach back to the ramdisk.</span>
<span class="sd">        :raises: NoFreeConductorWorker if there are no conductors to process</span>
<span class="sd">            this heartbeat request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;RPC heartbeat called for node </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>

        <span class="c1"># NOTE(dtantsur): we acquire a shared lock to begin with, drivers are</span>
        <span class="c1"># free to promote it to an exclusive one.</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;heartbeat&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">spawn_after</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spawn_worker</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">heartbeat</span><span class="p">,</span>
                             <span class="n">task</span><span class="p">,</span> <span class="n">callback_url</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.vif_list&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NetworkError</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vif_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List attached VIFs for a node</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node ID or UUID.</span>
<span class="sd">        :returns: List of VIF dictionaries, each dictionary will have an</span>
<span class="sd">            &#39;id&#39; entry with the ID of the VIF.</span>
<span class="sd">        :raises: NetworkError, if something goes wrong during list the VIFs.</span>
<span class="sd">        :raises: InvalidParameterValue, if a parameter that&#39;s required for</span>
<span class="sd">            VIF list is wrong/missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC vif_list called for the node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node_id</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;list vifs&#39;</span><span class="p">,</span>
                                  <span class="n">shared</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">vif_list</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.vif_attach&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NetworkError</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">VifAlreadyAttached</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NoFreePhysicalPorts</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vif_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">vif_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attach a VIF to a node</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node ID or UUID.</span>
<span class="sd">        :param vif_info: a dictionary representing VIF object.</span>
<span class="sd">             It must have an &#39;id&#39; key, whose value is a unique</span>
<span class="sd">             identifier for that VIF.</span>
<span class="sd">        :raises: VifAlreadyAttached, if VIF is already attached to node</span>
<span class="sd">        :raises: NoFreePhysicalPorts, if no free physical ports left to attach</span>
<span class="sd">        :raises: NodeLocked, if node has an exclusive lock held on it</span>
<span class="sd">        :raises: NetworkError, if an error occurs during attaching the VIF.</span>
<span class="sd">        :raises: InvalidParameterValue, if a parameter that&#39;s required for</span>
<span class="sd">            VIF attach is wrong/missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC vif_attach called for the node </span><span class="si">%(node_id)s</span><span class="s2"> with &quot;</span>
                  <span class="s2">&quot;vif_info </span><span class="si">%(vif_info)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span>
                                            <span class="s1">&#39;vif_info&#39;</span><span class="p">:</span> <span class="n">vif_info</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;attach vif&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">vif_attach</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">vif_info</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;VIF </span><span class="si">%(vif_id)s</span><span class="s2"> successfully attached to node &quot;</span>
                     <span class="s2">&quot;</span><span class="si">%(node_id)s</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;vif_id&#39;</span><span class="p">:</span> <span class="n">vif_info</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                                      <span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">})</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.vif_detach&#39;</span><span class="p">)</span>
    <span class="nd">@messaging.expected_exceptions</span><span class="p">(</span><span class="n">exception</span><span class="o">.</span><span class="n">NodeLocked</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">NetworkError</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">VifNotAttached</span><span class="p">,</span>
                                   <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">vif_detach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">vif_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detach a VIF from a node</span>

<span class="sd">        :param context: request context.</span>
<span class="sd">        :param node_id: node ID or UUID.</span>
<span class="sd">        :param vif_id: A VIF ID.</span>
<span class="sd">        :raises: VifNotAttached, if VIF not attached to node</span>
<span class="sd">        :raises: NodeLocked, if node has an exclusive lock held on it</span>
<span class="sd">        :raises: NetworkError, if an error occurs during detaching the VIF.</span>
<span class="sd">        :raises: InvalidParameterValue, if a parameter that&#39;s required for</span>
<span class="sd">            VIF detach is wrong/missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RPC vif_detach called for the node </span><span class="si">%(node_id)s</span><span class="s2"> with &quot;</span>
                  <span class="s2">&quot;vif_id </span><span class="si">%(vif_id)s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span> <span class="s1">&#39;vif_id&#39;</span><span class="p">:</span> <span class="n">vif_id</span><span class="p">})</span>
        <span class="k">with</span> <span class="n">task_manager</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span>
                                  <span class="n">purpose</span><span class="o">=</span><span class="s1">&#39;detach vif&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">vif_detach</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">vif_id</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;VIF </span><span class="si">%(vif_id)s</span><span class="s2"> successfully detached from node &quot;</span>
                     <span class="s2">&quot;</span><span class="si">%(node_id)s</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;vif_id&#39;</span><span class="p">:</span> <span class="n">vif_id</span><span class="p">,</span>
                                      <span class="s1">&#39;node_id&#39;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_object_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dispatch a call to an object method.</span>

<span class="sd">        This ensures that object methods get called and any exception</span>
<span class="sd">        that is raised gets wrapped in an ExpectedException for forwarding</span>
<span class="sd">        back to the caller (without spamming the conductor logs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># NOTE(danms): Keep the getattr inside the try block since</span>
            <span class="c1"># a missing method is really a client problem</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">context</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># NOTE(danms): This is oslo.messaging fu. ExpectedException()</span>
            <span class="c1"># grabs sys.exc_info here and forwards it along. This allows the</span>
            <span class="c1"># caller to see the exception information, but causes us *not* to</span>
            <span class="c1"># log it as such in this service. This is something that is quite</span>
            <span class="c1"># critical so that things that conductor does on behalf of another</span>
            <span class="c1"># node are not logged as exceptions in conductor logs. Otherwise,</span>
            <span class="c1"># you&#39;d have the same thing logged in both places, even though an</span>
            <span class="c1"># exception here *always* means that the caller screwed up, so</span>
            <span class="c1"># there&#39;s no reason to log it here.</span>
            <span class="k">raise</span> <span class="n">messaging</span><span class="o">.</span><span class="n">ExpectedException</span><span class="p">()</span>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.object_class_action_versions&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="ConductorManager.object_class_action_versions"><a class="viewcode-back" href="../../../api/ironic.conductor.manager.html#ironic.conductor.manager.ConductorManager.object_class_action_versions">[docs]</a>    <span class="k">def</span> <span class="nf">object_class_action_versions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">objname</span><span class="p">,</span> <span class="n">objmethod</span><span class="p">,</span>
                                     <span class="n">object_versions</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform an action on a VersionedObject class.</span>

<span class="sd">        :param context: The context within which to perform the action</span>
<span class="sd">        :param objname: The registry name of the object</span>
<span class="sd">        :param objmethod: The name of the action method to call</span>
<span class="sd">        :param object_versions: A dict of {objname: version} mappings</span>
<span class="sd">        :param args: The positional arguments to the action method</span>
<span class="sd">        :param kwargs: The keyword arguments to the action method</span>
<span class="sd">        :returns: The result of the action method, which may (or may not)</span>
<span class="sd">                  be an instance of the implementing VersionedObject class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objclass</span> <span class="o">=</span> <span class="n">objects_base</span><span class="o">.</span><span class="n">IronicObject</span><span class="o">.</span><span class="n">obj_class_from_name</span><span class="p">(</span>
            <span class="n">objname</span><span class="p">,</span> <span class="n">object_versions</span><span class="p">[</span><span class="n">objname</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_dispatch</span><span class="p">(</span><span class="n">objclass</span><span class="p">,</span> <span class="n">objmethod</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span>
                                       <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># NOTE(danms): The RPC layer will convert to primitives for us,</span>
        <span class="c1"># but in this case, we need to honor the version the client is</span>
        <span class="c1"># asking for, so we do it before returning here.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">objects_base</span><span class="o">.</span><span class="n">IronicObject</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">obj_to_primitive</span><span class="p">(</span>
                <span class="n">target_version</span><span class="o">=</span><span class="n">object_versions</span><span class="p">[</span><span class="n">objname</span><span class="p">],</span>
                <span class="n">version_manifest</span><span class="o">=</span><span class="n">object_versions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.object_action&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="ConductorManager.object_action"><a class="viewcode-back" href="../../../api/ironic.conductor.manager.html#ironic.conductor.manager.ConductorManager.object_action">[docs]</a>    <span class="k">def</span> <span class="nf">object_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">objinst</span><span class="p">,</span> <span class="n">objmethod</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform an action on a VersionedObject instance.</span>

<span class="sd">        :param context: The context within which to perform the action</span>
<span class="sd">        :param objinst: The object instance on which to perform the action</span>
<span class="sd">        :param objmethod: The name of the action method to call</span>
<span class="sd">        :param args: The positional arguments to the action method</span>
<span class="sd">        :param kwargs: The keyword arguments to the action method</span>
<span class="sd">        :returns: A tuple with the updates made to the object and</span>
<span class="sd">                  the result of the action method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">oldobj</span> <span class="o">=</span> <span class="n">objinst</span><span class="o">.</span><span class="n">obj_clone</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_object_dispatch</span><span class="p">(</span><span class="n">objinst</span><span class="p">,</span> <span class="n">objmethod</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span>
                                       <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># NOTE(danms): Diff the object with the one passed to us and</span>
        <span class="c1"># generate a list of changes to forward back</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">objinst</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">objinst</span><span class="o">.</span><span class="n">obj_attr_is_set</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="c1"># Avoid demand-loading anything</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">oldobj</span><span class="o">.</span><span class="n">obj_attr_is_set</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">oldobj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">objinst</span><span class="p">,</span> <span class="n">name</span><span class="p">)):</span>
                <span class="n">updates</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">to_primitive</span><span class="p">(</span><span class="n">objinst</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                                                   <span class="nb">getattr</span><span class="p">(</span><span class="n">objinst</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="c1"># This is safe since a field named this would conflict with the</span>
        <span class="c1"># method anyway</span>
        <span class="n">updates</span><span class="p">[</span><span class="s1">&#39;obj_what_changed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">objinst</span><span class="o">.</span><span class="n">obj_what_changed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">updates</span><span class="p">,</span> <span class="n">result</span></div>

    <span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;ConductorManager.object_backport_versions&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="ConductorManager.object_backport_versions"><a class="viewcode-back" href="../../../api/ironic.conductor.manager.html#ironic.conductor.manager.ConductorManager.object_backport_versions">[docs]</a>    <span class="k">def</span> <span class="nf">object_backport_versions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">objinst</span><span class="p">,</span> <span class="n">object_versions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a backport of an object instance.</span>

<span class="sd">        The default behavior of the base VersionedObjectSerializer, upon</span>
<span class="sd">        receiving an object with a version newer than what is in the local</span>
<span class="sd">        registry, is to call this method to request a backport of the object.</span>

<span class="sd">        :param context: The context within which to perform the backport</span>
<span class="sd">        :param objinst: An instance of a VersionedObject to be backported</span>
<span class="sd">        :param object_versions: A dict of {objname: version} mappings</span>
<span class="sd">        :returns: The downgraded instance of objinst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">object_versions</span><span class="p">[</span><span class="n">objinst</span><span class="o">.</span><span class="n">obj_name</span><span class="p">()]</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Backporting </span><span class="si">%(obj)s</span><span class="s1"> to </span><span class="si">%(ver)s</span><span class="s1"> with versions </span><span class="si">%(manifest)s</span><span class="s1">&#39;</span><span class="p">,</span>
                  <span class="p">{</span><span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">objinst</span><span class="o">.</span><span class="n">obj_name</span><span class="p">(),</span>
                   <span class="s1">&#39;ver&#39;</span><span class="p">:</span> <span class="n">target</span><span class="p">,</span>
                   <span class="s1">&#39;manifest&#39;</span><span class="p">:</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                       <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ver</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ver</span> <span class="ow">in</span> <span class="n">object_versions</span><span class="o">.</span><span class="n">items</span><span class="p">()])})</span>
        <span class="k">return</span> <span class="n">objinst</span><span class="o">.</span><span class="n">obj_to_primitive</span><span class="p">(</span><span class="n">target_version</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
                                        <span class="n">version_manifest</span><span class="o">=</span><span class="n">object_versions</span><span class="p">)</span></div></div>


<span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;get_vendor_passthru_metadata&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_vendor_passthru_metadata</span><span class="p">(</span><span class="n">route_dict</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="n">route_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># &#39;func&#39; is the vendor method reference, ignore it</span>
        <span class="n">d</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;func&#39;</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">_get_configdrive_obj_name</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate the object name for the config drive.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;configdrive-</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span>


<span class="k">def</span> <span class="nf">_store_configdrive</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">configdrive</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handle the storage of the config drive.</span>

<span class="sd">    If configured, the config drive data are uploaded to Swift. The Node&#39;s</span>
<span class="sd">    instance_info is updated to include either the temporary Swift URL</span>
<span class="sd">    from the upload, or if no upload, the actual config drive data.</span>

<span class="sd">    :param node: an Ironic node object.</span>
<span class="sd">    :param configdrive: A gzipped and base64 encoded configdrive.</span>
<span class="sd">    :raises: SwiftOperationError if an error occur when uploading the</span>
<span class="sd">             config drive to Swift.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">configdrive_use_swift</span><span class="p">:</span>
        <span class="c1"># NOTE(lucasagomes): No reason to use a different timeout than</span>
        <span class="c1"># the one used for deploying the node</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">deploy_callback_timeout</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">configdrive_swift_container</span>
        <span class="n">object_name</span> <span class="o">=</span> <span class="n">_get_configdrive_obj_name</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">object_headers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X-Delete-After&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">timeout</span><span class="p">)}</span>

        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">CONF</span><span class="o">.</span><span class="n">tempdir</span><span class="p">)</span> <span class="k">as</span> <span class="n">fileobj</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configdrive</span><span class="p">)</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="n">swift_api</span> <span class="o">=</span> <span class="n">swift</span><span class="o">.</span><span class="n">SwiftAPI</span><span class="p">()</span>
            <span class="n">swift_api</span><span class="o">.</span><span class="n">create_object</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">object_name</span><span class="p">,</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">object_headers</span><span class="o">=</span><span class="n">object_headers</span><span class="p">)</span>
            <span class="n">configdrive</span> <span class="o">=</span> <span class="n">swift_api</span><span class="o">.</span><span class="n">get_temp_url</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">object_name</span><span class="p">,</span>
                                                 <span class="n">timeout</span><span class="p">)</span>

    <span class="n">i_info</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span>
    <span class="n">i_info</span><span class="p">[</span><span class="s1">&#39;configdrive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">configdrive</span>
    <span class="n">node</span><span class="o">.</span><span class="n">instance_info</span> <span class="o">=</span> <span class="n">i_info</span>


<span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;do_node_deploy&#39;</span><span class="p">)</span>
<span class="nd">@task_manager.require_exclusive_lock</span>
<span class="k">def</span> <span class="nf">do_node_deploy</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">conductor_id</span><span class="p">,</span> <span class="n">configdrive</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prepare the environment and deploy a node.&quot;&quot;&quot;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

    <span class="k">def</span> <span class="nf">handle_failure</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">logmsg</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">):</span>
        <span class="c1"># NOTE(deva): there is no need to clear conductor_affinity</span>
        <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">}</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">logmsg</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">errmsg</span> <span class="o">%</span> <span class="n">e</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">configdrive</span><span class="p">:</span>
                <span class="n">_store_configdrive</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">configdrive</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">SwiftOperationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
                <span class="n">handle_failure</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span>
                    <span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Error while uploading the configdrive for &#39;</span>
                        <span class="s1">&#39;</span><span class="si">%(node)s</span><span class="s1"> to Swift&#39;</span><span class="p">),</span>
                    <span class="n">_</span><span class="p">(</span><span class="s1">&#39;Failed to upload the configdrive to Swift. &#39;</span>
                      <span class="s1">&#39;Error: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
                <span class="n">handle_failure</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span>
                    <span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Error while preparing to deploy to node </span><span class="si">%(node)s</span><span class="s1">: &#39;</span>
                        <span class="s1">&#39;</span><span class="si">%(err)s</span><span class="s1">&#39;</span><span class="p">),</span>
                    <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Failed to prepare to deploy. Error: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">deploy</span><span class="o">.</span><span class="n">deploy</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
                <span class="n">handle_failure</span><span class="p">(</span>
                    <span class="n">e</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span>
                    <span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Error in deploy of node </span><span class="si">%(node)s</span><span class="s1">: </span><span class="si">%(err)s</span><span class="s1">&#39;</span><span class="p">),</span>
                    <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Failed to deploy. Error: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="c1"># Update conductor_affinity to reference this conductor&#39;s ID</span>
        <span class="c1"># since there may be local persistent state</span>
        <span class="n">node</span><span class="o">.</span><span class="n">conductor_affinity</span> <span class="o">=</span> <span class="n">conductor_id</span>

        <span class="c1"># NOTE(deva): Some drivers may return states.DEPLOYWAIT</span>
        <span class="c1">#             eg. if they are waiting for a callback</span>
        <span class="k">if</span> <span class="n">new_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYDONE</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully deployed node </span><span class="si">%(node)s</span><span class="s1"> with &#39;</span>
                         <span class="s1">&#39;instance </span><span class="si">%(instance)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                     <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;instance&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">instance_uuid</span><span class="p">})</span>
        <span class="k">elif</span> <span class="n">new_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">DEPLOYWAIT</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;wait&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s1">&#39;Unexpected state </span><span class="si">%(state)s</span><span class="s1"> returned while &#39;</span>
                          <span class="s1">&#39;deploying node </span><span class="si">%(node)s</span><span class="s1">.&#39;</span><span class="p">),</span>
                      <span class="p">{</span><span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">new_state</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>


<span class="nd">@task_manager.require_exclusive_lock</span>
<span class="k">def</span> <span class="nf">handle_sync_power_state_max_retries_exceeded</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">actual_power_state</span><span class="p">,</span>
                                                 <span class="n">exception</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handles power state sync exceeding the max retries.</span>

<span class="sd">    When synchronizing the power state between a node and the DB has exceeded</span>
<span class="sd">    the maximum number of retries, change the DB power state to be the actual</span>
<span class="sd">    node power state and place the node in maintenance.</span>

<span class="sd">    :param task: a TaskManager instance with an exclusive lock</span>
<span class="sd">    :param actual_power_state: the actual power state of the node; a power</span>
<span class="sd">           state from ironic.common.states</span>
<span class="sd">    :param exception: the exception object that caused the sync power state</span>
<span class="sd">           to fail, if present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, max retries exceeded &quot;</span>
             <span class="s2">&quot;for node </span><span class="si">%(node)s</span><span class="s2">, node state </span><span class="si">%(actual)s</span><span class="s2"> &quot;</span>
             <span class="s2">&quot;does not match expected state &#39;</span><span class="si">%(state)s</span><span class="s2">&#39;. &quot;</span>
             <span class="s2">&quot;Updating DB state to &#39;</span><span class="si">%(actual)s</span><span class="s2">&#39; &quot;</span>
             <span class="s2">&quot;Switching node to maintenance mode.&quot;</span><span class="p">)</span> <span class="o">%</span>
           <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="n">actual_power_state</span><span class="p">,</span>
            <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">exception</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot; Error: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">exception</span>

    <span class="n">old_power_state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span>
    <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">actual_power_state</span>
    <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">msg</span>
    <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">node</span><span class="o">.</span><span class="n">maintenance_reason</span> <span class="o">=</span> <span class="n">msg</span>
    <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">old_power_state</span> <span class="o">!=</span> <span class="n">actual_power_state</span><span class="p">:</span>
        <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_power_state_corrected_notification</span><span class="p">(</span>
            <span class="n">task</span><span class="p">,</span> <span class="n">old_power_state</span><span class="p">)</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="nd">@METRICS.timer</span><span class="p">(</span><span class="s1">&#39;do_sync_power_state&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_sync_power_state</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sync the power state for this node, incrementing the counter on failure.</span>

<span class="sd">    When the limit of power_state_sync_max_retries is reached, the node is put</span>
<span class="sd">    into maintenance mode and the error recorded.</span>

<span class="sd">    :param task: a TaskManager instance</span>
<span class="sd">    :param count: number of times this node has previously failed a sync</span>
<span class="sd">    :raises: NodeLocked if unable to upgrade task lock to an exclusive one</span>
<span class="sd">    :returns: Count of failed attempts.</span>
<span class="sd">              On success, the counter is set to 0.</span>
<span class="sd">              On failure, the count is incremented by one</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>
    <span class="n">old_power_state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span>
    <span class="n">power_state</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">max_retries</span> <span class="o">=</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">power_state_sync_max_retries</span>
    <span class="c1"># If power driver info can not be validated, and node has no prior state,</span>
    <span class="c1"># do not attempt to sync the node&#39;s power state.</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidParameterValue</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># The driver may raise an exception, or may return ERROR.</span>
        <span class="c1"># Handle both the same way.</span>
        <span class="n">power_state</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">power</span><span class="o">.</span><span class="n">get_power_state</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">ERROR</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">PowerStateFailure</span><span class="p">(</span>
                <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Power driver returned ERROR state &quot;</span>
                  <span class="s2">&quot;while trying to sync power state.&quot;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># Stop if any exception is raised when getting the power state</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">upgrade_lock</span><span class="p">()</span>
            <span class="n">handle_sync_power_state_max_retries_exceeded</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">power_state</span><span class="p">,</span>
                                                         <span class="n">exception</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, could not get power &quot;</span>
                            <span class="s2">&quot;state for node </span><span class="si">%(node)s</span><span class="s2">, attempt </span><span class="si">%(attempt)s</span><span class="s2"> of &quot;</span>
                            <span class="s2">&quot;</span><span class="si">%(retries)s</span><span class="s2">. Error: </span><span class="si">%(err)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                        <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;attempt&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span>
                         <span class="s1">&#39;retries&#39;</span><span class="p">:</span> <span class="n">max_retries</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">power_state</span><span class="p">:</span>
        <span class="c1"># No action is needed</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># We will modify a node, so upgrade our lock and use reloaded node.</span>
    <span class="c1"># This call may raise NodeLocked that will be caught on upper level.</span>
    <span class="n">task</span><span class="o">.</span><span class="n">upgrade_lock</span><span class="p">()</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

    <span class="c1"># Repeat all checks with exclusive lock to avoid races</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">==</span> <span class="n">power_state</span><span class="p">:</span>
        <span class="c1"># Node power state was updated to the correct value</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">provision_state</span> <span class="ow">in</span> <span class="n">SYNC_EXCLUDED_STATES</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">maintenance</span><span class="p">:</span>
        <span class="c1"># Something was done to a node while a shared lock was held</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># If node has no prior state AND we successfully got a state,</span>
        <span class="c1"># simply record that and send a notification.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, node </span><span class="si">%(node)s</span><span class="s2"> has no &quot;</span>
                     <span class="s2">&quot;previous known state. Recording current state &quot;</span>
                     <span class="s2">&quot;&#39;</span><span class="si">%(state)s</span><span class="s2">&#39;.&quot;</span><span class="p">),</span>
                 <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">power_state</span><span class="p">})</span>
        <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">power_state</span>
        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_power_state_corrected_notification</span><span class="p">(</span>
            <span class="n">task</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_retries</span><span class="p">:</span>
        <span class="n">handle_sync_power_state_max_retries_exceeded</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">power_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">if</span> <span class="n">CONF</span><span class="o">.</span><span class="n">conductor</span><span class="o">.</span><span class="n">force_power_state_during_sync</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, node </span><span class="si">%(node)s</span><span class="s2"> state &quot;</span>
                        <span class="s2">&quot;&#39;</span><span class="si">%(actual)s</span><span class="s2">&#39; does not match expected state. &quot;</span>
                        <span class="s2">&quot;Changing hardware state to &#39;</span><span class="si">%(state)s</span><span class="s2">&#39;.&quot;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="n">power_state</span><span class="p">,</span>
                     <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">})</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># node_power_action will update the node record</span>
            <span class="c1"># so don&#39;t do that again here.</span>
            <span class="n">utils</span><span class="o">.</span><span class="n">node_power_action</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span>
                <span class="s2">&quot;Failed to change power state of node </span><span class="si">%(node)s</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;to &#39;</span><span class="si">%(state)s</span><span class="s2">&#39;, attempt </span><span class="si">%(attempt)s</span><span class="s2"> of </span><span class="si">%(retries)s</span><span class="s2">.&quot;</span><span class="p">),</span>
                <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span>
                 <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">,</span>
                 <span class="s1">&#39;attempt&#39;</span><span class="p">:</span> <span class="n">count</span><span class="p">,</span>
                 <span class="s1">&#39;retries&#39;</span><span class="p">:</span> <span class="n">max_retries</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_LW</span><span class="p">(</span><span class="s2">&quot;During sync_power_state, node </span><span class="si">%(node)s</span><span class="s2"> state &quot;</span>
                        <span class="s2">&quot;does not match expected state &#39;</span><span class="si">%(state)s</span><span class="s2">&#39;. &quot;</span>
                        <span class="s2">&quot;Updating recorded state to &#39;</span><span class="si">%(actual)s</span><span class="s2">&#39;.&quot;</span><span class="p">),</span>
                    <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;actual&#39;</span><span class="p">:</span> <span class="n">power_state</span><span class="p">,</span>
                     <span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">power_state</span><span class="p">})</span>
        <span class="n">node</span><span class="o">.</span><span class="n">power_state</span> <span class="o">=</span> <span class="n">power_state</span>
        <span class="n">node</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="n">notify_utils</span><span class="o">.</span><span class="n">emit_power_state_corrected_notification</span><span class="p">(</span>
            <span class="n">task</span><span class="p">,</span> <span class="n">old_power_state</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">count</span>


<span class="nd">@task_manager.require_exclusive_lock</span>
<span class="k">def</span> <span class="nf">_do_inspect_hardware</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initiates inspection.</span>

<span class="sd">    :param: task: a TaskManager instance with an exclusive lock</span>
<span class="sd">                  on its node.</span>
<span class="sd">    :raises: HardwareInspectionFailure if driver doesn&#39;t</span>
<span class="sd">             return the state as states.MANAGEABLE or</span>
<span class="sd">             states.INSPECTING.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">node</span>

    <span class="k">def</span> <span class="nf">handle_failure</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">log_func</span><span class="o">=</span><span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">):</span>
        <span class="n">node</span><span class="o">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">e</span>
        <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;fail&#39;</span><span class="p">)</span>
        <span class="n">log_func</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s2">&quot;Failed to inspect node </span><span class="si">%(node)s</span><span class="s2">: </span><span class="si">%(err)s</span><span class="s2">&quot;</span><span class="p">),</span>
                 <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">driver</span><span class="o">.</span><span class="n">inspect</span><span class="o">.</span><span class="n">inspect_hardware</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exception</span><span class="o">.</span><span class="n">IronicException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
            <span class="n">error</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">handle_failure</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s1">&#39;Unexpected exception of type </span><span class="si">%(type)s</span><span class="s1">: </span><span class="si">%(msg)s</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">%</span>
                 <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;msg&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">})</span>
        <span class="n">handle_failure</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">log_func</span><span class="o">=</span><span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">HardwareInspectionFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_state</span> <span class="o">==</span> <span class="n">states</span><span class="o">.</span><span class="n">MANAGEABLE</span><span class="p">:</span>
        <span class="n">task</span><span class="o">.</span><span class="n">process_event</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_LI</span><span class="p">(</span><span class="s1">&#39;Successfully inspected node </span><span class="si">%(node)s</span><span class="s1">&#39;</span><span class="p">),</span>
                 <span class="p">{</span><span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">uuid</span><span class="p">})</span>
    <span class="k">elif</span> <span class="n">new_state</span> <span class="o">!=</span> <span class="n">states</span><span class="o">.</span><span class="n">INSPECTING</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s2">&quot;During inspection, driver returned unexpected &quot;</span>
                   <span class="s2">&quot;state </span><span class="si">%(state)s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;state&#39;</span><span class="p">:</span> <span class="n">new_state</span><span class="p">})</span>
        <span class="n">handle_failure</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">HardwareInspectionFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/ironic
"
                     rel="nofollow">Project Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Ironic 7.0.1.dev7 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright OpenStack Foundation.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/Ironic");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>