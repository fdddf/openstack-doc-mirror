<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Atoms, tasks and retries &mdash; TaskFlow 2.9.1.dev5 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.9.1.dev5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="TaskFlow 2.9.1.dev5 documentation" href="index.html" />
    <link rel="next" title="Arguments and results" href="arguments_and_results.html" />
    <link rel="prev" title="TaskFlow" href="index.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="atoms-tasks-and-retries">
<h1>Atoms, tasks and retries<a class="headerlink" href="#atoms-tasks-and-retries" title="Permalink to this headline">¶</a></h1>
<div class="section" id="atom">
<h2>Atom<a class="headerlink" href="#atom" title="Permalink to this headline">¶</a></h2>
<p>An <a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">atom</span></code></a> is the smallest unit in TaskFlow which
acts as the base for other classes (its naming was inspired from the
similarities between this type and <a class="reference external" href="http://en.wikipedia.org/wiki/Atom">atoms</a> in the physical world). Atoms
have a name and may have a version. An atom is expected to name desired input
values (requirements) and name outputs (provided values).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For more details about atom inputs and outputs please visit
<a class="reference internal" href="arguments_and_results.html"><em>arguments and results</em></a>.</p>
</div>
<span class="target" id="module-taskflow.atom"></span><dl class="class">
<dt id="taskflow.atom.Atom">
<em class="property">class </em><code class="descclassname">taskflow.atom.</code><code class="descname">Atom</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>inject=None</em>, <em>ignore_list=None</em>, <em>revert_rebind=None</em>, <em>revert_requires=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An unit of work that causes a flow to progress (in some manner).</p>
<p>An atom is a named object that operates with input data to perform
some action that furthers the overall flows progress. It usually also
produces some of its own named output as a result of this process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> &#8211; Meaningful name for this atom, should be something that is
distinguishable and understandable for notification,
debugging, storing and any other similar purposes.</li>
<li><strong>provides</strong> &#8211; A set, string or list of items that
this will be providing (or could provide) to others, used
to correlate and associate the thing/s this atom
produces, if it produces anything at all.</li>
<li><strong>inject</strong> &#8211; An <em>immutable</em> input_name =&gt; value dictionary which
specifies  any initial inputs that should be automatically
injected into the atoms scope before the atom execution
commences (this allows for providing atom <em>local</em> values
that do not need to be provided by other atoms/dependents).</li>
<li><strong>rebind</strong> &#8211; A dict of key/value pairs used to define argument
name conversions for inputs to this atom&#8217;s <code class="docutils literal"><span class="pre">execute</span></code>
method.</li>
<li><strong>revert_rebind</strong> &#8211; The same as <code class="docutils literal"><span class="pre">rebind</span></code> but for the <code class="docutils literal"><span class="pre">revert</span></code>
method. If unpassed, <code class="docutils literal"><span class="pre">rebind</span></code> will be used
instead.</li>
<li><strong>requires</strong> &#8211; A set or list of required inputs for this atom&#8217;s
<code class="docutils literal"><span class="pre">execute</span></code> method.</li>
<li><strong>revert_requires</strong> &#8211; A set or list of required inputs for this atom&#8217;s
<code class="docutils literal"><span class="pre">revert</span></code> method. If unpassed, <code class="docutils literal"><span class="pre">`requires</span></code> will
be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>version</strong> &#8211; An <em>immutable</em> version that associates version information
with this atom. It can be useful in resuming older versions
of atoms. Standard major, minor versioning concepts
should apply.</li>
<li><strong>save_as</strong> &#8211; An <em>immutable</em> output <code class="docutils literal"><span class="pre">resource</span></code> name
<code class="xref py py-class docutils literal"><span class="pre">OrderedDict</span></code> this atom produces that other
atoms may depend on this atom providing. The format is
output index (or key when a dictionary is returned from
the execute method) to stored argument name.</li>
<li><strong>rebind</strong> &#8211; An <em>immutable</em> input <code class="docutils literal"><span class="pre">resource</span></code> <code class="xref py py-class docutils literal"><span class="pre">OrderedDict</span></code>
that can be used to alter the inputs given to this atom. It
is typically used for mapping a prior atoms output into
the names that this atom expects (in a way this is like
remapping a namespace of another atom into the namespace
of this atom).</li>
<li><strong>revert_rebind</strong> &#8211; The same as <code class="docutils literal"><span class="pre">rebind</span></code> but for the revert method. This
should only differ from <code class="docutils literal"><span class="pre">rebind</span></code> if the <code class="docutils literal"><span class="pre">revert</span></code>
method has a different signature from <code class="docutils literal"><span class="pre">execute</span></code> or
a different <code class="docutils literal"><span class="pre">revert_rebind</span></code> value was received.</li>
<li><a class="reference internal" href="persistence.html#taskflow.storage.Storage.inject" title="taskflow.storage.Storage.inject"><strong>inject</strong></a> &#8211; See parameter <code class="docutils literal"><span class="pre">inject</span></code>.</li>
<li><a class="reference internal" href="persistence.html#taskflow.persistence.models.AtomDetail.name" title="taskflow.persistence.models.AtomDetail.name"><strong>name</strong></a> &#8211; See parameter <code class="docutils literal"><span class="pre">name</span></code>.</li>
<li><a class="reference internal" href="patterns.html#taskflow.flow.Flow.requires" title="taskflow.flow.Flow.requires"><strong>requires</strong></a> &#8211; A <a class="reference internal" href="types.html#taskflow.types.sets.OrderedSet" title="taskflow.types.sets.OrderedSet"><code class="xref py py-class docutils literal"><span class="pre">OrderedSet</span></code></a> of inputs
this atom requires to function.</li>
<li><strong>optional</strong> &#8211; A <a class="reference internal" href="types.html#taskflow.types.sets.OrderedSet" title="taskflow.types.sets.OrderedSet"><code class="xref py py-class docutils literal"><span class="pre">OrderedSet</span></code></a> of inputs
that are optional for this atom to <code class="docutils literal"><span class="pre">execute</span></code>.</li>
<li><strong>revert_optional</strong> &#8211; The <code class="docutils literal"><span class="pre">revert</span></code> version of <code class="docutils literal"><span class="pre">optional</span></code>.</li>
<li><a class="reference internal" href="patterns.html#taskflow.flow.Flow.provides" title="taskflow.flow.Flow.provides"><strong>provides</strong></a> &#8211; A <a class="reference internal" href="types.html#taskflow.types.sets.OrderedSet" title="taskflow.types.sets.OrderedSet"><code class="xref py py-class docutils literal"><span class="pre">OrderedSet</span></code></a> of outputs
this atom produces.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="taskflow.atom.Atom.priority">
<code class="descname">priority</code><em class="property"> = 0</em><a class="headerlink" href="#taskflow.atom.Atom.priority" title="Permalink to this definition">¶</a></dt>
<dd><p>A numeric priority that instances of this class will have when running,
used when there are multiple <em>parallel</em> candidates to execute and/or
revert. During this situation the candidate list will be stably sorted
based on this priority attribute which will result in atoms with higher
priorities executing (or reverting) before atoms with lower
priorities (higher being defined as a number bigger, or greater tha
an atom with a lower priority number). By default all atoms have the same
priority (zero).</p>
<p>For example when the following is combined into a
graph (where each node in the denoted graph is some task):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>a -&gt; b
b -&gt; c
b -&gt; e
b -&gt; f
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">b</span></code> finishes there will then be three candidates that can run
<code class="docutils literal"><span class="pre">(c,</span> <span class="pre">e,</span> <span class="pre">f)</span></code> and they may run in any order. What this priority does is
sort those three by their priority before submitting them to be
worked on (so that instead of say a random run order they will now be
ran by there sorted order). This is also true when reverting (in that the
sort order of the potential nodes will be used to determine the
submission order).</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.pre_execute">
<code class="descname">pre_execute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.pre_execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.pre_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run prior to executing the atom.</p>
<p>A common pattern for initializing the state of the system prior to
running atoms is to define some code in a base class that all your
atoms inherit from.  In that class, you can define a <code class="docutils literal"><span class="pre">pre_execute</span></code>
method and it will always be invoked just prior to your atoms running.</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate a given atom which will perform some operation and return.</p>
<p>This method can be used to perform an action on a given set of input
requirements (passed in via <code class="docutils literal"><span class="pre">*args</span></code> and <code class="docutils literal"><span class="pre">**kwargs</span></code>) to accomplish
some type of operation. This operation may provide some named
outputs/results as a result of it executing for later reverting (or for
other atoms to depend on).</p>
<p>NOTE(harlowja): the result (if any) that is returned should be
persistable so that it can be passed back into this atom if
reverting is triggered (especially in the case where reverting
happens in a different python process or on a remote machine) and so
that the result can be transmitted to other atoms (which may be local
or remote).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; positional arguments that atom requires to execute.</li>
<li><strong>kwargs</strong> &#8211; any keyword arguments that atom requires to execute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.post_execute">
<code class="descname">post_execute</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.post_execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.post_execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run after executing the atom.</p>
<p>A common pattern for cleaning up global state of the system after the
execution of atoms is to define some code in a base class that all your
atoms inherit from.  In that class, you can define a <code class="docutils literal"><span class="pre">post_execute</span></code>
method and it will always be invoked just after your atoms execute,
regardless of whether they succeeded or not.</p>
<p>This pattern is useful if you have global shared database sessions
that need to be cleaned up, for example.</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.pre_revert">
<code class="descname">pre_revert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.pre_revert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.pre_revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run prior to reverting the atom.</p>
<p>This works the same as <a class="reference internal" href="#taskflow.atom.Atom.pre_execute" title="taskflow.atom.Atom.pre_execute"><code class="xref py py-meth docutils literal"><span class="pre">pre_execute()</span></code></a>, but for the revert phase.</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.revert">
<code class="descname">revert</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.revert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Revert this atom.</p>
<p>This method should undo any side-effects caused by previous execution
of the atom using the result of the <a class="reference internal" href="#taskflow.atom.Atom.execute" title="taskflow.atom.Atom.execute"><code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code></a> method and
information on the failure which triggered reversion of the flow the
atom is contained in (if applicable).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; positional arguments that the atom required to execute.</li>
<li><strong>kwargs</strong> &#8211; any keyword arguments that the atom required to
execute; the special key <code class="docutils literal"><span class="pre">'result'</span></code> will contain
the <a class="reference internal" href="#taskflow.atom.Atom.execute" title="taskflow.atom.Atom.execute"><code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code></a> result (if any) and
the <code class="docutils literal"><span class="pre">**kwargs</span></code> key <code class="docutils literal"><span class="pre">'flow_failures'</span></code> will contain
any failure information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="taskflow.atom.Atom.post_revert">
<code class="descname">post_revert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/atom.html#Atom.post_revert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.atom.Atom.post_revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Code to be run after reverting the atom.</p>
<p>This works the same as <a class="reference internal" href="#taskflow.atom.Atom.post_execute" title="taskflow.atom.Atom.post_execute"><code class="xref py py-meth docutils literal"><span class="pre">post_execute()</span></code></a>, but for the revert phase.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="task">
<h2>Task<a class="headerlink" href="#task" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">task</span></code></a> (derived from an atom) is a
unit of work that can have an execute &amp; rollback sequence associated with
it (they are <em>nearly</em> analogous to functions). Your task objects should all
derive from <a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a> which defines what a task must
provide in terms of properties and methods.</p>
<p><strong>For example:</strong></p>
<a class="reference internal image-reference" href="_images/tasks.png"><img alt="Task outline." class="align-left" src="_images/tasks.png" style="width: 525px;" /></a>
<p>Currently the following <em>provided</em> types of task subclasses are:</p>
<ul class="simple">
<li><a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">Task</span></code></a>: useful for inheriting from and creating your
own subclasses.</li>
<li><a class="reference internal" href="#taskflow.task.FunctorTask" title="taskflow.task.FunctorTask"><code class="xref py py-class docutils literal"><span class="pre">FunctorTask</span></code></a>: useful for wrapping existing
functions into task objects.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="#taskflow.task.FunctorTask" title="taskflow.task.FunctorTask"><code class="xref py py-class docutils literal"><span class="pre">FunctorTask</span></code></a> task types can not currently be used
with the <a class="reference internal" href="workers.html"><em>worker based engine</em></a> due to the fact that
arbitrary functions can not be guaranteed to be correctly
located (especially if they are lambda or anonymous functions) on the
worker nodes.</p>
</div>
</div>
<div class="section" id="retry">
<h2>Retry<a class="headerlink" href="#retry" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">retry</span></code></a> (derived from an atom) is a special
unit of work that handles errors, controls flow execution and can (for
example) retry other atoms with other parameters if needed. When an associated
atom fails, these retry units are <em>consulted</em> to determine what the resolution
<em>strategy</em> should be. The goal is that with this consultation the retry atom
will suggest a <em>strategy</em> for getting around the failure (perhaps by retrying,
reverting a single atom, or reverting everything contained in the retries
associated <a class="reference external" href="http://en.wikipedia.org/wiki/Scope_%28computer_science%29">scope</a>).</p>
<p>Currently derivatives of the <a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">retry</span></code></a> base
class must provide a <a class="reference internal" href="#taskflow.retry.Retry.on_failure" title="taskflow.retry.Retry.on_failure"><code class="xref py py-func docutils literal"><span class="pre">on_failure()</span></code></a> method to
determine how a failure should be handled. The current enumeration(s) that can
be returned from the <a class="reference internal" href="#taskflow.retry.Retry.on_failure" title="taskflow.retry.Retry.on_failure"><code class="xref py py-func docutils literal"><span class="pre">on_failure()</span></code></a> method
are defined in an enumeration class described here:</p>
<dl class="class">
<dt id="taskflow.retry.Decision">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">Decision</code><a class="reference internal" href="_modules/taskflow/retry.html#Decision"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Decision" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="utils.html#taskflow.utils.misc.StrEnum" title="taskflow.utils.misc.StrEnum"><code class="xref py py-class docutils literal"><span class="pre">taskflow.utils.misc.StrEnum</span></code></a></p>
<p>Decision results/strategy enumeration.</p>
<dl class="attribute">
<dt id="taskflow.retry.Decision.REVERT">
<code class="descname">REVERT</code><em class="property"> = &lt;Decision.REVERT: 'REVERT'&gt;</em><a class="headerlink" href="#taskflow.retry.Decision.REVERT" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverts only the surrounding/associated subflow.</p>
<p>This strategy first consults the parent atom before reverting the
associated subflow to determine if the parent retry object provides a
different reconciliation strategy.  This allows for safe nesting of
flows with different retry strategies.</p>
<p>If the parent flow has no retry strategy, the default behavior is
to just revert the atoms in the associated subflow.  This is
generally not the desired behavior, but is left as the default in
order to keep backwards-compatibility.  The <code class="docutils literal"><span class="pre">defer_reverts</span></code>
engine option will let you change this behavior.  If that is set
to True, a REVERT will always defer to the parent, meaning that
if the parent has no retry strategy, it will be reverted as well.</p>
</dd></dl>

<dl class="attribute">
<dt id="taskflow.retry.Decision.REVERT_ALL">
<code class="descname">REVERT_ALL</code><em class="property"> = &lt;Decision.REVERT_ALL: 'REVERT_ALL'&gt;</em><a class="headerlink" href="#taskflow.retry.Decision.REVERT_ALL" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverts the entire flow, regardless of parent strategy.</p>
<p>This strategy will revert every atom that has executed thus
far, regardless of whether the parent flow has a separate
retry strategy associated with it.</p>
</dd></dl>

<dl class="attribute">
<dt id="taskflow.retry.Decision.RETRY">
<code class="descname">RETRY</code><em class="property"> = &lt;Decision.RETRY: 'RETRY'&gt;</em><a class="headerlink" href="#taskflow.retry.Decision.RETRY" title="Permalink to this definition">¶</a></dt>
<dd><p>Retries the surrounding/associated subflow again.</p>
</dd></dl>

</dd></dl>

<p>To aid in the reconciliation process the
<a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">retry</span></code></a> base class also mandates
<a class="reference internal" href="#taskflow.retry.Retry.execute" title="taskflow.retry.Retry.execute"><code class="xref py py-func docutils literal"><span class="pre">execute()</span></code></a>
and <a class="reference internal" href="#taskflow.retry.Retry.revert" title="taskflow.retry.Retry.revert"><code class="xref py py-func docutils literal"><span class="pre">revert()</span></code></a> methods (although subclasses
are allowed to define these methods as no-ops) that can be used by a retry
atom to interact with the runtime execution model (for example, to track the
number of times it has been called which is useful for
the <a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a> retry subclass).</p>
<p>To avoid recreating common retry patterns the following provided retry
subclasses are provided:</p>
<ul class="simple">
<li><a class="reference internal" href="#taskflow.retry.AlwaysRevert" title="taskflow.retry.AlwaysRevert"><code class="xref py py-class docutils literal"><span class="pre">AlwaysRevert</span></code></a>: Always reverts subflow.</li>
<li><a class="reference internal" href="#taskflow.retry.AlwaysRevertAll" title="taskflow.retry.AlwaysRevertAll"><code class="xref py py-class docutils literal"><span class="pre">AlwaysRevertAll</span></code></a>: Always reverts the whole flow.</li>
<li><a class="reference internal" href="#taskflow.retry.Times" title="taskflow.retry.Times"><code class="xref py py-class docutils literal"><span class="pre">Times</span></code></a>: Retries subflow given number of times.</li>
<li><a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a>: Allows for providing different values
to subflow atoms each time a failure occurs (making it possibly to resolve
the failure by altering subflow atoms inputs).</li>
<li><a class="reference internal" href="#taskflow.retry.ParameterizedForEach" title="taskflow.retry.ParameterizedForEach"><code class="xref py py-class docutils literal"><span class="pre">ParameterizedForEach</span></code></a>: Same as
<a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a> but extracts values from storage
instead of the <a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a> constructor.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">They are <em>similar</em> to exception handlers but are made to be <em>more</em> capable
due to their ability to <em>dynamically</em> choose a reconciliation strategy,
which allows for these atoms to influence subsequent execution(s) and the
inputs any associated atoms require.</p>
</div>
<div class="section" id="area-of-influence">
<h3>Area of influence<a class="headerlink" href="#area-of-influence" title="Permalink to this headline">¶</a></h3>
<p>Each retry atom is associated with a flow and it can <em>influence</em> how the
atoms (or nested flows) contained in that flow retry or revert (using
the previously mentioned patterns and decision enumerations):</p>
<p><em>For example:</em></p>
<a class="reference internal image-reference" href="_images/area_of_influence.svg"><div align="left" class="align-left"><img alt="Retry area of influence" src="_images/area_of_influence.svg" width="325px" /></div>
</a>
<p>In this diagram retry controller (1) will be consulted if task <code class="docutils literal"><span class="pre">A</span></code>, <code class="docutils literal"><span class="pre">B</span></code>
or <code class="docutils literal"><span class="pre">C</span></code> fail and retry controller (2) decides to delegate its retry decision
to retry controller (1). If retry controller (2) does <strong>not</strong> decide to
delegate its retry decision to retry controller (1) then retry
controller (1) will be oblivious of any decisions. If any of
task <code class="docutils literal"><span class="pre">1</span></code>, <code class="docutils literal"><span class="pre">2</span></code> or <code class="docutils literal"><span class="pre">3</span></code> fail then only retry controller (1) will be
consulted to determine the strategy/pattern to apply to resolve there
associated failure.</p>
</div>
<div class="section" id="usage-examples">
<h3>Usage examples<a class="headerlink" href="#usage-examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">EchoTask</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">Task</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">linear_flow</span><span class="o">.</span><span class="n">Flow</span><span class="p">(</span><span class="s1">&#39;f1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">EchoTask</span><span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">linear_flow</span><span class="o">.</span><span class="n">Flow</span><span class="p">(</span><span class="s1">&#39;f2&#39;</span><span class="p">,</span> <span class="n">retry</span><span class="o">=</span><span class="n">retry</span><span class="o">.</span><span class="n">ForEach</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;r1&#39;</span><span class="p">,</span> <span class="n">provides</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
<span class="gp">... </span>        <span class="n">EchoTask</span><span class="p">(</span><span class="s1">&#39;t2&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">EchoTask</span><span class="p">(</span><span class="s1">&#39;t3&#39;</span><span class="p">,</span> <span class="n">requires</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">EchoTask</span><span class="p">(</span><span class="s1">&#39;t4&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example the flow <code class="docutils literal"><span class="pre">f2</span></code> has a retry controller <code class="docutils literal"><span class="pre">r1</span></code>, that is an
instance of the default retry controller <a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a>,
it accepts a collection of values and iterates over this collection when
each failure occurs. On each run <a class="reference internal" href="#taskflow.retry.ForEach" title="taskflow.retry.ForEach"><code class="xref py py-class docutils literal"><span class="pre">ForEach</span></code></a> retry
returns the next value from the collection and stops retrying a subflow if
there are no more values left in the collection. For example if tasks <code class="docutils literal"><span class="pre">t2</span></code> or
<code class="docutils literal"><span class="pre">t3</span></code> fail, then the flow <code class="docutils literal"><span class="pre">f2</span></code> will be reverted and retry <code class="docutils literal"><span class="pre">r1</span></code> will retry
it with the next value from the given collection <code class="docutils literal"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>. But if
the task <code class="docutils literal"><span class="pre">t1</span></code> or the task <code class="docutils literal"><span class="pre">t4</span></code> fails, <code class="docutils literal"><span class="pre">r1</span></code> won&#8217;t retry a flow, because
tasks <code class="docutils literal"><span class="pre">t1</span></code> and <code class="docutils literal"><span class="pre">t4</span></code> are in the flow <code class="docutils literal"><span class="pre">f1</span></code> and don&#8217;t depend on
retry <code class="docutils literal"><span class="pre">r1</span></code> (so they will not <em>consult</em> <code class="docutils literal"><span class="pre">r1</span></code> on failure).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SendMessage</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">Task</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Sending message: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">message</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">linear_flow</span><span class="o">.</span><span class="n">Flow</span><span class="p">(</span><span class="s1">&#39;send_message&#39;</span><span class="p">,</span> <span class="n">retry</span><span class="o">=</span><span class="n">retry</span><span class="o">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">SendMessage</span><span class="p">(</span><span class="s1">&#39;sender&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example the <code class="docutils literal"><span class="pre">send_message</span></code> flow will try to execute the
<code class="docutils literal"><span class="pre">SendMessage</span></code> five times when it fails. When it fails for the sixth time (if
it does) the task will be asked to <code class="docutils literal"><span class="pre">REVERT</span></code> (in this example task reverting
does not cause anything to happen but in other use cases it could).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ConnectToServer</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">Task</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Connecting to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ip</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">server_ips</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;192.168.1.1&#39;</span><span class="p">,</span> <span class="s1">&#39;192.168.1.2&#39;</span><span class="p">,</span> <span class="s1">&#39;192.168.1.3&#39;</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">linear_flow</span><span class="o">.</span><span class="n">Flow</span><span class="p">(</span><span class="s1">&#39;send_message&#39;</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">retry</span><span class="o">=</span><span class="n">retry</span><span class="o">.</span><span class="n">ParameterizedForEach</span><span class="p">(</span><span class="n">rebind</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="s1">&#39;server_ips&#39;</span><span class="p">},</span>
<span class="gp">... </span>                                                         <span class="n">provides</span><span class="o">=</span><span class="s1">&#39;ip&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">ConnectToServer</span><span class="p">(</span><span class="n">requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ip&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>In this example the flow tries to connect a server using a list (a tuple
can also be used) of possible IP addresses. Each time the retry will return
one IP from the list. In case of a failure it will return the next one until
it reaches the last one, then the flow will be reverted.</p>
</div>
</div>
<div class="section" id="module-taskflow.task">
<span id="interfaces"></span><h2>Interfaces<a class="headerlink" href="#module-taskflow.task" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="taskflow.task.Task">
<em class="property">class </em><code class="descclassname">taskflow.task.</code><code class="descname">Task</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>inject=None</em>, <em>ignore_list=None</em>, <em>revert_rebind=None</em>, <em>revert_requires=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#Task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.Task" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">taskflow.atom.Atom</span></code></a></p>
<p>An abstraction that defines a potential piece of work.</p>
<p>This potential piece of work is expected to be able to contain
functionality that defines what can be executed to accomplish that work
as well as a way of defining what can be executed to reverted/undo that
same piece of work.</p>
<dl class="attribute">
<dt id="taskflow.task.Task.notifier">
<code class="descname">notifier</code><a class="headerlink" href="#taskflow.task.Task.notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal notification dispatcher/registry.</p>
<p>A notification object that will dispatch events that occur related
to <em>internal</em> notifications that the task internally emits to
listeners (for example for progress status updates, telling others
that a task has reached 50% completion...).</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.task.Task.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>retain_listeners=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#Task.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.Task.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone/copy this task.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>retain_listeners</strong> &#8211; retain the attached notification listeners
when cloning, when false the listeners will
be emptied, when true the listeners will be
copied and retained</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the copied task</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="taskflow.task.Task.update_progress">
<code class="descname">update_progress</code><span class="sig-paren">(</span><em>progress</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#Task.update_progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.Task.update_progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Update task progress and notify all registered listeners.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>progress</strong> &#8211; task progress float value between 0.0 and 1.0</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="taskflow.task.FunctorTask">
<em class="property">class </em><code class="descclassname">taskflow.task.</code><code class="descname">FunctorTask</code><span class="sig-paren">(</span><em>execute</em>, <em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>revert=None</em>, <em>version=None</em>, <em>inject=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#FunctorTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.FunctorTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">taskflow.task.Task</span></code></a></p>
<p>Adaptor to make a task from a callable.</p>
<p>Take any callable pair and make a task from it.</p>
<p>NOTE(harlowja): If a name is not provided the function/method name of
the <code class="docutils literal"><span class="pre">execute</span></code> callable will be used as the name instead (the name of
the <code class="docutils literal"><span class="pre">revert</span></code> callable is not used).</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.task.ReduceFunctorTask">
<em class="property">class </em><code class="descclassname">taskflow.task.</code><code class="descname">ReduceFunctorTask</code><span class="sig-paren">(</span><em>functor</em>, <em>requires</em>, <em>name=None</em>, <em>provides=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>inject=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#ReduceFunctorTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.ReduceFunctorTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">taskflow.task.Task</span></code></a></p>
<p>General purpose Task to reduce a list by applying a function.</p>
<p>This Task mimics the behavior of Python&#8217;s built-in <code class="docutils literal"><span class="pre">reduce</span></code> function. The
Task takes a functor (lambda or otherwise) and a list. The list is
specified using the <code class="docutils literal"><span class="pre">requires</span></code> argument of the Task. When executed, this
task calls <code class="docutils literal"><span class="pre">reduce</span></code> with the functor and list as arguments. The resulting
value from the call to <code class="docutils literal"><span class="pre">reduce</span></code> is then returned after execution.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.task.MapFunctorTask">
<em class="property">class </em><code class="descclassname">taskflow.task.</code><code class="descname">MapFunctorTask</code><span class="sig-paren">(</span><em>functor</em>, <em>requires</em>, <em>name=None</em>, <em>provides=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>inject=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/task.html#MapFunctorTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.task.MapFunctorTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.task.Task" title="taskflow.task.Task"><code class="xref py py-class docutils literal"><span class="pre">taskflow.task.Task</span></code></a></p>
<p>General purpose Task to map a function to a list.</p>
<p>This Task mimics the behavior of Python&#8217;s built-in <code class="docutils literal"><span class="pre">map</span></code> function. The
Task takes a functor (lambda or otherwise) and a list. The list is
specified using the <code class="docutils literal"><span class="pre">requires</span></code> argument of the Task. When executed, this
task calls <code class="docutils literal"><span class="pre">map</span></code> with the functor and list as arguments. The resulting
list from the call to <code class="docutils literal"><span class="pre">map</span></code> is then returned after execution.</p>
<p>Each value of the returned list can be bound to individual names using
the <code class="docutils literal"><span class="pre">provides</span></code> argument, following taskflow standard behavior. Order is
preserved in the returned list.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.retry.Retry">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">Retry</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#Retry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Retry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">taskflow.atom.Atom</span></code></a></p>
<p>A class that can decide how to resolve execution failures.</p>
<p>This abstract base class is used to inherit from and provide different
strategies that will be activated upon execution failures. Since a retry
object is an atom it may also provide <a class="reference internal" href="#taskflow.retry.Retry.execute" title="taskflow.retry.Retry.execute"><code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code></a>
and <a class="reference internal" href="#taskflow.retry.Retry.revert" title="taskflow.retry.Retry.revert"><code class="xref py py-meth docutils literal"><span class="pre">revert()</span></code></a> methods to alter the inputs of
connected atoms (depending on the desired strategy to be used this can be
quite useful).</p>
<p>NOTE(harlowja): the <a class="reference internal" href="#taskflow.retry.Retry.execute" title="taskflow.retry.Retry.execute"><code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code></a> and
<a class="reference internal" href="#taskflow.retry.Retry.revert" title="taskflow.retry.Retry.revert"><code class="xref py py-meth docutils literal"><span class="pre">revert()</span></code></a> and
<a class="reference internal" href="#taskflow.retry.Retry.on_failure" title="taskflow.retry.Retry.on_failure"><code class="xref py py-meth docutils literal"><span class="pre">on_failure()</span></code></a> will automatically be given
a <code class="docutils literal"><span class="pre">history</span></code> parameter, which contains information about the past
decisions and outcomes that have occurred (if available).</p>
<dl class="method">
<dt id="taskflow.retry.Retry.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>history</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#Retry.execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Retry.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the given retry.</p>
<p>This execution activates a given retry which will typically produce
data required to start or restart a connected component using
previously provided values and a <code class="docutils literal"><span class="pre">history</span></code> of prior failures from
previous runs. The historical data can be analyzed to alter the
resolution strategy that this retry controller will use.</p>
<p>For example, a retry can provide the same values multiple times (after
each run), the latest value or some other variation. Old values will be
saved to the history of the retry atom automatically, that is a list of
tuples (result, failures) are persisted where failures is a dictionary
of failures indexed by task names and the result is the execution
result returned by this retry during that failure resolution
attempt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; positional arguments that retry requires to execute.</li>
<li><strong>kwargs</strong> &#8211; any keyword arguments that retry requires to execute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="taskflow.retry.Retry.revert">
<code class="descname">revert</code><span class="sig-paren">(</span><em>history</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#Retry.revert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Retry.revert" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverts this retry.</p>
<p>On revert call all results that had been provided by previous tries
and all errors caused during reversion are provided. This method
will be called <em>only</em> if a subflow must be reverted without the
retry (that is to say that the controller has ran out of resolution
options and has either given up resolution or has failed to handle
a execution failure).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>args</strong> &#8211; positional arguments that the retry required to execute.</li>
<li><strong>kwargs</strong> &#8211; any keyword arguments that the retry required to
execute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="taskflow.retry.Retry.on_failure">
<code class="descname">on_failure</code><span class="sig-paren">(</span><em>history</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#Retry.on_failure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Retry.on_failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a decision about the future.</p>
<p>This method will typically use information about prior failures (if
this historical failure information is not available or was not
persisted the provided history will be empty).</p>
<p>Returns a retry constant (one of):</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">RETRY</span></code>: when the controlling flow must be reverted and restarted
again (for example with new parameters).</li>
<li><code class="docutils literal"><span class="pre">REVERT</span></code>: when this controlling flow must be completely reverted
and the parent flow (if any) should make a decision about further
flow execution.</li>
<li><code class="docutils literal"><span class="pre">REVERT_ALL</span></code>: when this controlling flow and the parent
flow (if any) must be reverted and marked as a <code class="docutils literal"><span class="pre">FAILURE</span></code>.</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="taskflow.retry.History">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">History</code><span class="sig-paren">(</span><em>contents</em>, <em>failure=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#History"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.History" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper that simplifies interactions with retry historical contents.</p>
<dl class="attribute">
<dt id="taskflow.retry.History.failure">
<code class="descname">failure</code><a class="headerlink" href="#taskflow.retry.History.failure" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the retries own failure or none if not existent.</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.retry.History.outcomes_iter">
<code class="descname">outcomes_iter</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#History.outcomes_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.History.outcomes_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over the contained failure outcomes.</p>
<p>If the index is not provided, then all outcomes are iterated over.</p>
<p>NOTE(harlowja): if the retry itself failed, this will <strong>not</strong> include
those types of failures. Use the <a class="reference internal" href="#taskflow.retry.History.failure" title="taskflow.retry.History.failure"><code class="xref py py-attr docutils literal"><span class="pre">failure</span></code></a> attribute to
access that instead (if it exists, aka, non-none).</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.retry.History.provided_iter">
<code class="descname">provided_iter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#History.provided_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.History.provided_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all the values the retry has attempted (in order).</p>
</dd></dl>

<dl class="method">
<dt id="taskflow.retry.History.caused_by">
<code class="descname">caused_by</code><span class="sig-paren">(</span><em>exception_cls</em>, <em>index=None</em>, <em>include_retry=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#History.caused_by"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.History.caused_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the exception class provided caused the failures.</p>
<p>If the index is not provided, then all outcomes are iterated over.</p>
<dl class="docutils">
<dt>NOTE(harlowja): only if <code class="docutils literal"><span class="pre">include_retry</span></code> is provided as true (defaults</dt>
<dd>to false) will the potential retries own failure be
checked against as well.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="taskflow.retry.AlwaysRevert">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">AlwaysRevert</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#AlwaysRevert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.AlwaysRevert" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">taskflow.retry.Retry</span></code></a></p>
<p>Retry that always reverts subflow.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.retry.AlwaysRevertAll">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">AlwaysRevertAll</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#AlwaysRevertAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.AlwaysRevertAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">taskflow.retry.Retry</span></code></a></p>
<p>Retry that always reverts a whole flow.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.retry.Times">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">Times</code><span class="sig-paren">(</span><em>attempts=1</em>, <em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>revert_all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#Times"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.Times" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#taskflow.retry.Retry" title="taskflow.retry.Retry"><code class="xref py py-class docutils literal"><span class="pre">taskflow.retry.Retry</span></code></a></p>
<p>Retries subflow given number of times. Returns attempt number.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attempts</strong> (<em>int</em>) &#8211; number of attempts to retry the associated subflow
before giving up</li>
<li><strong>revert_all</strong> (<em>bool</em>) &#8211; when provided this will cause the full flow to revert
when the number of attempts that have been tried
has been reached (when false, it will only locally
revert the associated subflow)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Further arguments are interpreted as defined in the
<a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">Atom</span></code></a> constructor.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.retry.ForEach">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">ForEach</code><span class="sig-paren">(</span><em>values</em>, <em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>revert_all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#ForEach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.ForEach" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">taskflow.retry.ForEachBase</span></code></p>
<p>Applies a statically provided collection of strategies.</p>
<p>Accepts a collection of decision strategies on construction and returns the
next element of the collection on each try.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>values</strong> (<em>list</em>) &#8211; values collection to iterate over and provide to
atoms other in the flow as a result of this functions
<a class="reference internal" href="#taskflow.atom.Atom.execute" title="taskflow.atom.Atom.execute"><code class="xref py py-meth docutils literal"><span class="pre">execute()</span></code></a> method, which
other dependent atoms can consume (for example, to alter
their own behavior)</li>
<li><strong>revert_all</strong> (<em>bool</em>) &#8211; when provided this will cause the full flow to revert
when the number of attempts that have been tried
has been reached (when false, it will only locally
revert the associated subflow)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Further arguments are interpreted as defined in the
<a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">Atom</span></code></a> constructor.</p>
</dd></dl>

<dl class="class">
<dt id="taskflow.retry.ParameterizedForEach">
<em class="property">class </em><code class="descclassname">taskflow.retry.</code><code class="descname">ParameterizedForEach</code><span class="sig-paren">(</span><em>name=None</em>, <em>provides=None</em>, <em>requires=None</em>, <em>auto_extract=True</em>, <em>rebind=None</em>, <em>revert_all=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/taskflow/retry.html#ParameterizedForEach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#taskflow.retry.ParameterizedForEach" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">taskflow.retry.ForEachBase</span></code></p>
<p>Applies a dynamically provided collection of strategies.</p>
<p>Accepts a collection of decision strategies from a predecessor (or from
storage) as a parameter and returns the next element of that collection on
each try.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>revert_all</strong> (<em>bool</em>) &#8211; when provided this will cause the full flow to revert
when the number of attempts that have been tried
has been reached (when false, it will only locally
revert the associated subflow)</td>
</tr>
</tbody>
</table>
<p>Further arguments are interpreted as defined in the
<a class="reference internal" href="#taskflow.atom.Atom" title="taskflow.atom.Atom"><code class="xref py py-class docutils literal"><span class="pre">Atom</span></code></a> constructor.</p>
</dd></dl>

</div>
<div class="section" id="hierarchy">
<h2>Hierarchy<a class="headerlink" href="#hierarchy" title="Permalink to this headline">¶</a></h2>
<p class="graphviz">
<img src="_images/inheritance-d05f5f5dbfcdfce8a3cfcbc0f42a9f137b3658af.png" alt="Inheritance diagram of taskflow.atom, taskflow.task, taskflow.retry.Retry, taskflow.retry.AlwaysRevert, taskflow.retry.AlwaysRevertAll, taskflow.retry.Times, taskflow.retry.ForEach, taskflow.retry.ParameterizedForEach" usemap="#inheritance123a5f2cd3" class="inheritance"/>
<map id="inheritance123a5f2cd3" name="inheritance123a5f2cd3">
<area shape="rect" id="node1" href="#taskflow.retry.AlwaysRevert" target="_top" title="Retry that always reverts subflow." alt="" coords="264,5,369,31"/>
<area shape="rect" id="node2" href="#taskflow.retry.Retry" target="_top" title="A class that can decide how to resolve execution failures." alt="" coords="125,104,197,129"/>
<area shape="rect" id="node3" href="#taskflow.retry.AlwaysRevertAll" target="_top" title="Retry that always reverts a whole flow." alt="" coords="257,55,377,80"/>
<area shape="rect" id="node6" title="Base class for retries that iterate over a given collection." alt="" coords="264,104,369,129"/>
<area shape="rect" id="node12" href="#taskflow.retry.Times" target="_top" title="Retries subflow given number of times. Returns attempt number." alt="" coords="281,153,353,179"/>
<area shape="rect" id="node4" href="#taskflow.atom.Atom" target="_top" title="An unit of work that causes a flow to progress (in some manner)." alt="" coords="5,155,77,180"/>
<area shape="rect" id="node8" href="#taskflow.task.Task" target="_top" title="An abstraction that defines a potential piece of work." alt="" coords="125,228,197,253"/>
<area shape="rect" id="node5" href="#taskflow.retry.ForEach" target="_top" title="Applies a statically provided collection of strategies." alt="" coords="483,80,556,105"/>
<area shape="rect" id="node10" href="#taskflow.retry.ParameterizedForEach" target="_top" title="Applies a dynamically provided collection of strategies." alt="" coords="436,129,603,155"/>
<area shape="rect" id="node7" href="#taskflow.task.FunctorTask" target="_top" title="Adaptor to make a task from a callable." alt="" coords="269,203,365,228"/>
<area shape="rect" id="node9" href="#taskflow.task.MapFunctorTask" target="_top" title="General purpose Task to map a function to a list." alt="" coords="255,252,378,277"/>
<area shape="rect" id="node11" href="#taskflow.task.ReduceFunctorTask" target="_top" title="General purpose Task to reduce a list by applying a function." alt="" coords="245,301,388,327"/>
</map>
</p>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Atoms, tasks and retries</a><ul>
<li><a class="reference internal" href="#atom">Atom</a></li>
<li><a class="reference internal" href="#task">Task</a></li>
<li><a class="reference internal" href="#retry">Retry</a><ul>
<li><a class="reference internal" href="#area-of-influence">Area of influence</a></li>
<li><a class="reference internal" href="#usage-examples">Usage examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-taskflow.task">Interfaces</a></li>
<li><a class="reference internal" href="#hierarchy">Hierarchy</a></li>
</ul>
</li>
</ul>

  <h3>Navigation</h3>
  <ul>

    <li><a href="index.html">Table Of Contents</a></li>


    <li><a href="arguments_and_results.html" title="next chapter">Next topic: Arguments and results</a></li>


    <li><a href="index.html" title="previous chapter">Previous topic: TaskFlow</a></li>

  </ul>

            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/taskflow
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/atoms.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="arguments_and_results.html" title="Arguments and results"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="TaskFlow"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TaskFlow 2.9.1.dev5 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, OpenStack Foundation.
      Last updated on &#39;Fri Feb 10 20:11:01 2017, commit b7e2fcd&#39;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/TaskFlow");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>