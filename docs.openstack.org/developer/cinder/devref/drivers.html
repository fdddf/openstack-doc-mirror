<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Drivers &mdash; cinder 10.0.0.0rc2.dev76 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '10.0.0.0rc2.dev76',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="cinder 10.0.0.0rc2.dev76 documentation" href="../index.html" />
    <link rel="up" title="Developer Guide" href="index.html" />
    <link rel="next" title="Guru Meditation Reports" href="gmr.html" />
    <link rel="prev" title="Adding a Method to the OpenStack API" href="addmethod.openstackapi.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="drivers">
<h1>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h1>
<p>Cinder exposes an API to users to interact with different storage backend
solutions. The following are standards across all drivers for Cinder services
to properly interact with a driver.</p>
<div class="section" id="basic-attributes">
<h2>Basic attributes<a class="headerlink" href="#basic-attributes" title="Permalink to this headline">¶</a></h2>
<p>There are some basic attributes that all drivers classes should have:</p>
<ul class="simple">
<li>VERSION: Driver version in string format.  No naming convention is imposed,
although semantic versioning is recommended.</li>
<li>CI_WIKI_NAME: Must be the exact name of the <a class="reference external" href="https://wiki.openstack.org/wiki/ThirdPartySystems">ThirdPartySystems wiki page</a>. This is used by our
tooling system to associate jobs to drivers and track their CI reporting
status correctly.</li>
</ul>
<p>The tooling system will also use the name and docstring of the driver class.</p>
</div>
<div class="section" id="minimum-features">
<h2>Minimum Features<a class="headerlink" href="#minimum-features" title="Permalink to this headline">¶</a></h2>
<p>Minimum features are enforced to avoid having a grid of what features are
supported by which drivers and which releases. Cinder Core requires that all
drivers implement the following minimum features.</p>
</div>
<div class="section" id="core-functionality">
<h2>Core Functionality<a class="headerlink" href="#core-functionality" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Volume Create/Delete</li>
<li>Volume Attach/Detach</li>
<li>Snapshot Create/Delete</li>
<li>Create Volume from Snapshot</li>
<li>Get Volume Stats</li>
<li>Copy Image to Volume</li>
<li>Copy Volume to Image</li>
<li>Clone Volume</li>
<li>Extend Volume</li>
</ul>
</div>
<div class="section" id="volume-stats">
<h2>Volume Stats<a class="headerlink" href="#volume-stats" title="Permalink to this headline">¶</a></h2>
<p>Volume stats are used by the different schedulers for the drivers to provide
a report on their current state of the backend. The following should be
provided by a driver.</p>
<ul class="simple">
<li>driver_version</li>
<li>free_capacity_gb</li>
<li>storage_protocol</li>
<li>total_capacity_gb</li>
<li>vendor_name</li>
<li>volume_backend_name</li>
</ul>
<p><strong>NOTE:</strong> If the driver is unable to provide a value for free_capacity_gb or
total_capacity_gb, keywords can be provided instead. Please use &#8216;unknown&#8217; if
the backend cannot report the value or &#8216;infinite&#8217; if the backend has no upper
limit. But, it is recommended to report real values as the Cinder scheduler
assigns lowest weight to any storage backend reporting &#8216;unknown&#8217; or &#8216;infinite&#8217;.</p>
</div>
<div class="section" id="feature-enforcement">
<h2>Feature Enforcement<a class="headerlink" href="#feature-enforcement" title="Permalink to this headline">¶</a></h2>
<p>All concrete driver implementations should use the
<code class="docutils literal"><span class="pre">cinder.interface.volumedriver</span></code> decorator on the driver class:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>@interface.volumedriver
class LVMVolumeDriver(driver.VolumeDriver):
</pre></div>
</div>
<p>This will register the driver and allow automated compliance tests to run
against and verify the compliance of the driver against the required interface
to support the <a class="reference internal" href="#core-functionality">Core Functionality</a> listed above.</p>
<p>Running <code class="docutils literal"><span class="pre">tox</span> <span class="pre">-e</span> <span class="pre">compliance</span></code> will verify all registered drivers comply to
this interface. This can be used during development to perform self checks
along the way. Any missing method calls will be identified by the compliance
tests.</p>
<p>The details for the required volume driver interfaces can be found in the
<code class="docutils literal"><span class="pre">cinder/interface/volume_*_driver.py</span></code> source.</p>
</div>
<div class="section" id="driver-development-documentations">
<h2>Driver Development Documentations<a class="headerlink" href="#driver-development-documentations" title="Permalink to this headline">¶</a></h2>
<p>The LVM driver is our reference for all new driver implementations. The
information below can provide additional documentation for the methods that
volume drivers need to implement.</p>
<div class="section" id="base-driver-interface">
<h3>Base Driver Interface<a class="headerlink" href="#base-driver-interface" title="Permalink to this headline">¶</a></h3>
<p>The methods documented below are the minimum required interface for a volume
driver to support. All methods from this interface must be implemented
in order to be an official Cinder volume driver.</p>
<span class="target" id="module-cinder.interface.volume_driver"></span><p>Core backend volume driver interface.</p>
<p>All backend drivers should support this interface as a bare minimum.</p>
<dl class="class">
<dt id="cinder.interface.volume_driver.VolumeDriverCore">
<em class="property">class </em><code class="descname">VolumeDriverCore</code><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Core backend driver required interface.</p>
<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.attach_volume">
<code class="descname">attach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>instance_uuid</em>, <em>host_name</em>, <em>mountpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.attach_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Lets the driver know Nova has attached the volume to an instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; Security/policy info for the request.</li>
<li><strong>volume</strong> &#8211; Volume being attached.</li>
<li><strong>instance_uuid</strong> &#8211; ID of the instance being attached to.</li>
<li><strong>host_name</strong> &#8211; The host name.</li>
<li><strong>mountpoint</strong> &#8211; Device mount point on the instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.check_for_setup_error">
<code class="descname">check_for_setup_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.check_for_setup_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate there are no issues with the driver configuration.</p>
<p>Called after do_setup(). Driver initialization can occur there or in
this call, but must be complete by the time this returns.</p>
<p>If this method raises an exception, the driver will be left in an
&#8220;uninitialized&#8221; state by the volume manager, which means that it will
not be sent requests for volume operations.</p>
<p>This method typically checks things like whether the configured
credentials can be used to log in the storage backend, and whether any
external dependencies are present and working.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">VolumeBackendAPIException in case of setup error.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.clone_image">
<code class="descname">clone_image</code><span class="sig-paren">(</span><em>volume</em>, <em>image_location</em>, <em>image_id</em>, <em>image_metadata</em>, <em>image_service</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.clone_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an image to a volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; The volume to create.</li>
<li><strong>image_location</strong> &#8211; Where to pull the image from.</li>
<li><strong>image_id</strong> &#8211; The image identifier.</li>
<li><strong>image_metadata</strong> &#8211; Information about the image.</li>
<li><strong>image_service</strong> &#8211; The image service to use.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Model updates.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.copy_image_to_volume">
<code class="descname">copy_image_to_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_service</em>, <em>image_id</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.copy_image_to_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch the image from image_service and write it to the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; Security/policy info for the request.</li>
<li><strong>volume</strong> &#8211; The volume to create.</li>
<li><strong>image_service</strong> &#8211; The image service to use.</li>
<li><strong>image_id</strong> &#8211; The image identifier.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Model updates.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.copy_volume_to_image">
<code class="descname">copy_volume_to_image</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_service</em>, <em>image_meta</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.copy_volume_to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the volume to the specified image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; Security/policy info for the request.</li>
<li><strong>volume</strong> &#8211; The volume to copy.</li>
<li><strong>image_service</strong> &#8211; The image service to use.</li>
<li><strong>image_meta</strong> &#8211; Information about the image.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Model updates.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.create_volume">
<code class="descname">create_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.create_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new volume on the backend.</p>
<p>This method is responsible only for storage allocation on the backend.
It should not export a LUN or actually make this storage available for
use, this is done in a later call.</p>
<p># TODO(smcginnis) - Add example data structure of volume object.
:param volume: Volume object containing specifics to create.
:returns: (Optional) dict of database updates for the new volume.
:raises: VolumeBackendAPIException if creation failed.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.delete_volume">
<code class="descname">delete_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.delete_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a volume from the backend.</p>
<p>If the driver can talk to the backend and detects that the volume is no
longer present, this call should succeed and allow Cinder to complete
the process of deleting the volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>volume</strong> &#8211; The volume to delete.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">VolumeIsBusy if the volume is still attached or has snapshots.
VolumeBackendAPIException on error.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.detach_volume">
<code class="descname">detach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>attachment=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.detach_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Detach volume from an instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; Security/policy info for the request.</li>
<li><strong>volume</strong> &#8211; Volume being detached.</li>
<li><strong>attachment</strong> &#8211; (Optional) Attachment information.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.do_setup">
<code class="descname">do_setup</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.do_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Any initialization the volume driver needs to do while starting.</p>
<p>Called once by the manager after the driver is loaded.
Can be used to set up clients, check licenses, set up protocol
specific helpers, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; The admin context.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.extend_volume">
<code class="descname">extend_volume</code><span class="sig-paren">(</span><em>volume</em>, <em>new_size</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.extend_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the size of a volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> &#8211; The volume to extend.</li>
<li><strong>new_size</strong> &#8211; The new desired size of the volume.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.get_volume_stats">
<code class="descname">get_volume_stats</code><span class="sig-paren">(</span><em>refresh=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.get_volume_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects volume backend stats.</p>
<p>The get_volume_stats method is used by the volume manager to collect
information from the driver instance related to information about the
driver, available and used space, and driver/backend capabilities.</p>
<p>It returns a dict with the following required fields:</p>
<ul>
<li><dl class="first docutils">
<dt>volume_backend_name</dt>
<dd><p class="first last">This is an identifier for the backend taken from cinder.conf.
Useful when using multi-backend.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>vendor_name</dt>
<dd><p class="first last">Vendor/author of the driver who serves as the contact for the
driver&#8217;s development and support.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>driver_version</dt>
<dd><p class="first last">The driver version is logged at cinder-volume startup and is useful
for tying volume service logs to a specific release of the code.
There are currently no rules for how or when this is updated, but
it tends to follow typical major.minor.revision ideas.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>storage_protocol</dt>
<dd><p class="first last">The protocol used to connect to the storage, this should be a short
string such as: &#8220;iSCSI&#8221;, &#8220;FC&#8221;, &#8220;nfs&#8221;, &#8220;ceph&#8221;, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>total_capacity_gb</dt>
<dd><p class="first last">The total capacity in gigabytes (GiB) of the storage backend being
used to store Cinder volumes. Use keyword &#8216;unknown&#8217; if the backend
cannot report the value or &#8216;infinite&#8217; if there is no upper limit.
But, it is recommended to report real values as the Cinder
scheduler assigns lowest weight to any storage backend reporting
&#8216;unknown&#8217; or &#8216;infinite&#8217;.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>free_capacity_gb</dt>
<dd><p class="first last">The free capacity in gigabytes (GiB). Use keyword &#8216;unknown&#8217; if the
backend cannot report the value or &#8216;infinite&#8217; if there is no upper
limit. But, it is recommended to report real values as the Cinder
scheduler assigns lowest weight to any storage backend reporting
&#8216;unknown&#8217; or &#8216;infinite&#8217;.</p>
</dd>
</dl>
</li>
</ul>
<p>And the following optional fields:</p>
<ul>
<li><dl class="first docutils">
<dt>reserved_percentage (integer)</dt>
<dd><p class="first last">Percentage of backend capacity which is not used by the scheduler.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>location_info (string)</dt>
<dd><p class="first last">Driver-specific information used by the driver and storage backend
to correlate Cinder volumes and backend LUNs/files.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>QoS_support (Boolean)</dt>
<dd><p class="first last">Whether the backend supports quality of service.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>provisioned_capacity_gb</dt>
<dd><p class="first last">The total provisioned capacity on the storage backend, in gigabytes
(GiB), including space consumed by any user other than Cinder
itself.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>max_over_subscription_ratio</dt>
<dd><p class="first last">The maximum amount a backend can be over subscribed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>thin_provisioning_support (Boolean)</dt>
<dd><p class="first last">Whether the backend is capable of allocating thinly provisioned
volumes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>thick_provisioning_support (Boolean)</dt>
<dd><p class="first last">Whether the backend is capable of allocating thick provisioned
volumes. (Typically True.)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>total_volumes (integer)</dt>
<dd><p class="first last">Total number of volumes on the storage backend. This can be used in
custom driver filter functions.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>filter_function (string)</dt>
<dd><p class="first">A custom function used by the scheduler to determine whether a
volume should be allocated to this backend or not. Example:</p>
<blockquote class="last">
<div><p>capabilities.total_volumes &lt; 10</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>goodness_function (string)</dt>
<dd><p class="first">Similar to filter_function, but used to weigh multiple volume
backends. Example:</p>
<blockquote class="last">
<div><p>capabilities.capacity_utilization &lt; 0.6 ? 100 : 25</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>multiattach (Boolean)</dt>
<dd><p class="first last">Whether the backend supports multiattach or not. Defaults to False.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sparse_copy_volume (Boolean)</dt>
<dd><p class="first last">Whether copies performed by the volume manager for operations such
as migration should attempt to preserve sparseness.</p>
</dd>
</dl>
</li>
</ul>
<p>The returned dict may also contain a list, &#8220;pools&#8221;, which has a similar
dict for each pool being used with the backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>refresh</strong> &#8211; Whether to discard any cached values and force a full
refresh of stats.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dict of appropriate values (see above).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.initialize_connection">
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em>, <em>initiator_data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.initialize_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow connection to connector and return connection info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; The volume to be attached.</li>
<li><strong>connector</strong> &#8211; Dictionary containing information about what is being
connected to.</li>
<li><strong>initiator_data</strong> &#8211; (Optional) A dictionary of driver_initiator_data
objects with key-value pairs that have been
saved for this initiator by a driver in previous
initialize_connection calls.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dictionary of connection information. This can optionally
include a &#8220;initiator_updates&#8221; field.</p>
</td>
</tr>
</tbody>
</table>
<p>The &#8220;initiator_updates&#8221; field must be a dictionary containing a
&#8220;set_values&#8221; and/or &#8220;remove_values&#8221; field. The &#8220;set_values&#8221; field must
be a dictionary of key-value pairs to be set/updated in the db. The
&#8220;remove_values&#8221; field must be a list of keys, previously set with
&#8220;set_values&#8221;, that will be deleted from the db.</p>
<p>May be called multiple times to get connection information after a
volume has already been attached.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_driver.VolumeDriverCore.terminate_connection">
<code class="descname">terminate_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_driver.VolumeDriverCore.terminate_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove access to a volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> &#8211; The volume to remove.</li>
<li><strong>connector</strong> &#8211; The Dictionary containing information about the
connection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="snapshot-interface">
<h3>Snapshot Interface<a class="headerlink" href="#snapshot-interface" title="Permalink to this headline">¶</a></h3>
<p>Another required interface for a volume driver to be fully compatible is the
ability to create and manage snapshots. Due to legacy constraints, this
interface is not included in the base driver interface above.</p>
<p>Work is being done to address those legacy issues. Once that is complete, this
interface will be merged with the base driver interface.</p>
<span class="target" id="module-cinder.interface.volume_snapshot_driver"></span><p>Snapshot capable volume driver interface.</p>
<dl class="class">
<dt id="cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver">
<em class="property">class </em><code class="descname">VolumeSnapshotDriver</code><a class="headerlink" href="#cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for drivers that support snapshots.</p>
<p>TODO(smcginnis) Merge into VolumeDriverBase once NFS driver supports
snapshots.</p>
<dl class="method">
<dt id="cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.create_snapshot">
<code class="descname">create_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.create_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>snapshot</strong> &#8211; Information for the snapshot to be created.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.create_volume_from_snapshot">
<code class="descname">create_volume_from_snapshot</code><span class="sig-paren">(</span><em>volume</em>, <em>snapshot</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.create_volume_from_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a volume from a snapshot.</p>
<p>If volume_type extra specs includes &#8216;replication: &lt;is&gt; True&#8217;
the driver needs to create a volume replica (secondary),
and setup replication between the newly created volume and
the secondary volume.</p>
<p>An optional larger size for the new snapshot can be specified. Drivers
should check this value and create or expand the new volume to match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; The volume to be created.</li>
<li><strong>snapshot</strong> &#8211; The snapshot from which to create the volume.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dict of database updates for the new volume.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.delete_snapshot">
<code class="descname">delete_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshot_driver.VolumeSnapshotDriver.delete_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>snapshot</strong> &#8211; The snapshot to delete.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="manage-unmanage-support">
<h3>Manage/Unmanage Support<a class="headerlink" href="#manage-unmanage-support" title="Permalink to this headline">¶</a></h3>
<p>An optional feature a volume backend can support is the ability to manage
existing volumes or unmanage volumes - keep the volume on the storage backend
but no longer manage it through Cinder.</p>
<p>To support this functionality, volume drivers must implement these methods:</p>
<span class="target" id="module-cinder.interface.volume_management_driver"></span><p>Manage/unmanage existing volume driver interface.</p>
<dl class="class">
<dt id="cinder.interface.volume_management_driver.VolumeManagementDriver">
<em class="property">class </em><code class="descname">VolumeManagementDriver</code><a class="headerlink" href="#cinder.interface.volume_management_driver.VolumeManagementDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for drivers that support managing existing volumes.</p>
<dl class="method">
<dt id="cinder.interface.volume_management_driver.VolumeManagementDriver.manage_existing">
<code class="descname">manage_existing</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_management_driver.VolumeManagementDriver.manage_existing" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings an existing backend storage object under Cinder management.</p>
<p>existing_ref is passed straight through from the API request&#8217;s
manage_existing_ref value, and it is up to the driver how this should
be interpreted.  It should be sufficient to identify a storage object
that the driver should somehow associate with the newly-created cinder
volume structure.</p>
<p>There are two ways to do this:</p>
<ol class="arabic simple">
<li>Rename the backend storage object so that it matches the,
volume[&#8216;name&#8217;] which is how drivers traditionally map between a
cinder volume and the associated backend storage object.</li>
<li>Place some metadata on the volume, or somewhere in the backend, that
allows other driver requests (e.g. delete, clone, attach, detach...)
to locate the backend storage object when required.</li>
</ol>
<p>If the existing_ref doesn&#8217;t make sense, or doesn&#8217;t refer to an existing
backend storage object, raise a ManageExistingInvalidReference
exception.</p>
<p>The volume may have a volume_type, and the driver can inspect that and
compare against the properties of the referenced backend storage
object.  If they are incompatible, raise a
ManageExistingVolumeTypeMismatch, specifying a reason for the failure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; Cinder volume to manage</li>
<li><strong>existing_ref</strong> &#8211; Dictionary with keys &#8216;source-id&#8217;, &#8216;source-name&#8217;
with driver-specific values to identify a backend
storage object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">ManageExistingInvalidReference If the existing_ref doesn&#8217;t
make sense, or doesn&#8217;t refer to an existing backend storage
object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ManageExistingVolumeTypeMismatch If there is a mismatch
between the volume type and the properties of the existing
backend storage object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_management_driver.VolumeManagementDriver.manage_existing_get_size">
<code class="descname">manage_existing_get_size</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_management_driver.VolumeManagementDriver.manage_existing_get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return size of volume to be managed by manage_existing.</p>
<p>When calculating the size, round up to the next GB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; Cinder volume to manage</li>
<li><strong>existing_ref</strong> &#8211; Dictionary with keys &#8216;source-id&#8217;, &#8216;source-name&#8217;
with driver-specific values to identify a backend
storage object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ManageExistingInvalidReference If the existing_ref doesn&#8217;t
make sense, or doesn&#8217;t refer to an existing backend storage
object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_management_driver.VolumeManagementDriver.unmanage">
<code class="descname">unmanage</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_management_driver.VolumeManagementDriver.unmanage" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the specified volume from Cinder management.</p>
<p>Does not delete the underlying backend storage object.</p>
<p>For most drivers, this will not need to do anything.  However, some
drivers might use this call as an opportunity to clean up any
Cinder-specific configuration that they have associated with the
backend storage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>volume</strong> &#8211; Cinder volume to unmanage</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="manage-unmanage-snapshot-support">
<h3>Manage/Unmanage Snapshot Support<a class="headerlink" href="#manage-unmanage-snapshot-support" title="Permalink to this headline">¶</a></h3>
<p>In addition to the ability to manage and unmanage volumes, Cinder backend
drivers may also support managing and unmanaging volume snapshots. These
additional methods must be implemented to support these operations.</p>
<span class="target" id="module-cinder.interface.volume_snapshotmanagement_driver"></span><p>Manage/unmanage existing volume snapshots driver interface.</p>
<dl class="class">
<dt id="cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver">
<em class="property">class </em><code class="descname">VolumeSnapshotManagementDriver</code><a class="headerlink" href="#cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for drivers that support managing existing snapshots.</p>
<dl class="method">
<dt id="cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.manage_existing_snapshot">
<code class="descname">manage_existing_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.manage_existing_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Brings an existing backend storage object under Cinder management.</p>
<p>existing_ref is passed straight through from the API request&#8217;s
manage_existing_ref value, and it is up to the driver how this should
be interpreted.  It should be sufficient to identify a storage object
that the driver should somehow associate with the newly-created cinder
snapshot structure.</p>
<p>There are two ways to do this:</p>
<ol class="arabic simple">
<li>Rename the backend storage object so that it matches the
snapshot[&#8216;name&#8217;] which is how drivers traditionally map between a
cinder snapshot and the associated backend storage object.</li>
<li>Place some metadata on the snapshot, or somewhere in the backend,
that allows other driver requests (e.g. delete) to locate the
backend storage object when required.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>snapshot</strong> &#8211; The snapshot to manage.</li>
<li><strong>existing_ref</strong> &#8211; Dictionary with keys &#8216;source-id&#8217;, &#8216;source-name&#8217;
with driver-specific values to identify a backend
storage object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ManageExistingInvalidReference If the existing_ref doesn&#8217;t
make sense, or doesn&#8217;t refer to an existing backend storage
object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.manage_existing_snapshot_get_size">
<code class="descname">manage_existing_snapshot_get_size</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.manage_existing_snapshot_get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return size of snapshot to be managed by manage_existing.</p>
<p>When calculating the size, round up to the next GB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>snapshot</strong> &#8211; The snapshot to manage.</li>
<li><strong>existing_ref</strong> &#8211; Dictionary with keys &#8216;source-id&#8217;, &#8216;source-name&#8217;
with driver-specific values to identify a backend
storage object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ManageExistingInvalidReference If the existing_ref doesn&#8217;t
make sense, or doesn&#8217;t refer to an existing backend storage
object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.unmanage_snapshot">
<code class="descname">unmanage_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_snapshotmanagement_driver.VolumeSnapshotManagementDriver.unmanage_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the specified snapshot from Cinder management.</p>
<p>Does not delete the underlying backend storage object.</p>
<p>For most drivers, this will not need to do anything. However, some
drivers might use this call as an opportunity to clean up any
Cinder-specific configuration that they have associated with the
backend storage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>snapshot</strong> &#8211; The snapshot to unmanage.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="volume-consistency-groups">
<h3>Volume Consistency Groups<a class="headerlink" href="#volume-consistency-groups" title="Permalink to this headline">¶</a></h3>
<p>Some storage backends support the ability to group volumes and create write
consistent snapshots across the group. In order to support these operations,
the following interface must be implemented by the driver.</p>
<span class="target" id="module-cinder.interface.volume_consistencygroup_driver"></span><p>Consistency group volume driver interface.</p>
<dl class="class">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver">
<em class="property">class </em><code class="descname">VolumeConsistencyGroupDriver</code><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for drivers that support consistency groups.</p>
<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_cgsnapshot">
<code class="descname">create_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em>, <em>snapshots</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_cgsnapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a cgsnapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot to be created.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
assigned to snapshots_model_update. snapshots_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is &#8216;error&#8217;, the
status in model_update will be set to the same if it is not already
&#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will raise an
exception and the status of cgsnapshot will be set to &#8216;error&#8217; in the
db. If snapshots_model_update is not returned by the driver, the
manager will set the status of every snapshot to &#8216;error&#8217; in the except
block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
cgsnapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of cgsnapshot and all snapshots
will be set to &#8216;available&#8217; at the end of the manager function.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_consistencygroup">
<code class="descname">create_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_consistencygroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a consistencygroup.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be created.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will throw
an exception and it will be caught in the try-except block in the
manager. If the driver throws an exception, the manager will also
catch it in the try-except block. The group status in the db will
be changed to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and return it or return None. The group status will
be set to &#8216;available&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_consistencygroup_from_src">
<code class="descname">create_consistencygroup_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em>, <em>cgsnapshot=None</em>, <em>snapshots=None</em>, <em>source_cg=None</em>, <em>source_vols=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.create_consistencygroup_from_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a consistencygroup from source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be created.</li>
<li><strong>volumes</strong> &#8211; a list of volume dictionaries in the group.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot as source.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
<li><strong>source_cg</strong> &#8211; the dictionary of a consistency group as source.</li>
<li><strong>source_vols</strong> &#8211; a list of volume dictionaries in the source_cg.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>The source can be cgsnapshot or a source cg.</p>
<p>param volumes is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
assigned to volumes_model_update. volumes_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>To be consistent with other volume operations, the manager will
assume the operation is successful if no exception is thrown by
the driver. For a successful operation, the driver can either build
the model_update and volumes_model_update and return them or
return None, None.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.delete_cgsnapshot">
<code class="descname">delete_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em>, <em>snapshots</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.delete_cgsnapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a cgsnapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot to be deleted.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
assigned to snapshots_model_update. snapshots_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is
&#8216;error_deleting&#8217; or &#8216;error&#8217;, the status in model_update will be set to
the same if it is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of cgsnapshot will be
set to &#8216;error&#8217; in the db. If snapshots_model_update is not returned by
the driver, the manager will set the status of every snapshot to
&#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
cgsnapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of cgsnapshot and all snapshots
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.delete_consistencygroup">
<code class="descname">delete_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.delete_consistencygroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a consistency group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be deleted.</li>
<li><strong>volumes</strong> &#8211; a list of volume dictionaries in the group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param volumes is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
assigned to volumes_model_update. volumes_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate volumes_model_update and model_update
and return them.</p>
<p>The manager will check volumes_model_update and update db accordingly
for each volume. If the driver successfully deleted some volumes
but failed to delete others, it should set statuses of the volumes
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of volumes_model_update is &#8216;error_deleting&#8217;
or &#8216;error&#8217;, the status in model_update will be set to the same if it
is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of the group will be
set to &#8216;error&#8217; in the db. If volumes_model_update is not returned by
the driver, the manager will set the status of every volume in the
group to &#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager. The statuses of the
group and all volumes in it will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and volumes_model_update and return them or
return None, None. The statuses of the group and all volumes
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.update_consistencygroup">
<code class="descname">update_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_consistencygroup_driver.VolumeConsistencyGroupDriver.update_consistencygroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates a consistency group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be updated.</li>
<li><strong>add_volumes</strong> &#8211; a list of volume dictionaries to be added.</li>
<li><strong>remove_volumes</strong> &#8211; a list of volume dictionaries to be removed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, add_volumes_update, remove_volumes_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update is a dictionary that the driver wants the manager
to update upon a successful return. If None is returned, the manager
will set the status to &#8216;available&#8217;.</p>
<p>add_volumes_update and remove_volumes_update are lists of dictionaries
that the driver wants the manager to update upon a successful return.
Note that each entry requires a {&#8216;id&#8217;: xxx} so that the correct
volume entry can be updated. If None is returned, the volume will
remain its original status. Also note that you cannot directly
assign add_volumes to add_volumes_update as add_volumes is a list of
cinder.db.sqlalchemy.models.Volume objects and cannot be used for
db update directly. Same with remove_volumes.</p>
<p>If the driver throws an exception, the status of the group as well as
those of the volumes to be added/removed will be set to &#8216;error&#8217;.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="generic-volume-groups">
<h3>Generic Volume Groups<a class="headerlink" href="#generic-volume-groups" title="Permalink to this headline">¶</a></h3>
<p>The generic volume groups feature provides the ability to manage a group of
volumes together. Because this feature is implemented at the manager level,
every driver gets this feature by default. If a driver wants to override
the default behavior to support additional functionalities such as consistent
group snapshot, the following interface must be implemented by the driver.
Once every driver supporting volume consistency groups has added the
consistent group snapshot capability to generic volume groups, we no longer
need the volume consistency groups interface listed above.</p>
<span class="target" id="module-cinder.interface.volume_group_driver"></span><p>Generic volume group volume driver interface.</p>
<dl class="class">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver">
<em class="property">class </em><code class="descname">VolumeGroupDriver</code><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface for drivers that support groups.</p>
<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.create_group">
<code class="descname">create_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.create_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object to be created.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will throw
an exception and it will be caught in the try-except block in the
manager. If the driver throws an exception, the manager will also
catch it in the try-except block. The group status in the db will
be changed to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and return it or return None. The group status will
be set to &#8216;available&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.create_group_from_src">
<code class="descname">create_group_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em>, <em>group_snapshot=None</em>, <em>snapshots=None</em>, <em>source_group=None</em>, <em>source_vols=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.create_group_from_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a group from source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object to be created.</li>
<li><strong>volumes</strong> &#8211; a list of Volume objects in the group.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object as source.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in the group_snapshot.</li>
<li><strong>source_group</strong> &#8211; a Group object as source.</li>
<li><strong>source_vols</strong> &#8211; a list of Volume objects in the source_group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>The source can be group_snapshot or a source group.</p>
<p>param volumes is a list of objects retrieved from the db. It cannot
be assigned to volumes_model_update. volumes_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>To be consistent with other volume operations, the manager will
assume the operation is successful if no exception is thrown by
the driver. For a successful operation, the driver can either build
the model_update and volumes_model_update and return them or
return None, None.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.create_group_snapshot">
<code class="descname">create_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em>, <em>snapshots</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.create_group_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a group_snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object to be created.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in the group_snapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is a list of Snapshot objects. It cannot be assigned
to snapshots_model_update. snapshots_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is &#8216;error&#8217;, the
status in model_update will be set to the same if it is not already
&#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will raise an
exception and the status of group_snapshot will be set to &#8216;error&#8217; in
the db. If snapshots_model_update is not returned by the driver, the
manager will set the status of every snapshot to &#8216;error&#8217; in the except
block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
group_snapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of group_snapshot and all snapshots
will be set to &#8216;available&#8217; at the end of the manager function.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.delete_group">
<code class="descname">delete_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.delete_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object to be deleted.</li>
<li><strong>volumes</strong> &#8211; a list of Volume objects in the group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param volumes is a list of objects retrieved from the db. It cannot
be assigned to volumes_model_update. volumes_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate volumes_model_update and model_update
and return them.</p>
<p>The manager will check volumes_model_update and update db accordingly
for each volume. If the driver successfully deleted some volumes
but failed to delete others, it should set statuses of the volumes
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of volumes_model_update is &#8216;error_deleting&#8217;
or &#8216;error&#8217;, the status in model_update will be set to the same if it
is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of the group will be
set to &#8216;error&#8217; in the db. If volumes_model_update is not returned by
the driver, the manager will set the status of every volume in the
group to &#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager. The statuses of the
group and all volumes in it will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and volumes_model_update and return them or
return None, None. The statuses of the group and all volumes
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.delete_group_snapshot">
<code class="descname">delete_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em>, <em>snapshots</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.delete_group_snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a group_snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object to be deleted.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in the group_snapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is a list of objects. It cannot be assigned to
snapshots_model_update. snapshots_model_update is a list of of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is
&#8216;error_deleting&#8217; or &#8216;error&#8217;, the status in model_update will be set to
the same if it is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of group_snapshot will
be set to &#8216;error&#8217; in the db. If snapshots_model_update is not returned
by the driver, the manager will set the status of every snapshot to
&#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
group_snapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of group_snapshot and all snapshots
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt id="cinder.interface.volume_group_driver.VolumeGroupDriver.update_group">
<code class="descname">update_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cinder.interface.volume_group_driver.VolumeGroupDriver.update_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object to be updated.</li>
<li><strong>add_volumes</strong> &#8211; a list of Volume objects to be added.</li>
<li><strong>remove_volumes</strong> &#8211; a list of Volume objects to be removed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, add_volumes_update, remove_volumes_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update is a dictionary that the driver wants the manager
to update upon a successful return. If None is returned, the manager
will set the status to &#8216;available&#8217;.</p>
<p>add_volumes_update and remove_volumes_update are lists of dictionaries
that the driver wants the manager to update upon a successful return.
Note that each entry requires a {&#8216;id&#8217;: xxx} so that the correct
volume entry can be updated. If None is returned, the volume will
remain its original status. Also note that you cannot directly
assign add_volumes to add_volumes_update as add_volumes is a list of
volume objects and cannot be used for db update directly. Same with
remove_volumes.</p>
<p>If the driver throws an exception, the status of the group as well as
those of the volumes to be added/removed will be set to &#8216;error&#8217;.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Drivers</a><ul>
<li><a class="reference internal" href="#basic-attributes">Basic attributes</a></li>
<li><a class="reference internal" href="#minimum-features">Minimum Features</a></li>
<li><a class="reference internal" href="#core-functionality">Core Functionality</a></li>
<li><a class="reference internal" href="#volume-stats">Volume Stats</a></li>
<li><a class="reference internal" href="#feature-enforcement">Feature Enforcement</a></li>
<li><a class="reference internal" href="#driver-development-documentations">Driver Development Documentations</a><ul>
<li><a class="reference internal" href="#base-driver-interface">Base Driver Interface</a></li>
<li><a class="reference internal" href="#snapshot-interface">Snapshot Interface</a></li>
<li><a class="reference internal" href="#manage-unmanage-support">Manage/Unmanage Support</a></li>
<li><a class="reference internal" href="#manage-unmanage-snapshot-support">Manage/Unmanage Snapshot Support</a></li>
<li><a class="reference internal" href="#volume-consistency-groups">Volume Consistency Groups</a></li>
<li><a class="reference internal" href="#generic-volume-groups">Generic Volume Groups</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="addmethod.openstackapi.html"
                                  title="previous chapter">Adding a Method to the OpenStack API</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="gmr.html"
                                  title="next chapter">Guru Meditation Reports</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/cinder
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/devref/drivers.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gmr.html" title="Guru Meditation Reports"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="addmethod.openstackapi.html" title="Adding a Method to the OpenStack API"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">cinder 10.0.0.0rc2.dev76 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Developer Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2010-present, OpenStack Foundation.
      Last updated on Tue Feb 14 19:30:39 2017, commit 3c2819f.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/cinder");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>