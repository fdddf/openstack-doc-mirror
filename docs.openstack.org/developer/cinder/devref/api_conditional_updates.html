<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API Races - Conditional Updates &mdash; cinder 10.0.0.0rc2.dev76 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '10.0.0.0rc2.dev76',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="cinder 10.0.0.0rc2.dev76 documentation" href="../index.html" />
    <link rel="up" title="Developer Guide" href="index.html" />
    <link rel="next" title="REST API Version History" href="api_microversion_history.html" />
    <link rel="prev" title="API Microversions" href="api_microversion_dev.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="api-races-conditional-updates">
<h1>API Races - Conditional Updates<a class="headerlink" href="#api-races-conditional-updates" title="Permalink to this headline">¶</a></h1>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>On Cinder API nodes we have to check that requested action can be performed by
checking request arguments and involved resources, and only if everything
matches required criteria we will proceed with the RPC call to any of the other
nodes.</p>
<p>Checking the conditions must be done in a non racy way to ensure that already
checked requirements don&#8217;t change while we check remaining conditions.  This is
of utter importance, as Cinder uses resource status as a lock to prevent
concurrent operations on a resource.</p>
<p>An simple example of this would be extending a volume, where we first check the
status:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span>if volume[&#39;status&#39;] != &#39;available&#39;:
</pre></div>
</div>
<p>Then update the status:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;extending&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>And finally make the RPC call:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">volume_rpcapi</span><span class="o">.</span><span class="n">extend_volume</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span>
                                 <span class="n">reservations</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem is that this code would allow races, as other request could
have already changed the volume status between us getting the value and
updating the DB.</p>
<p>There are multiple ways to fix this, such as:</p>
<ul class="simple">
<li>Using a Distributed Locking Mechanism</li>
<li>Using DB isolation level</li>
<li>Using SQL SELECT ... FOR UPDATE</li>
<li>USING compare and swap mechanism in SQL query</li>
</ul>
<p>Our tests showed that the best alternative was compare and swap and we decided
to call this mechanism &#8220;Conditional Update&#8221; as it seemed more appropriate.</p>
</div>
<div class="section" id="conditional-update">
<h2>Conditional Update<a class="headerlink" href="#conditional-update" title="Permalink to this headline">¶</a></h2>
<p>Conditional Update is the mechanism we use in Cinder to prevent races when
updating the DB.  In essence it is the SQL equivalent of an <code class="docutils literal"><span class="pre">UPDATE</span> <span class="pre">...</span> <span class="pre">FROM</span>
<span class="pre">...</span> <span class="pre">WHERE;</span></code> clause</p>
<p>It is implemented as an abstraction layer on top of SQLAlchemy ORM engine in
our DB api layer and exposed for consumption in Cinder&#8217;s Persistent Versioned
Objects through the <code class="docutils literal"><span class="pre">conditional_update</span></code> method so it can be used from any
Versioned Object instance that has persistence (Volume, Snapshot, Backup...).</p>
<p>Method signature is:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span>def conditional_update(self, values, expected_values=None, filters=(),
                       save_all=False, session=None, reflect_changes=True):
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">values:</th><td class="field-body"><p class="first">Dictionary of key-value pairs with changes that we want to make to the
resource in the DB.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">expected_values:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">Dictionary with conditions that must be met for the update to be executed.</p>
<p>Condition <code class="docutils literal"><span class="pre">field.id</span> <span class="pre">==</span> <span class="pre">resource.id</span></code> is implicit and there is no need to add
it to the conditions.</p>
<p>If no <code class="docutils literal"><span class="pre">expected_values</span></code> argument is provided update will only go through if
no field in the DB has changed. Dirty fields from the Versioned Object are
excluded as we don&#8217;t know their original value.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">filters:</th><td class="field-body"><p class="first">Additional SQLAlchemy filters can be provided for more complex conditions.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">save_all:</th><td class="field-body"><p class="first">By default we will only be updating the DB with values provided in the
<code class="docutils literal"><span class="pre">values</span></code> argument, but we can explicitly say that we also want to save
object&#8217;s current dirty fields.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">session:</th><td class="field-body"><p class="first">A SQLAlchemy session can be provided, although it is unlikely to be needed.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">reflect_changes:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">On a successful update we will also update Versioned Object instance to
reflect these changes, but we can prevent this instance update passing False
on this argument.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return Value:</th><td class="field-body"><p class="first last">We&#8217;ll return the number of changed rows.  So we&#8217;ll get a 0 value if the
conditional update has not been successful instead of an exception.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="basic-usage">
<h2>Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><strong>Simple match</strong></p>
<p>The most basic example is doing a simple match, for example for a <code class="docutils literal"><span class="pre">volume</span></code>
variable that contains a Versioned Object Volume class instance we may want
to change the <code class="docutils literal"><span class="pre">status</span></code> to &#8220;deleting&#8221; and update the <code class="docutils literal"><span class="pre">terminated_at</span></code> field
with current UTC time only if current <code class="docutils literal"><span class="pre">status</span></code> is &#8220;available&#8221; and the
volume is not in a consistency group.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;terminated_at&#39;</span><span class="p">:</span> <span class="n">timeutils</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()}</span>
<span class="n">expected_values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;available&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;consistencygroup_id&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>

<span class="n">volume</span><span class="o">.</span><span class="n">conditional_update</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Iterable match</strong></p>
<p>Conditions can contain not only single values, but also iterables, and the
conditional update mechanism will correctly handle the presence of None
values in the range, unlike SQL <code class="docutils literal"><span class="pre">IN</span></code> clause that doesn&#8217;t support <code class="docutils literal"><span class="pre">NULL</span></code>
values.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;terminated_at&#39;</span><span class="p">:</span> <span class="n">timeutils</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()}</span>
<span class="n">expected_values</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;available&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error_restoring&#39;</span> <span class="s1">&#39;error_extending&#39;</span><span class="p">),</span>
    <span class="s1">&#39;migration_status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;success&#39;</span><span class="p">),</span>
    <span class="s1">&#39;consistencygroup_id&#39;</span><span class="p">:</span> <span class="bp">None</span>
<span class="p">}</span>

<span class="n">volume</span><span class="o">.</span><span class="n">conditional_update</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Exclusion</strong></p>
<p>In some cases we&#8217;ll need to set conditions on what is <em>not</em> in the DB record
instead of what is is, for that we will use the exclusion mechanism provided
by the <code class="docutils literal"><span class="pre">Not</span></code> class in all persistent objects.  This class accepts single
values as well as iterables.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;terminated_at&#39;</span><span class="p">:</span> <span class="n">timeutils</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()}</span>
<span class="n">expected_values</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;attach_status&#39;</span><span class="p">:</span> <span class="n">volume</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="s1">&#39;attached&#39;</span><span class="p">),</span>
    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;available&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error_restoring&#39;</span> <span class="s1">&#39;error_extending&#39;</span><span class="p">),</span>
    <span class="s1">&#39;migration_status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;success&#39;</span><span class="p">),</span>
    <span class="s1">&#39;consistencygroup_id&#39;</span><span class="p">:</span> <span class="bp">None</span>
<span class="p">}</span>

<span class="n">volume</span><span class="o">.</span><span class="n">conditional_update</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Filters</strong></p>
<p>We can use complex filters in the conditions, but these must be SQLAlchemy
queries/conditions and as the rest of the DB methods must be properly
abstracted from the API.</p>
<p>Therefore we will create the method in cinder/db/sqlalchemy/api.py:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">volume_has_snapshots_filter</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">and_</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">models</span><span class="o">.</span><span class="n">Snapshot</span><span class="o">.</span><span class="n">volume_id</span><span class="p">,</span>
             <span class="o">~</span><span class="n">models</span><span class="o">.</span><span class="n">Snapshot</span><span class="o">.</span><span class="n">deleted</span><span class="p">))</span>
</pre></div>
</div>
<p>Then expose this filter through the cinder/db/api.py:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">volume_has_snapshots_filter</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">IMPL</span><span class="o">.</span><span class="n">volume_has_snapshots_filter</span><span class="p">()</span>
</pre></div>
</div>
<p>And finally used in the API (notice how we are negating the filter at the
API):</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="o">~</span><span class="n">db</span><span class="o">.</span><span class="n">volume_has_snapshots_filter</span><span class="p">()]</span>
<span class="n">values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;terminated_at&#39;</span><span class="p">:</span> <span class="n">timeutils</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()}</span>
<span class="n">expected_values</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;attach_status&#39;</span><span class="p">:</span> <span class="n">volume</span><span class="o">.</span><span class="n">Not</span><span class="p">(</span><span class="s1">&#39;attached&#39;</span><span class="p">),</span>
    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;available&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;error_restoring&#39;</span> <span class="s1">&#39;error_extending&#39;</span><span class="p">),</span>
    <span class="s1">&#39;migration_status&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;deleting&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;success&#39;</span><span class="p">),</span>
    <span class="s1">&#39;consistencygroup_id&#39;</span><span class="p">:</span> <span class="bp">None</span>
<span class="p">}</span>

<span class="n">volume</span><span class="o">.</span><span class="n">conditional_update</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="returning-errors">
<h2>Returning Errors<a class="headerlink" href="#returning-errors" title="Permalink to this headline">¶</a></h2>
<p>The most important downside of using conditional updates to remove API races is
the inherent uncertainty of the cause of failure resulting in more generic
error messages.</p>
<p>When we use the <cite>conditional_update</cite> method we&#8217;ll use returned value to
determine the success of the operation, as a value of 0 indicates that no rows
have been updated and the conditions were not met.  But we don&#8217;t know which
one, or which ones, were the cause of the failure.</p>
<p>There are 2 approaches to this issue:</p>
<ul class="simple">
<li>On failure we go one by one checking the conditions and return the first one
that fails.</li>
<li>We return a generic error message indicating all conditions that must be met
for the operation to succeed.</li>
</ul>
<p>It was decided that we would go with the second approach, because even though
the first approach was closer to what we already had and would give a better
user experience, it had considerable implications such as:</p>
<ul class="simple">
<li>More code was needed to do individual checks making operations considerable
longer and less readable.  This was greatly alleviated using helper methods
to return the errors.</li>
<li>Higher number of DB queries required to determine failure cause.</li>
<li>Since there could be races because DB contents could be changed between the
failed update and the follow up queries that checked the values for the
specific error, a loop would be needed to make sure that either the
conditional update succeeds or one of the condition checks fails.</li>
<li>Having such a loop means that a small error in the code could lead to an
endless loop in a production environment.  This coding error could be an
incorrect conditional update filter that would always fail or a missing or
incorrect condition that checked for the specific issue to return the error.</li>
</ul>
<p>A simple example of a generic error can be found in <cite>begin_detaching</cite> code:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="nd">@wrap_check_policy</span>
<span class="k">def</span> <span class="nf">begin_detaching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">volume</span><span class="p">):</span>
    <span class="c1"># If we are in the middle of a volume migration, we don&#39;t want the</span>
    <span class="c1"># user to see that the volume is &#39;detaching&#39;. Having</span>
    <span class="c1"># &#39;migration_status&#39; set will have the same effect internally.</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;in-use&#39;</span><span class="p">,</span>
                <span class="s1">&#39;attach_status&#39;</span><span class="p">:</span> <span class="s1">&#39;attached&#39;</span><span class="p">,</span>
                <span class="s1">&#39;migration_status&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">AVAILABLE_MIGRATION_STATUS</span><span class="p">}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">conditional_update</span><span class="p">({</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;detaching&#39;</span><span class="p">},</span> <span class="n">expected</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_volume_migrating</span><span class="p">(</span><span class="n">volume</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">_</span><span class="p">(</span><span class="s2">&quot;Unable to detach volume. Volume status must be &#39;in-use&#39; &quot;</span>
                <span class="s2">&quot;and attach_status must be &#39;attached&#39; to detach.&quot;</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">exception</span><span class="o">.</span><span class="n">InvalidVolume</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="building-filters-on-the-api">
<h2>Building filters on the API<a class="headerlink" href="#building-filters-on-the-api" title="Permalink to this headline">¶</a></h2>
<p>SQLAlchemy filters created as mentioned above can create very powerful and
complex conditions, but sometimes we may require a condition that, while more
complex than the basic match and not match on the resource fields, it&#8217;s still
quite simple.  For those cases we can create filters directly on the API using
the <code class="docutils literal"><span class="pre">model</span></code> field provided in Versioned Objects.</p>
<p>This <code class="docutils literal"><span class="pre">model</span></code> field is a reference to the ORM model that allows us to
reference ORM fields.</p>
<p>We&#8217;ll use as an example changing the <code class="docutils literal"><span class="pre">status</span></code> field of a backup to
&#8220;restoring&#8221; if the backup status is &#8220;available&#8221; and the volume where we are
going to restore the backup is also in &#8220;available&#8221; state.</p>
<p>Joining of tables is implicit when using a model different from the one used
for the Versioned Object instance.</p>
<ul>
<li><p class="first"><strong>As expected_values</strong></p>
<p>Since this is a matching case we can use <code class="docutils literal"><span class="pre">expected_values</span></code> argument to make
the condition:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;restoring&#39;</span><span class="p">}</span>
<span class="n">expected_values</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;available&#39;</span><span class="p">,</span>
                 <span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">volume</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                 <span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">:</span> <span class="s1">&#39;available&#39;</span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>As filters</strong></p>
<p>We can also use the <code class="docutils literal"><span class="pre">filters</span></code> argument to achieve the same results:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">volume</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
           <span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;available&#39;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Other filters</strong></p>
<p>If we are not doing a match for the condition the only available option will
be to use <code class="docutils literal"><span class="pre">filters</span></code> argument.  For example if we want to do a check on the
volume size against the backup size:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">volume</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
           <span class="n">objects</span><span class="o">.</span><span class="n">Volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">backup</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="using-db-fields-for-assignment">
<h2>Using DB fields for assignment<a class="headerlink" href="#using-db-fields-for-assignment" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><strong>Using non modified fields</strong></p>
<p>Similar to the way we use the fields to specify conditions, we can also use
them to set values in the DB.</p>
<p>For example when we disable a service we want to keep existing <code class="docutils literal"><span class="pre">updated_at</span></code>
field value:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;disabled&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
          <span class="s1">&#39;updated_at&#39;</span><span class="p">:</span> <span class="n">service</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">updated_at</span><span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>Using modified field</strong></p>
<p>In some cases we may need to use a DB field that we are also updating, for
example when we are updating the <code class="docutils literal"><span class="pre">status</span></code> but we also want to keep the old
value in the <code class="docutils literal"><span class="pre">previous_status</span></code> field.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="s1">&#39;retyping&#39;</span><span class="p">,</span>
          <span class="s1">&#39;previous_status&#39;</span><span class="p">:</span> <span class="n">volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">}</span>
</pre></div>
</div>
<p>Conditional update mechanism takes into account that MySQL does not follow
SQL language specs and adjusts the query creation accordingly.</p>
</li>
<li><p class="first"><strong>Together with filters</strong></p>
<p>Using DB fields for assignment together with using them for values can give
us advanced functionality like for example increasing a quota value based on
current value and making sure we don&#8217;t exceed our quota limits.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;in_use&#39;</span><span class="p">:</span> <span class="n">quota</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">in_use</span> <span class="o">+</span> <span class="n">volume</span><span class="o">.</span><span class="n">size</span><span class="p">}</span>
<span class="n">filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">quota</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">in_use</span> <span class="o">&lt;=</span> <span class="n">max_usage</span> <span class="o">-</span> <span class="n">volume</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="conditional-value-setting">
<h2>Conditional value setting<a class="headerlink" href="#conditional-value-setting" title="Permalink to this headline">¶</a></h2>
<p>Under certain circumstances you may not know what value should be set in the DB
because it depends on another field or on another condition.  For those cases
we can use the <code class="docutils literal"><span class="pre">Case</span></code> class present in our persistent Versioned Objects which
implements the SQL CASE clause.</p>
<p>The idea is simple, using <code class="docutils literal"><span class="pre">Case</span></code> class we can say which values to set in a
field based on conditions and also set a default value if none of the
conditions are True.</p>
<dl class="docutils">
<dt>Conditions must be SQLAlchemy conditions, so we&#8217;ll need to use fields from the</dt>
<dd><code class="docutils literal"><span class="pre">model</span></code> attribute.</dd>
</dl>
<p>For example setting the status to &#8220;maintenance&#8221; during migration if current
status is &#8220;available&#8221; and leaving it as it was if it&#8217;s not can be done using
the following:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">volume</span><span class="o">.</span><span class="n">Case</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;available&#39;</span><span class="p">,</span> <span class="s1">&#39;maintenance&#39;</span><span class="p">)</span>
        <span class="p">],</span>
        <span class="n">else_</span><span class="o">=</span><span class="n">volume</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reflect-changes-considerations">
<h2>reflect_changes considerations<a class="headerlink" href="#reflect-changes-considerations" title="Permalink to this headline">¶</a></h2>
<p>As we&#8217;ve already mentioned <code class="docutils literal"><span class="pre">conditional_update</span></code> method will update Versioned
Object instance with provided values if the row in the DB has been updated, and
in most cases this is OK since we can set the values directly because we are
using simple values, but there are cases where we don&#8217;t know what value we
should set in the instance, and is in those cases where the default
<code class="docutils literal"><span class="pre">reflect_changes</span></code> value of True has performance implications.</p>
<p>There are 2 cases where Versioned Object <code class="docutils literal"><span class="pre">conditional_update</span></code> method doesn&#8217;t
know the value it has to set on the Versioned Object instance, and they are
when we use a field for assignment and when we are using the <code class="docutils literal"><span class="pre">Case</span></code> class,
since in both cases the DB is the one deciding the value that will be set.</p>
<p>In those cases <code class="docutils literal"><span class="pre">conditional_update</span></code> will have to retrieve the value from the
DB using <code class="docutils literal"><span class="pre">get_by_id</span></code> method, and this has a performance impact and therefore
should be avoided when possible.</p>
<p>So the recommendation is to set <code class="docutils literal"><span class="pre">reflect_changes</span></code> to False when using
<code class="docutils literal"><span class="pre">Case</span></code> class or using fields in the <code class="docutils literal"><span class="pre">values</span></code> argument if we don&#8217;t care
about the stored value.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<p>We can only use functionality that works on <strong>all</strong> supported DBs, and that&#8217;s
why we don&#8217;t allow multi table updates and will raise ProgrammingError
exception even when the code is running against a DB engine that supports this
functionality.</p>
<p>This way we make sure that we don&#8217;t inadvertently add a multi table update that
works on MySQL but will surely fail on PostgreSQL.</p>
<p>MySQL DB engine also has some limitations that we should be aware of when
creating our filters.</p>
<p>One that is very common is when we are trying to check if there is a row that
matches a specific criteria in the same table that we are updating.  For
example, when deleting a Consistency Group we want to check that it is not
being used as the source for a Consistency Group that is in the process of
being created.</p>
<p>The straightforward way of doing this is using the core exists expression and
use an alias to differentiate general query fields and the exists subquery.
Code would look like this:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cg_creating_from_src</span><span class="p">(</span><span class="n">cg_id</span><span class="p">):</span>
   <span class="n">model</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">ConsistencyGroup</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
       <span class="o">~</span><span class="n">model</span><span class="o">.</span><span class="n">deleted</span><span class="p">,</span>
       <span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;creating&#39;</span><span class="p">,</span>
       <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">source_cgid</span> <span class="o">==</span> <span class="n">cg_id</span><span class="p">)))</span>
</pre></div>
</div>
<p>While this will work in SQLite and PostgreSQL, it will not work on MySQL and an
error will be raised when the query is executed: &#8220;You can&#8217;t specify target
table &#8216;consistencygroups&#8217; for update in FROM clause&#8221;.</p>
<p>To solve this we have 2 options:</p>
<ul class="simple">
<li>Create a specific query for MySQL engines using an update with a left self
join, which is a feature only available in MySQL.</li>
<li>Use a trick -using a select subquery- that will work on all DBs.</li>
</ul>
<p>Considering that it&#8217;s always better to have only 1 way of doing things and that
SQLAlchemy doesn&#8217;t support MySQL&#8217;s non standard behavior we should generate
these filters using the select subquery method like this:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cg_creating_from_src</span><span class="p">(</span><span class="n">cg_id</span><span class="p">):</span>
   <span class="n">subq</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">models</span><span class="o">.</span><span class="n">ConsistencyGroup</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span>
       <span class="o">~</span><span class="n">model</span><span class="o">.</span><span class="n">deleted</span><span class="p">,</span>
       <span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;creating&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s1">&#39;cg2&#39;</span><span class="p">)</span>

   <span class="k">return</span> <span class="n">sql</span><span class="o">.</span><span class="n">exists</span><span class="p">([</span><span class="n">subq</span><span class="p">])</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">source_cgid</span> <span class="o">==</span> <span class="n">cgid</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="considerations-for-new-orm-versioned-objects">
<h2>Considerations for new ORM &amp; Versioned Objects<a class="headerlink" href="#considerations-for-new-orm-versioned-objects" title="Permalink to this headline">¶</a></h2>
<p>Conditional update mechanism works using generic methods for getting an object
from the DB as well as determining the model for a specific Versioned Object
instance for field binding.</p>
<p>These generic methods rely on some naming rules for Versioned Object classes,
ORM classes, and get methods, so when we are creating a new ORM class and
adding the matching Versioned Object and access methods we must be careful to
follow these rules or at least specify exceptions if we have a good reason not
to follow these conventions.</p>
<p>Rules:</p>
<ul class="simple">
<li>Versioned Object class name must be the same as the ORM class</li>
<li>Get method name must be ORM class converted to snake format with postfix
&#8220;_get&#8221;.  For example, for <code class="docutils literal"><span class="pre">Volume</span></code> ORM class expected method is
<code class="docutils literal"><span class="pre">volume_get</span></code>, and for an imaginary <code class="docutils literal"><span class="pre">MyORMClass</span></code> it would be
<code class="docutils literal"><span class="pre">my_orm_class_get</span></code>.</li>
<li>Get method must receive the <code class="docutils literal"><span class="pre">context</span></code> as the first argument and the <code class="docutils literal"><span class="pre">id</span></code>
as the second one, although it may accept more optional arguments.</li>
</ul>
<p>We should avoid diverging from these rules whenever is possible, but there are
cases where this is not possible, for example <code class="docutils literal"><span class="pre">BackupImport</span></code> Versioned Object
that really uses <code class="docutils literal"><span class="pre">Backup</span></code> ORM class.  For cases such as this we have a way to
set exceptions both for the generic get method and the model for a Versioned
Object.</p>
<p>To add exceptions for the get method we have to add a new entry to
<code class="docutils literal"><span class="pre">GET_EXCEPTIONS</span></code> dictionary mapping in
<code class="docutils literal"><span class="pre">cinder.db.sqlalchemy.api._get_get_method</span></code>.</p>
<p>And for determining the model for the Versioned Object we have to add a new
entry to <code class="docutils literal"><span class="pre">VO_TO_MODEL_EXCEPTIONS</span></code> dictionary mapping in
<code class="docutils literal"><span class="pre">cinder.db.sqlalchemy.api.get_model_for_versioned_object</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">API Races - Conditional Updates</a><ul>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#conditional-update">Conditional Update</a></li>
<li><a class="reference internal" href="#basic-usage">Basic Usage</a></li>
<li><a class="reference internal" href="#returning-errors">Returning Errors</a></li>
<li><a class="reference internal" href="#building-filters-on-the-api">Building filters on the API</a></li>
<li><a class="reference internal" href="#using-db-fields-for-assignment">Using DB fields for assignment</a></li>
<li><a class="reference internal" href="#conditional-value-setting">Conditional value setting</a></li>
<li><a class="reference internal" href="#reflect-changes-considerations">reflect_changes considerations</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#considerations-for-new-orm-versioned-objects">Considerations for new ORM &amp; Versioned Objects</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="api_microversion_dev.html"
                                  title="previous chapter">API Microversions</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="api_microversion_history.html"
                                  title="next chapter">REST API Version History</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/cinder
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/devref/api_conditional_updates.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api_microversion_history.html" title="REST API Version History"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="api_microversion_dev.html" title="API Microversions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">cinder 10.0.0.0rc2.dev76 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Developer Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2010-present, OpenStack Foundation.
      Last updated on Tue Feb 14 19:30:39 2017, commit 3c2819f.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/cinder");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>