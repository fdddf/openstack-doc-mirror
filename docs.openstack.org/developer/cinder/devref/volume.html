<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Storage Volumes, Disks &mdash; cinder 10.0.0.0rc2.dev77 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/tweaks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '10.0.0.0rc2.dev77',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="cinder 10.0.0.0rc2.dev77 documentation" href="../index.html" />
    <link rel="up" title="Developer Guide" href="index.html" />
    <link rel="next" title="Authentication and Authorization" href="auth.html" />
    <link rel="prev" title="The Database Layer" href="database.html" /> 
  </head>
  <body role="document">
  <div id="header">
    <h1 id="logo"><a href="http://www.openstack.org/">OpenStack</a></h1>
    <ul id="navigation">
      
      <li><a href="http://www.openstack.org/" title="Go to the Home page" class="link">Home</a></li>
      <li><a href="http://www.openstack.org/projects/" title="Go to the OpenStack Projects page">Projects</a></li>
      <li><a href="http://www.openstack.org/user-stories/" title="Go to the User Stories page" class="link">User Stories</a></li>
      <li><a href="http://www.openstack.org/community/" title="Go to the Community page" class="link">Community</a></li>
      <li><a href="http://www.openstack.org/blog/" title="Go to the OpenStack Blog">Blog</a></li>
      <li><a href="http://wiki.openstack.org/" title="Go to the OpenStack Wiki">Wiki</a></li>
      <li><a href="http://docs.openstack.org/" title="Go to OpenStack Documentation" class="current">Documentation</a></li>
      
    </ul>
  </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="storage-volumes-disks">
<h1>Storage Volumes, Disks<a class="headerlink" href="#storage-volumes-disks" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-cinder-volume-manager-module">
<h2>The <a class="reference internal" href="../api/cinder.volume.manager.html#module-cinder.volume.manager" title="cinder.volume.manager"><code class="xref py py-mod docutils literal"><span class="pre">cinder.volume.manager</span></code></a> Module<a class="headerlink" href="#the-cinder-volume-manager-module" title="Permalink to this headline">¶</a></h2>
<p>Volume manager manages creating, attaching, detaching, and persistent storage.</p>
<p>Persistent storage volumes keep their state independent of instances.  You can
attach to an instance, terminate the instance, spawn a new instance (even
one from a different image) and re-attach the volume with the same data
intact.</p>
<p><strong>Related Flags</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">volume_manager:</th><td class="field-body">The module name of a class derived from
<code class="xref py py-class docutils literal"><span class="pre">manager.Manager</span></code> (default:
<code class="xref py py-class docutils literal"><span class="pre">cinder.volume.manager.Manager</span></code>).</td>
</tr>
<tr class="field-even field"><th class="field-name">volume_driver:</th><td class="field-body">Used by <code class="xref py py-class docutils literal"><span class="pre">Manager</span></code>.  Defaults to
<a class="reference internal" href="../api/cinder.volume.drivers.lvm.html#cinder.volume.drivers.lvm.LVMVolumeDriver" title="cinder.volume.drivers.lvm.LVMVolumeDriver"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.drivers.lvm.LVMVolumeDriver</span></code></a>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">volume_group:</th><td class="field-body">Name of the group that will contain exported volumes (default:
<cite>cinder-volumes</cite>)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">num_shell_tries:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body">Number of times to attempt to run commands (default: 3)</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">VolumeManager</code><span class="sig-paren">(</span><em>volume_driver=None</em>, <em>service_name=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.manager.html#cinder.manager.CleanableManager" title="cinder.manager.CleanableManager"><code class="xref py py-class docutils literal"><span class="pre">cinder.manager.CleanableManager</span></code></a>, <a class="reference internal" href="../api/cinder.manager.html#cinder.manager.SchedulerDependentManager" title="cinder.manager.SchedulerDependentManager"><code class="xref py py-class docutils literal"><span class="pre">cinder.manager.SchedulerDependentManager</span></code></a></p>
<p>Manages attachable block storage devices.</p>
<dl class="attribute">
<dt>
<code class="descname">RPC_API_VERSION</code><em class="property"> = '3.10'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">accept_transfer</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em>, <em>new_user</em>, <em>new_project</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">attach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em>, <em>instance_uuid</em>, <em>host_name</em>, <em>mountpoint</em>, <em>mode</em>, <em>volume=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates db to show volume is attached.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">attachment_delete</code><span class="sig-paren">(</span><em>context</em>, <em>attachment_id</em>, <em>vref</em><span class="sig-paren">)</span></dt>
<dd><p>Delete/Detach the specified attachment.</p>
<p>Notifies the backend device that we&#8217;re detaching the specified
attachment instance.</p>
<p>param: vref: Volume object associated with the attachment
param: attachment: Attachment reference object to remove</p>
<p>NOTE if the attachment reference is None, we remove all existing
attachments for the specified volume object.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">attachment_update</code><span class="sig-paren">(</span><em>context</em>, <em>vref</em>, <em>connector</em>, <em>attachment_id</em><span class="sig-paren">)</span></dt>
<dd><p>Update/Finalize an attachment.</p>
<p>This call updates a valid attachment record to associate with a volume
and provide the caller with the proper connection info.  Note that
this call requires an <cite>attachment_ref</cite>.  It&#8217;s expected that prior to
this call that the volume and an attachment UUID has been reserved.</p>
<p>param: vref: Volume object to create attachment for
param: connector: Connector object to use for attachment creation
param: attachment_ref: ID of the attachment record to update</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy_volume_to_image</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em>, <em>image_meta</em><span class="sig-paren">)</span></dt>
<dd><p>Uploads the specified volume to Glance.</p>
<p>image_meta is a dictionary containing the following keys:
&#8216;id&#8217;, &#8216;container_format&#8217;, &#8216;disk_format&#8217;</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the cgsnapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the consistency group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_consistencygroup_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>cgsnapshot=None</em>, <em>source_cg=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the consistency group from source.</p>
<p>The source can be a CG snapshot or a source CG.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>group_snapshot=None</em>, <em>source_group=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the group from source.</p>
<p>The source can be a group snapshot or a source group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the group_snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Creates and exports the snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>request_spec=None</em>, <em>filter_properties=None</em>, <em>allow_reschedule=True</em><span class="sig-paren">)</span></dt>
<dd><p>Creates the volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes cgsnapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes consistency group and the volumes in the group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes group and the volumes in the group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes group_snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em>, <em>unmanage_only=False</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes and unexports snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>unmanage_only=False</em>, <em>cascade=False</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes and unexports volume.</p>
<ol class="arabic simple">
<li>Delete a volume(normal case)
Delete a volume and update quotas.</li>
<li>Delete a migration volume
If deleting the volume in a migration, we want to skip
quotas but we need database updates for the volume.</li>
</ol>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">detach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em>, <em>attachment_id=None</em>, <em>volume=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates db to show volume is detached.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">extend_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_size</em>, <em>reservations</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">failover</code><span class="sig-paren">(</span><em>context</em>, <em>secondary_backend_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>Failover a backend to a secondary replication target.</p>
<p>Instructs a replication capable/configured backend to failover
to one of it&#8217;s secondary replication targets. host=None is
an acceptable input, and leaves it to the driver to failover
to the only configured target, or to choose a target on it&#8217;s
own. All of the hosts volumes will be passed on to the driver
in order for it to determine the replicated volumes on the host,
if needed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; security context</li>
<li><strong>secondary_backend_id</strong> &#8211; Specifies backend_id to fail over to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">failover_completed</code><span class="sig-paren">(</span><em>context</em>, <em>updates</em><span class="sig-paren">)</span></dt>
<dd><p>Finalize failover of this backend.</p>
<p>When a service is clustered and replicated the failover has 2 stages,
one that does the failover of the volumes and another that finalizes
the failover of the services themselves.</p>
<p>This method takes care of the last part and is called from the service
doing the failover of the volumes after finished processing the
volumes.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">failover_host</code><span class="sig-paren">(</span><em>context</em>, <em>secondary_backend_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>Failover a backend to a secondary replication target.</p>
<p>Instructs a replication capable/configured backend to failover
to one of it&#8217;s secondary replication targets. host=None is
an acceptable input, and leaves it to the driver to failover
to the only configured target, or to choose a target on it&#8217;s
own. All of the hosts volumes will be passed on to the driver
in order for it to determine the replicated volumes on the host,
if needed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>context</strong> &#8211; security context</li>
<li><strong>secondary_backend_id</strong> &#8211; Specifies backend_id to fail over to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">finish_failover</code><span class="sig-paren">(</span><em>context</em>, <em>service</em>, <em>updates</em><span class="sig-paren">)</span></dt>
<dd><p>Completion of the failover locally or via RPC.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">freeze_host</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Freeze management plane on this backend.</p>
<p>Basically puts the control/management plane into a
Read Only state.  We should handle this in the scheduler,
however this is provided to let the driver know in case it
needs/wants to do something specific on the backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; security context</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_backup_device</code><span class="sig-paren">(</span><em>ctxt</em>, <em>backup</em>, <em>want_objects=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">get_capabilities</code><span class="sig-paren">(</span><em>context</em>, <em>discover</em><span class="sig-paren">)</span></dt>
<dd><p>Get capabilities of backend storage.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_manageable_snapshots</code><span class="sig-paren">(</span><em>ctxt</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em>, <em>want_objects=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">get_manageable_volumes</code><span class="sig-paren">(</span><em>ctxt</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em>, <em>want_objects=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">init_host</code><span class="sig-paren">(</span><em>added_to_cluster=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Perform any required initialization.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_host_with_rpc</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Prepare volume for connection from host represented by connector.</p>
<p>This method calls the driver initialize_connection and returns
it to the caller.  The connector parameter is a dictionary with
information about the host that will connect to the volume in the
following format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;ip&#39;</span><span class="p">:</span> <span class="n">ip</span><span class="p">,</span>
    <span class="s1">&#39;initiator&#39;</span><span class="p">:</span> <span class="n">initiator</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ip: the ip address of the connecting machine</p>
<p>initiator: the iscsi initiator name of the connecting machine.
This can be None if the connecting machine does not support iscsi
connections.</p>
<p>driver is responsible for doing any necessary security setup and
returning a connection_info dictionary in the following format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s1">&#39;driver_volume_type&#39;</span><span class="p">:</span> <span class="n">driver_volume_type</span><span class="p">,</span>
    <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>driver_volume_type: a string to identify the type of volume.  This</dt>
<dd>can be used by the calling code to determine the
strategy for connecting to the volume. This could
be &#8216;iscsi&#8217;, &#8216;rbd&#8217;, &#8216;sheepdog&#8217;, etc.</dd>
<dt>data: this is the data that the calling code will use to connect</dt>
<dd>to the volume. Keep in mind that this will be serialized to
json in various places, so it should not contain any non-json
data types.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">is_working</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return if Manager is ready to accept requests.</p>
<p>This is to inform Service class that in case of volume driver
initialization failure the manager is actually down and not ready to
accept any requests.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em>, <em>ref=None</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_snapshot</code><span class="sig-paren">(</span><em>ctxt</em>, <em>snapshot</em>, <em>ref=None</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">migrate_volume</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em>, <em>host</em>, <em>force_host_copy=False</em>, <em>new_type_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>Migrate the volume to the specified host (called on source host).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">migrate_volume_completion</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em>, <em>new_volume</em>, <em>error=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">publish_service_capabilities</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Collect driver status and then publish.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em><span class="sig-paren">)</span></dt>
<dd><p>Removes an export for a volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">retype</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_type_id</em>, <em>host</em>, <em>migration_policy='never'</em>, <em>reservations=None</em>, <em>old_reservations=None</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">secure_file_operations_enabled</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">target</code><em class="property"> = &lt;Target version=3.10&gt;</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection</code><span class="sig-paren">(</span><em>context</em>, <em>volume_id</em>, <em>connector</em>, <em>force=False</em><span class="sig-paren">)</span></dt>
<dd><p>Cleanup connection from host represented by connector.</p>
<p>The format of connector is the same as for initialize_connection.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">thaw_host</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>UnFreeze management plane on this backend.</p>
<p>Basically puts the control/management plane back into
a normal state.  We should handle this in the scheduler,
however this is provided to let the driver know in case it
needs/wants to do something specific on the backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; security context</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates consistency group.</p>
<p>Update consistency group by adding volumes to the group,
or removing volumes from the group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates group.</p>
<p>Update group by adding volumes to the group,
or removing volumes from the group.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_migrated_volume</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em>, <em>new_volume</em>, <em>volume_status</em><span class="sig-paren">)</span></dt>
<dd><p>Finalize migration process on backend device.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="the-cinder-volume-driver-module">
<h2>The <a class="reference internal" href="../api/cinder.volume.driver.html#module-cinder.volume.driver" title="cinder.volume.driver"><code class="xref py py-mod docutils literal"><span class="pre">cinder.volume.driver</span></code></a> Module<a class="headerlink" href="#the-cinder-volume-driver-module" title="Permalink to this headline">¶</a></h2>
<p>Drivers for volumes.</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">BaseVD</code><span class="sig-paren">(</span><em>execute=&lt;function execute&gt;</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Executes commands relating to Volumes.</p>
<p>Base Driver for Cinder Volume Control Path,
This includes supported/required implementation
for API calls.  Also provides <em>generic</em> implementation
of core features like cloning, copy_image_to_volume etc,
this way drivers that inherit from this base class and
don&#8217;t offer their own impl can fall back on a general
solution here.</p>
<p>Key thing to keep in mind with this driver is that it&#8217;s
intended that these drivers ONLY implement Control Path
details (create, delete, extend...), while transport or
data path related implementation should be a <em>member object</em>
that we call a connector.  The point here is that for example
don&#8217;t allow the LVM driver to implement iSCSI methods, instead
call whatever connector it has configured via conf file
(iSCSI{LIO, TGT, IET}, FC, etc).</p>
<p>In the base class and for example the LVM driver we do this via a has-a
relationship and just provide an interface to the specific connector
methods.  How you do this in your own driver is of course up to you.</p>
<dl class="attribute">
<dt>
<code class="descname">REPLICATION_FEATURE_CHECKERS</code><em class="property"> = {'a/a': 'failover_completed', 'v2.1': 'failover_host'}</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">SUPPORTED</code><em class="property"> = True</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">SUPPORTS_ACTIVE_ACTIVE</code><em class="property"> = False</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">VERSION</code><em class="property"> = 'N/A'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">accept_transfer</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_user</em>, <em>new_project</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">after_volume_copy</code><span class="sig-paren">(</span><em>context</em>, <em>src_vol</em>, <em>dest_vol</em>, <em>remote=None</em><span class="sig-paren">)</span></dt>
<dd><p>Driver-specific actions after copyvolume data.</p>
<p>This method will be called after _copy_volume_data during volume
migration</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">attach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>instance_uuid</em>, <em>host_name</em>, <em>mountpoint</em><span class="sig-paren">)</span></dt>
<dd><p>Callback for volume attached to instance or host.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">backup_use_temp_snapshot</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">backup_volume</code><span class="sig-paren">(</span><em>context</em>, <em>backup</em>, <em>backup_service</em><span class="sig-paren">)</span></dt>
<dd><p>Create a new backup from an existing volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">before_volume_copy</code><span class="sig-paren">(</span><em>context</em>, <em>src_vol</em>, <em>dest_vol</em>, <em>remote=None</em><span class="sig-paren">)</span></dt>
<dd><p>Driver-specific actions before copyvolume data.</p>
<p>This method will be called before _copy_volume_data during volume
migration</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">check_for_setup_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">clear_download</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Clean up after an interrupted image copy.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">clone_image</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_location</em>, <em>image_meta</em>, <em>image_service</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">copy_image_to_encrypted_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_service</em>, <em>image_id</em><span class="sig-paren">)</span></dt>
<dd><p>Fetch image from image_service and write to encrypted volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy_image_to_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_service</em>, <em>image_id</em><span class="sig-paren">)</span></dt>
<dd><p>Fetch image from image_service and write to unencrypted volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy_volume_to_image</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>image_service</em>, <em>image_meta</em><span class="sig-paren">)</span></dt>
<dd><p>Copy the volume to the specified image.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_cloned_volume</code><span class="sig-paren">(</span><em>volume</em>, <em>src_vref</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a clone of the specified volume.</p>
<p>If volume_type extra specs includes &#8216;replication: &lt;is&gt; True&#8217; the
driver needs to create a volume replica (secondary)
and setup replication between the newly created volume
and the secondary volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Exports the volume.</p>
<p>Can optionally return a Dictionary of changes
to the volume object to be persisted.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_export_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Exports the snapshot.</p>
<p>Can optionally return a Dictionary of changes
to the snapshot object to be persisted.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object of the group to be created.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will throw
an exception and it will be caught in the try-except block in the
manager. If the driver throws an exception, the manager will also
catch it in the try-except block. The group status in the db will
be changed to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and return it or return None. The group status will
be set to &#8216;available&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em>, <em>group_snapshot=None</em>, <em>snapshots=None</em>, <em>source_group=None</em>, <em>source_vols=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a group from source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object to be created.</li>
<li><strong>volumes</strong> &#8211; a list of Volume objects in the group.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object as source.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in group_snapshot.</li>
<li><strong>source_group</strong> &#8211; the Group object as source.</li>
<li><strong>source_vols</strong> &#8211; a list of Volume objects in the source_group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>The source can be group_snapshot or a source_group.</p>
<p>param volumes is a list of objects retrieved from the db. It cannot
be assigned to volumes_model_update. volumes_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>To be consistent with other volume operations, the manager will
assume the operation is successful if no exception is thrown by
the driver. For a successful operation, the driver can either build
the model_update and volumes_model_update and return them or
return None, None.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em>, <em>snapshots</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a group_snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object to be created.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in the group_snapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is a list of Snapshot objects. It cannot be assigned
to snapshots_model_update. snapshots_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is &#8216;error&#8217;, the
status in model_update will be set to the same if it is not already
&#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will raise an
exception and the status of group_snapshot will be set to &#8216;error&#8217; in
the db. If snapshots_model_update is not returned by the driver, the
manager will set the status of every snapshot to &#8216;error&#8217; in the except
block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
group_snapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of group_snapshot and all snapshots
will be set to &#8216;available&#8217; at the end of the manager function.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a volume.</p>
<p>Can optionally return a Dictionary of changes to the volume object to
be persisted.</p>
<p>If volume_type extra specs includes
&#8216;capabilities:replication &lt;is&gt; True&#8217; the driver
needs to create a volume replica (secondary), and setup replication
between the newly created volume and the secondary volume.
Returned dictionary should include:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">volume</span><span class="p">[</span><span class="s1">&#39;replication_status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;copying&#39;</span>
<span class="n">volume</span><span class="p">[</span><span class="s1">&#39;replication_extended_status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">driver</span> <span class="n">specific</span> <span class="n">value</span><span class="o">&gt;</span>
<span class="n">volume</span><span class="p">[</span><span class="s1">&#39;driver_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">driver</span> <span class="n">specific</span> <span class="n">value</span><span class="o">&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object of the group to be deleted.</li>
<li><strong>volumes</strong> &#8211; a list of Volume objects in the group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param volumes is a list of objects retrieved from the db. It cannot
be assigned to volumes_model_update. volumes_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate volumes_model_update and model_update
and return them.</p>
<p>The manager will check volumes_model_update and update db accordingly
for each volume. If the driver successfully deleted some volumes
but failed to delete others, it should set statuses of the volumes
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of volumes_model_update is &#8216;error_deleting&#8217;
or &#8216;error&#8217;, the status in model_update will be set to the same if it
is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of the group will be
set to &#8216;error&#8217; in the db. If volumes_model_update is not returned by
the driver, the manager will set the status of every volume in the
group to &#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager. The statuses of the
group and all volumes in it will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and volumes_model_update and return them or
return None, None. The statuses of the group and all volumes
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_group_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>group_snapshot</em>, <em>snapshots</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a group_snapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group_snapshot</strong> &#8211; the GroupSnapshot object to be deleted.</li>
<li><strong>snapshots</strong> &#8211; a list of Snapshot objects in the group_snapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is a list of objects. It cannot be assigned to
snapshots_model_update. snapshots_model_update is a list of of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is
&#8216;error_deleting&#8217; or &#8216;error&#8217;, the status in model_update will be set to
the same if it is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of group_snapshot will
be set to &#8216;error&#8217; in the db. If snapshots_model_update is not returned
by the driver, the manager will set the status of every snapshot to
&#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
group_snapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of group_snapshot and all snapshots
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a volume.</p>
<p>If volume_type extra specs includes &#8216;replication: &lt;is&gt; True&#8217;
then the driver needs to delete the volume replica too.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">detach_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>attachment=None</em><span class="sig-paren">)</span></dt>
<dd><p>Callback for volume detached.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">do_setup</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Any initialization the volume driver does while starting.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">ensure_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Synchronously recreates an export for a volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">extend_volume</code><span class="sig-paren">(</span><em>volume</em>, <em>new_size</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">failover</code><span class="sig-paren">(</span><em>context</em>, <em>volumes</em>, <em>secondary_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>Like failover but for a host that is clustered.</p>
<p>Most of the time this will be the exact same behavior as failover_host,
so if it&#8217;s not overwritten, it is assumed to be the case.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">failover_completed</code><span class="sig-paren">(</span><em>context</em>, <em>active_backend_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>This method is called after failover for clustered backends.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">failover_host</code><span class="sig-paren">(</span><em>context</em>, <em>volumes</em>, <em>secondary_id=None</em><span class="sig-paren">)</span></dt>
<dd><p>Failover a backend to a secondary replication target.</p>
<p>Instructs a replication capable/configured backend to failover
to one of it&#8217;s secondary replication targets. host=None is
an acceptable input, and leaves it to the driver to failover
to the only configured target, or to choose a target on it&#8217;s
own. All of the hosts volumes will be passed on to the driver
in order for it to determine the replicated volumes on the host,
if needed.</p>
<p>Response is a tuple, including the new target backend_id
AND a lit of dictionaries with volume_id and updates.
Key things to consider (attaching failed-over volumes):
- provider_location
- provider_auth
- provider_id
- replication_status</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; security context</li>
<li><strong>volumes</strong> &#8211; list of volume objects, in case the driver needs
to take action on them in some way</li>
<li><strong>secondary_id</strong> &#8211; Specifies rep target backend to fail over to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">ID of the backend that was failed-over to
and model update for volumes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">freeze_backend</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Notify the backend that it&#8217;s frozen.</p>
<p>We use set to prohibit the creation of any new resources
on the backend, or any modifications to existing items on
a backend.  We set/enforce this by not allowing scheduling
of new volumes to the specified backend, and checking at the
api for modifications to resources and failing.</p>
<p>In most cases the driver may not need to do anything, but
this provides a handle if they need it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; security context</td>
</tr>
<tr class="field-even field"><th class="field-name">Response:</th><td class="field-body">True|False</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_backup_device</code><span class="sig-paren">(</span><em>context</em>, <em>backup</em><span class="sig-paren">)</span></dt>
<dd><p>Get a backup device from an existing volume.</p>
<p>The function returns a volume or snapshot to backup service,
and then backup service attaches the device and does backup.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_default_filter_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get the default filter_function string.</p>
<p>Each driver could overwrite the method to return a well-known
default string if it is available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_default_goodness_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get the default goodness_function string.</p>
<p>Each driver could overwrite the method to return a well-known
default string if it is available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_filter_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get filter_function string.</p>
<p>Returns either the string from the driver instance or global section
in cinder.conf. If nothing is specified in cinder.conf, then try to
find the default filter_function. When None is returned the scheduler
will always pass the driver instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a filter_function string or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_goodness_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get good_function string.</p>
<p>Returns either the string from the driver instance or global section
in cinder.conf. If nothing is specified in cinder.conf, then try to
find the default goodness_function. When None is returned the scheduler
will give the lowest score to the driver instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a goodness_function string or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_pool</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Return pool name where volume reside on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>volume</strong> &#8211; The volume hosted by the driver.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">name of the pool where given volume is in.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_prefixed_property</code><span class="sig-paren">(</span><em>property</em><span class="sig-paren">)</span></dt>
<dd><p>Return prefixed property name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a prefixed property name string or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_replication_updates</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Old replication update method, deprecate.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get the current version of this driver.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_volume_stats</code><span class="sig-paren">(</span><em>refresh=False</em><span class="sig-paren">)</span></dt>
<dd><p>Return the current state of the volume service.</p>
<p>If &#8216;refresh&#8217; is True, run the update first.</p>
<p>For replication the following state should be reported:
replication = True (None or false disables replication)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_capabilities</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Obtain backend volume stats and capabilities list.</p>
<p>This stores a dictionary which is consisted of two parts.
First part includes static backend capabilities which are
obtained by get_volume_stats(). Second part is properties,
which includes parameters correspond to extra specs.
This properties part is consisted of cinder standard
capabilities and vendor unique properties.</p>
<p>Using this capabilities list, operator can manage/configure
backend using key/value from capabilities without specific
knowledge of backend.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Allow connection to connector and return connection info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; The volume to be attached</li>
<li><strong>connector</strong> &#8211; Dictionary containing information about what is being
connected to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns conn_info:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">A dictionary of connection information.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Allow connection to connector and return connection info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>snapshot</strong> &#8211; The snapshot to be attached</li>
<li><strong>connector</strong> &#8211; Dictionary containing information about what
is being connected to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Returns conn_info:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">A dictionary of connection information. This
can optionally include a &#8220;initiator_updates&#8221;
field.</p>
</td>
</tr>
</tbody>
</table>
<p>The &#8220;initiator_updates&#8221; field must be a dictionary containing a
&#8220;set_values&#8221; and/or &#8220;remove_values&#8221; field. The &#8220;set_values&#8221; field must
be a dictionary of key-value pairs to be set/updated in the db. The
&#8220;remove_values&#8221; field must be a list of keys, previously set with
&#8220;set_values&#8221;, that will be deleted from the db.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">initialized</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd><p>Manage exiting stub.</p>
<p>This is for drivers that don&#8217;t implement manage_existing().</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">migrate_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>host</em><span class="sig-paren">)</span></dt>
<dd><p>Migrate volume stub.</p>
<p>This is for drivers that don&#8217;t implement an enhanced version
of this operation.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Removes an export for a volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove_export_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Removes an export for a snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">restore_backup</code><span class="sig-paren">(</span><em>context</em>, <em>backup</em>, <em>volume</em>, <em>backup_service</em><span class="sig-paren">)</span></dt>
<dd><p>Restore an existing backup to a new or existing volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">retype</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_type</em>, <em>diff</em>, <em>host</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">secure_file_operations_enabled</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Determine if driver is running in Secure File Operations mode.</p>
<p>The Cinder Volume driver needs to query if this driver is running
in a secure file operations mode. By default, it is False: any driver
that does support secure file operations should override this method.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_initialized</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">set_throttle</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">snapshot_remote_attachable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">supported</code></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><code class="descname">supports_replication_feature</code><span class="sig-paren">(</span><em>feature</em><span class="sig-paren">)</span></dt>
<dd><p>Check if driver class supports replication features.</p>
<dl class="docutils">
<dt>Feature is a string that must be one of:</dt>
<dd><ul class="first last simple">
<li>v2.1</li>
<li>a/a</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Disallow connection from connector.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Disallow connection from connector.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">thaw_backend</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span></dt>
<dd><p>Notify the backend that it&#8217;s unfrozen/thawed.</p>
<p>Returns the backend to a normal state after a freeze
operation.</p>
<p>In most cases the driver may not need to do anything, but
this provides a handle if they need it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> &#8211; security context</td>
</tr>
<tr class="field-even field"><th class="field-name">Response:</th><td class="field-body">True|False</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">unmanage</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Unmanage stub.</p>
<p>This is for drivers that don&#8217;t implement unmanage().</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_group</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the Group object of the group to be updated.</li>
<li><strong>add_volumes</strong> &#8211; a list of Volume objects to be added.</li>
<li><strong>remove_volumes</strong> &#8211; a list of Volume objects to be removed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, add_volumes_update, remove_volumes_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update is a dictionary that the driver wants the manager
to update upon a successful return. If None is returned, the manager
will set the status to &#8216;available&#8217;.</p>
<p>add_volumes_update and remove_volumes_update are lists of dictionaries
that the driver wants the manager to update upon a successful return.
Note that each entry requires a {&#8216;id&#8217;: xxx} so that the correct
volume entry can be updated. If None is returned, the volume will
remain its original status. Also note that you cannot directly
assign add_volumes to add_volumes_update as add_volumes is a list of
volume objects and cannot be used for db update directly. Same with
remove_volumes.</p>
<p>If the driver throws an exception, the status of the group as well as
those of the volumes to be added/removed will be set to &#8216;error&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_migrated_volume</code><span class="sig-paren">(</span><em>ctxt</em>, <em>volume</em>, <em>new_volume</em>, <em>original_volume_status</em><span class="sig-paren">)</span></dt>
<dd><p>Return model update for migrated volume.</p>
<p>Each driver implementing this method needs to be responsible for the
values of _name_id and provider_location. If None is returned or either
key is not set, it means the volume table does not need to change the
value(s) for the key(s).
The return format is {&#8220;_name_id&#8221;: value, &#8220;provider_location&#8221;: value}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; The original volume that was migrated to this backend</li>
<li><strong>new_volume</strong> &#8211; The migration volume object that was created on
this backend as part of the migration process</li>
<li><strong>original_volume_status</strong> &#8211; The status of the original volume</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update to update DB with any needed changes</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_provider_info</code><span class="sig-paren">(</span><em>volumes</em>, <em>snapshots</em><span class="sig-paren">)</span></dt>
<dd><p>Get provider info updates from driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volumes</strong> &#8211; List of Cinder volumes to check for updates</li>
<li><strong>snapshots</strong> &#8211; List of Cinder snapshots to check for updates</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple (volume_updates, snapshot_updates)</p>
</td>
</tr>
</tbody>
</table>
<p>where volume updates {&#8216;id&#8217;: uuid, provider_id: &lt;provider-id&gt;}
and snapshot updates {&#8216;id&#8217;: uuid, provider_id: &lt;provider-id&gt;}</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">validate_connector</code><span class="sig-paren">(</span><em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Fail if connector doesn&#8217;t contain all the data needed by driver.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">validate_connector_has_setting</code><span class="sig-paren">(</span><em>connector</em>, <em>setting</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">CloneableImageVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt>
<code class="descname">clone_image</code><span class="sig-paren">(</span><em>volume</em>, <em>image_location</em>, <em>image_id</em>, <em>image_meta</em>, <em>image_service</em><span class="sig-paren">)</span></dt>
<dd><p>Create a volume efficiently from an existing image.</p>
<p>image_location is a string whose format depends on the
image service backend in use. The driver should use it
to determine whether cloning is possible.</p>
<p>image_id is a string which represents id of the image.
It can be used by the driver to introspect internal
stores or registry to do an efficient image clone.</p>
<p>image_meta is a dictionary that includes &#8216;disk_format&#8217; (e.g.
raw, qcow2) and other image attributes that allow drivers to
decide whether they can clone the image without first requiring
conversion.</p>
<p>image_service is the reference of the image_service to use.
Note that this is needed to be passed here for drivers that
will want to fetch images from the image service directly.</p>
<p>Returns a dict of volume properties eg. provider_location,
boolean indicating whether cloning occurred</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ConsistencyGroupVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class has been deprecated and should not be inherited.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ExtendVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class has been deprecated and should not be inherited.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">FibreChannelDriver</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.VolumeDriver" title="cinder.volume.driver.VolumeDriver"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.VolumeDriver</span></code></a></p>
<p>Executes commands relating to Fibre Channel volumes.</p>
<dl class="method">
<dt>
<code class="descname">get_volume_stats</code><span class="sig-paren">(</span><em>refresh=False</em><span class="sig-paren">)</span></dt>
<dd><p>Get volume stats.</p>
<p>If &#8216;refresh&#8217; is True, run update the stats first.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Initializes the connection and returns connection info.</p>
<p>The  driver returns a driver_volume_type of &#8216;fibre_channel&#8217;.
The target_wwn can be a single entry or a list of wwns that
correspond to the list of remote wwn(s) that will export the volume.
Example return values:</p>
<div class="highlight-json"><div class="highlight"><pre><span></span>{
    &#39;driver_volume_type&#39;: &#39;fibre_channel&#39;
    &#39;data&#39;: {
        &#39;target_discovered&#39;: True,
        &#39;target_lun&#39;: 1,
        &#39;target_wwn&#39;: &#39;1234567890123&#39;,
        &#39;discard&#39;: False,
    }
}

or

 {
    &#39;driver_volume_type&#39;: &#39;fibre_channel&#39;
    &#39;data&#39;: {
        &#39;target_discovered&#39;: True,
        &#39;target_lun&#39;: 1,
        &#39;target_wwn&#39;: [&#39;1234567890123&#39;, &#39;0987654321321&#39;],
        &#39;discard&#39;: False,
    }
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">validate_connector</code><span class="sig-paren">(</span><em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Fail if connector doesn&#8217;t contain all the data needed by driver.</p>
<p>Do a check on the connector and ensure that it has wwnns, wwpns.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">validate_connector_has_setting</code><span class="sig-paren">(</span><em>connector</em>, <em>setting</em><span class="sig-paren">)</span></dt>
<dd><p>Test for non-empty setting in connector.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ISCSIDriver</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.VolumeDriver" title="cinder.volume.driver.VolumeDriver"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.VolumeDriver</span></code></a></p>
<p>Executes commands relating to ISCSI volumes.</p>
<p>We make use of model provider properties as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">provider_location</span></code></dt>
<dd>if present, contains the iSCSI target information in the same
format as an ietadm discovery
i.e. &#8216;&lt;ip&gt;:&lt;port&gt;,&lt;portal&gt; &lt;target IQN&gt;&#8217;</dd>
<dt><code class="docutils literal"><span class="pre">provider_auth</span></code></dt>
<dd>if present, contains a space-separated triple:
&#8216;&lt;auth method&gt; &lt;auth username&gt; &lt;auth password&gt;&#8217;.
<cite>CHAP</cite> is the only auth_method in use at the moment.</dd>
</dl>
<dl class="method">
<dt>
<code class="descname">get_volume_stats</code><span class="sig-paren">(</span><em>refresh=False</em><span class="sig-paren">)</span></dt>
<dd><p>Get volume stats.</p>
<p>If &#8216;refresh&#8217; is True, run update the stats first.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Initializes the connection and returns connection info.</p>
<p>The iscsi driver returns a driver_volume_type of &#8216;iscsi&#8217;.
The format of the driver data is defined in _get_iscsi_properties.
Example return value:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>{
    &#39;driver_volume_type&#39;: &#39;iscsi&#39;
    &#39;data&#39;: {
        &#39;target_discovered&#39;: True,
        &#39;target_iqn&#39;: &#39;iqn.2010-10.org.openstack:volume-00000001&#39;,
        &#39;target_portal&#39;: &#39;127.0.0.0.1:3260&#39;,
        &#39;volume_id&#39;: 1,
        &#39;discard&#39;: False,
    }
}
</pre></div>
</div>
<p>If the backend driver supports multiple connections for multipath and
for single path with failover, &#8220;target_portals&#8221;, &#8220;target_iqns&#8221;,
&#8220;target_luns&#8221; are also populated:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>{
    &#39;driver_volume_type&#39;: &#39;iscsi&#39;
    &#39;data&#39;: {
        &#39;target_discovered&#39;: False,
        &#39;target_iqn&#39;: &#39;iqn.2010-10.org.openstack:volume1&#39;,
        &#39;target_iqns&#39;: [&#39;iqn.2010-10.org.openstack:volume1&#39;,
                        &#39;iqn.2010-10.org.openstack:volume1-2&#39;],
        &#39;target_portal&#39;: &#39;10.0.0.1:3260&#39;,
        &#39;target_portals&#39;: [&#39;10.0.0.1:3260&#39;, &#39;10.0.1.1:3260&#39;]
        &#39;target_lun&#39;: 1,
        &#39;target_luns&#39;: [1, 1],
        &#39;volume_id&#39;: 1,
        &#39;discard&#39;: False,
    }
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">validate_connector</code><span class="sig-paren">(</span><em>connector</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ISERDriver</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.ISCSIDriver" title="cinder.volume.driver.ISCSIDriver"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.ISCSIDriver</span></code></a></p>
<p>Executes commands relating to ISER volumes.</p>
<p>We make use of model provider properties as follows:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">provider_location</span></code></dt>
<dd>if present, contains the iSER target information in the same
format as an ietadm discovery
i.e. &#8216;&lt;ip&gt;:&lt;port&gt;,&lt;portal&gt; &lt;target IQN&gt;&#8217;</dd>
<dt><code class="docutils literal"><span class="pre">provider_auth</span></code></dt>
<dd>if present, contains a space-separated triple:
&#8216;&lt;auth method&gt; &lt;auth username&gt; &lt;auth password&gt;&#8217;.
<cite>CHAP</cite> is the only auth_method in use at the moment.</dd>
</dl>
<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd><p>Initializes the connection and returns connection info.</p>
<p>The iser driver returns a driver_volume_type of &#8216;iser&#8217;.
The format of the driver data is defined in _get_iser_properties.
Example return value:</p>
<div class="highlight-json"><div class="highlight"><pre><span></span>{
    &#39;driver_volume_type&#39;: &#39;iser&#39;
    &#39;data&#39;: {
        &#39;target_discovered&#39;: True,
        &#39;target_iqn&#39;:
        &#39;iqn.2010-10.org.iser.openstack:volume-00000001&#39;,
        &#39;target_portal&#39;: &#39;127.0.0.0.1:3260&#39;,
        &#39;volume_id&#39;: 1,
    }
}
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">LocalVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class has been deprecated and should not be inherited.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ManageableSnapshotsVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt>
<code class="descname">get_manageable_snapshots</code><span class="sig-paren">(</span><em>cinder_snapshots</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em><span class="sig-paren">)</span></dt>
<dd><p>List snapshots on the backend available for management by Cinder.</p>
<p>Returns a list of dictionaries, each specifying a snapshot in the host,
with the following keys:
- reference (dictionary): The reference for a snapshot, which can be</p>
<blockquote>
<div>passed to &#8220;manage_existing_snapshot&#8221;.</div></blockquote>
<ul class="simple">
<li>size (int): The size of the snapshot according to the storage
backend, rounded up to the nearest GB.</li>
<li>safe_to_manage (boolean): Whether or not this snapshot is safe to
manage according to the storage backend. For example, is the snapshot
in use or invalid for any reason.</li>
<li>reason_not_safe (string): If safe_to_manage is False, the reason why.</li>
<li>cinder_id (string): If already managed, provide the Cinder ID.</li>
<li>extra_info (string): Any extra information to return to the user</li>
<li>source_reference (string): Similar to &#8220;reference&#8221;, but for the
snapshot&#8217;s source volume.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cinder_snapshots</strong> &#8211; A list of snapshots in this host that Cinder
currently manages, used to determine if
a snapshot is manageable or not.</li>
<li><strong>marker</strong> &#8211; The last item of the previous page; we return the
next results after this value (after sorting)</li>
<li><strong>limit</strong> &#8211; Maximum number of items to return</li>
<li><strong>offset</strong> &#8211; Number of items to skip after marker</li>
<li><strong>sort_keys</strong> &#8211; List of keys to sort results by (valid keys are
&#8216;identifier&#8217; and &#8216;size&#8217;)</li>
<li><strong>sort_dirs</strong> &#8211; List of directions to sort by, corresponding to
sort_keys (valid directions are &#8216;asc&#8217; and &#8216;desc&#8217;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd><p>Brings an existing backend storage object under Cinder management.</p>
<p>existing_ref is passed straight through from the API request&#8217;s
manage_existing_ref value, and it is up to the driver how this should
be interpreted.  It should be sufficient to identify a storage object
that the driver should somehow associate with the newly-created cinder
snapshot structure.</p>
<p>There are two ways to do this:</p>
<ol class="arabic simple">
<li>Rename the backend storage object so that it matches the
snapshot[&#8216;name&#8217;] which is how drivers traditionally map between a
cinder snapshot and the associated backend storage object.</li>
<li>Place some metadata on the snapshot, or somewhere in the backend,
that allows other driver requests (e.g. delete) to locate the
backend storage object when required.</li>
</ol>
<p>If the existing_ref doesn&#8217;t make sense, or doesn&#8217;t refer to an existing
backend storage object, raise a ManageExistingInvalidReference
exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>snapshot</strong> &#8211; Cinder volume snapshot to manage</li>
<li><strong>existing_ref</strong> &#8211; Driver-specific information used to identify a
volume snapshot</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_snapshot_get_size</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd><p>Return size of snapshot to be managed by manage_existing.</p>
<p>When calculating the size, round up to the next GB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>snapshot</strong> &#8211; Cinder volume snapshot to manage</li>
<li><strong>existing_ref</strong> &#8211; Driver-specific information used to identify a
volume snapshot</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns size:</th><td class="field-body"><p class="first last">Volume snapshot size in GiB (integer)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">unmanage_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Removes the specified snapshot from Cinder management.</p>
<p>Does not delete the underlying backend storage object.</p>
<p>For most drivers, this will not need to do anything. However, some
drivers might use this call as an opportunity to clean up any
Cinder-specific configuration that they have associated with the
backend storage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>snapshot</strong> &#8211; Cinder volume snapshot to unmanage</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ManageableVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt>
<code class="descname">get_manageable_volumes</code><span class="sig-paren">(</span><em>cinder_volumes</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em><span class="sig-paren">)</span></dt>
<dd><p>List volumes on the backend available for management by Cinder.</p>
<p>Returns a list of dictionaries, each specifying a volume in the host,
with the following keys:
- reference (dictionary): The reference for a volume, which can be</p>
<blockquote>
<div>passed to &#8220;manage_existing&#8221;.</div></blockquote>
<ul class="simple">
<li>size (int): The size of the volume according to the storage
backend, rounded up to the nearest GB.</li>
<li>safe_to_manage (boolean): Whether or not this volume is safe to
manage according to the storage backend. For example, is the volume
in use or invalid for any reason.</li>
<li>reason_not_safe (string): If safe_to_manage is False, the reason why.</li>
<li>cinder_id (string): If already managed, provide the Cinder ID.</li>
<li>extra_info (string): Any extra information to return to the user</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cinder_volumes</strong> &#8211; A list of volumes in this host that Cinder
currently manages, used to determine if
a volume is manageable or not.</li>
<li><strong>marker</strong> &#8211; The last item of the previous page; we return the
next results after this value (after sorting)</li>
<li><strong>limit</strong> &#8211; Maximum number of items to return</li>
<li><strong>offset</strong> &#8211; Number of items to skip after marker</li>
<li><strong>sort_keys</strong> &#8211; List of keys to sort results by (valid keys are
&#8216;identifier&#8217; and &#8216;size&#8217;)</li>
<li><strong>sort_dirs</strong> &#8211; List of directions to sort by, corresponding to
sort_keys (valid directions are &#8216;asc&#8217; and &#8216;desc&#8217;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd><p>Brings an existing backend storage object under Cinder management.</p>
<p>existing_ref is passed straight through from the API request&#8217;s
manage_existing_ref value, and it is up to the driver how this should
be interpreted.  It should be sufficient to identify a storage object
that the driver should somehow associate with the newly-created cinder
volume structure.</p>
<p>There are two ways to do this:</p>
<ol class="arabic simple">
<li>Rename the backend storage object so that it matches the,
volume[&#8216;name&#8217;] which is how drivers traditionally map between a
cinder volume and the associated backend storage object.</li>
<li>Place some metadata on the volume, or somewhere in the backend, that
allows other driver requests (e.g. delete, clone, attach, detach...)
to locate the backend storage object when required.</li>
</ol>
<p>If the existing_ref doesn&#8217;t make sense, or doesn&#8217;t refer to an existing
backend storage object, raise a ManageExistingInvalidReference
exception.</p>
<p>The volume may have a volume_type, and the driver can inspect that and
compare against the properties of the referenced backend storage
object.  If they are incompatible, raise a
ManageExistingVolumeTypeMismatch, specifying a reason for the failure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>volume</strong> &#8211; Cinder volume to manage</li>
<li><strong>existing_ref</strong> &#8211; Driver-specific information used to identify a
volume</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_get_size</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd><p>Return size of volume to be managed by manage_existing.</p>
<p>When calculating the size, round up to the next GB.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>volume</strong> &#8211; Cinder volume to manage</li>
<li><strong>existing_ref</strong> &#8211; Driver-specific information used to identify a
volume</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns size:</th><td class="field-body"><p class="first last">Volume size in GiB (integer)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">unmanage</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Removes the specified volume from Cinder management.</p>
<p>Does not delete the underlying backend storage object.</p>
<p>For most drivers, this will not need to do anything.  However, some
drivers might use this call as an opportunity to clean up any
Cinder-specific configuration that they have associated with the
backend storage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>volume</strong> &#8211; Cinder volume to unmanage</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">MigrateVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt>
<code class="descname">migrate_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>host</em><span class="sig-paren">)</span></dt>
<dd><p>Migrate the volume to the specified host.</p>
<p>Returns a boolean indicating whether the migration occurred, as well as
model_update.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ctxt</strong> &#8211; Context</li>
<li><strong>volume</strong> &#8211; A dictionary describing the volume to migrate</li>
<li><strong>host</strong> &#8211; A dictionary describing the host to migrate to, where
host[&#8216;host&#8217;] is its name, and host[&#8216;capabilities&#8217;] is a
dictionary of its reported capabilities.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">ProxyVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Proxy Volume Driver to mark proxy drivers</p>
<p>If a driver uses a proxy class (e.g. by using __setattr__ and
__getattr__) without directly inheriting from base volume driver this
class can help marking them and retrieve the actual used driver object.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">SnapshotVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class has been deprecated and should not be inherited.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">TransferVD</code></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class has been deprecated and should not be inherited.</p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descname">VolumeDriver</code><span class="sig-paren">(</span><em>execute=&lt;function execute&gt;</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.ManageableVD" title="cinder.volume.driver.ManageableVD"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.ManageableVD</span></code></a>, <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.CloneableImageVD" title="cinder.volume.driver.CloneableImageVD"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.CloneableImageVD</span></code></a>, <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.ManageableSnapshotsVD" title="cinder.volume.driver.ManageableSnapshotsVD"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.ManageableSnapshotsVD</span></code></a>, <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.MigrateVD" title="cinder.volume.driver.MigrateVD"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.MigrateVD</span></code></a>, <a class="reference internal" href="../api/cinder.volume.driver.html#cinder.volume.driver.BaseVD" title="cinder.volume.driver.BaseVD"><code class="xref py py-class docutils literal"><span class="pre">cinder.volume.driver.BaseVD</span></code></a></p>
<dl class="method">
<dt>
<code class="descname">accept_transfer</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_user</em>, <em>new_project</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">check_for_setup_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">clear_download</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">clone_image</code><span class="sig-paren">(</span><em>volume</em>, <em>image_location</em>, <em>image_id</em>, <em>image_meta</em>, <em>image_service</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">create_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em>, <em>snapshots</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a cgsnapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot to be created.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
assigned to snapshots_model_update. snapshots_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is &#8216;error&#8217;, the
status in model_update will be set to the same if it is not already
&#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will raise an
exception and the status of cgsnapshot will be set to &#8216;error&#8217; in the
db. If snapshots_model_update is not returned by the driver, the
manager will set the status of every snapshot to &#8216;error&#8217; in the except
block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
cgsnapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of cgsnapshot and all snapshots
will be set to &#8216;available&#8217; at the end of the manager function.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a consistencygroup.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be created.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>If the status in model_update is &#8216;error&#8217;, the manager will throw
an exception and it will be caught in the try-except block in the
manager. If the driver throws an exception, the manager will also
catch it in the try-except block. The group status in the db will
be changed to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and return it or return None. The group status will
be set to &#8216;available&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_consistencygroup_from_src</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em>, <em>cgsnapshot=None</em>, <em>snapshots=None</em>, <em>source_cg=None</em>, <em>source_vols=None</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a consistencygroup from source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be created.</li>
<li><strong>volumes</strong> &#8211; a list of volume dictionaries in the group.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot as source.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
<li><strong>source_cg</strong> &#8211; the dictionary of a consistency group as source.</li>
<li><strong>source_vols</strong> &#8211; a list of volume dictionaries in the source_cg.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>The source can be cgsnapshot or a source cg.</p>
<p>param volumes is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
assigned to volumes_model_update. volumes_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>To be consistent with other volume operations, the manager will
assume the operation is successful if no exception is thrown by
the driver. For a successful operation, the driver can either build
the model_update and volumes_model_update and return them or
return None, None.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">create_export_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em>, <em>connector</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">create_replica_test_volume</code><span class="sig-paren">(</span><em>volume</em>, <em>src_vref</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">create_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">create_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">create_volume_from_snapshot</code><span class="sig-paren">(</span><em>volume</em>, <em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Creates a volume from a snapshot.</p>
<p>If volume_type extra specs includes &#8216;replication: &lt;is&gt; True&#8217;
the driver needs to create a volume replica (secondary),
and setup replication between the newly created volume and
the secondary volume.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_cgsnapshot</code><span class="sig-paren">(</span><em>context</em>, <em>cgsnapshot</em>, <em>snapshots</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a cgsnapshot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>cgsnapshot</strong> &#8211; the dictionary of the cgsnapshot to be deleted.</li>
<li><strong>snapshots</strong> &#8211; a list of snapshot dictionaries in the cgsnapshot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, snapshots_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param snapshots is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
assigned to snapshots_model_update. snapshots_model_update is a list
of dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate snapshots_model_update and model_update
and return them.</p>
<p>The manager will check snapshots_model_update and update db accordingly
for each snapshot. If the driver successfully deleted some snapshots
but failed to delete others, it should set statuses of the snapshots
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of snapshots_model_update is
&#8216;error_deleting&#8217; or &#8216;error&#8217;, the status in model_update will be set to
the same if it is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of cgsnapshot will be
set to &#8216;error&#8217; in the db. If snapshots_model_update is not returned by
the driver, the manager will set the status of every snapshot to
&#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager and the statuses of
cgsnapshot and all snapshots will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and snapshots_model_update and return them or
return None, None. The statuses of cgsnapshot and all snapshots
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>volumes</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a consistency group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be deleted.</li>
<li><strong>volumes</strong> &#8211; a list of volume dictionaries in the group.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, volumes_model_update</p>
</td>
</tr>
</tbody>
</table>
<p>param volumes is retrieved directly from the db. It is a list of
cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
assigned to volumes_model_update. volumes_model_update is a list of
dictionaries. It has to be built by the driver. An entry will be
in this format: {&#8216;id&#8217;: xxx, &#8216;status&#8217;: xxx, ......}. model_update
will be in this format: {&#8216;status&#8217;: xxx, ......}.</p>
<p>The driver should populate volumes_model_update and model_update
and return them.</p>
<p>The manager will check volumes_model_update and update db accordingly
for each volume. If the driver successfully deleted some volumes
but failed to delete others, it should set statuses of the volumes
accordingly so that the manager can update db correctly.</p>
<p>If the status in any entry of volumes_model_update is &#8216;error_deleting&#8217;
or &#8216;error&#8217;, the status in model_update will be set to the same if it
is not already &#8216;error_deleting&#8217; or &#8216;error&#8217;.</p>
<p>If the status in model_update is &#8216;error_deleting&#8217; or &#8216;error&#8217;, the
manager will raise an exception and the status of the group will be
set to &#8216;error&#8217; in the db. If volumes_model_update is not returned by
the driver, the manager will set the status of every volume in the
group to &#8216;error&#8217; in the except block.</p>
<p>If the driver raises an exception during the operation, it will be
caught by the try-except block in the manager. The statuses of the
group and all volumes in it will be set to &#8216;error&#8217;.</p>
<p>For a successful operation, the driver can either build the
model_update and volumes_model_update and return them or
return None, None. The statuses of the group and all volumes
will be set to &#8216;deleted&#8217; after the manager deletes them from db.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">delete_volume</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">ensure_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">extend_volume</code><span class="sig-paren">(</span><em>volume</em>, <em>new_size</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">get_manageable_snapshots</code><span class="sig-paren">(</span><em>cinder_snapshots</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">get_manageable_volumes</code><span class="sig-paren">(</span><em>cinder_volumes</em>, <em>marker</em>, <em>limit</em>, <em>offset</em>, <em>sort_keys</em>, <em>sort_dirs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">get_pool</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd><p>Return pool name where volume reside on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>volume</strong> &#8211; The volume hosted by the driver.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">name of the pool where given volume is in.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">initialize_connection_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Allow connection from connector for a snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">local_path</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_get_size</code><span class="sig-paren">(</span><em>volume</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">manage_existing_snapshot_get_size</code><span class="sig-paren">(</span><em>snapshot</em>, <em>existing_ref</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">migrate_volume</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>host</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">remove_export</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">remove_export_snapshot</code><span class="sig-paren">(</span><em>context</em>, <em>snapshot</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">retype</code><span class="sig-paren">(</span><em>context</em>, <em>volume</em>, <em>new_type</em>, <em>diff</em>, <em>host</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection</code><span class="sig-paren">(</span><em>volume</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Disallow connection from connector</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">terminate_connection_snapshot</code><span class="sig-paren">(</span><em>snapshot</em>, <em>connector</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Disallow connection from connector for a snapshot.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">unmanage</code><span class="sig-paren">(</span><em>volume</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">unmanage_snapshot</code><span class="sig-paren">(</span><em>snapshot</em><span class="sig-paren">)</span></dt>
<dd><p>Unmanage the specified snapshot from Cinder management.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_consistencygroup</code><span class="sig-paren">(</span><em>context</em>, <em>group</em>, <em>add_volumes=None</em>, <em>remove_volumes=None</em><span class="sig-paren">)</span></dt>
<dd><p>Updates a consistency group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>context</strong> &#8211; the context of the caller.</li>
<li><strong>group</strong> &#8211; the dictionary of the consistency group to be updated.</li>
<li><strong>add_volumes</strong> &#8211; a list of volume dictionaries to be added.</li>
<li><strong>remove_volumes</strong> &#8211; a list of volume dictionaries to be removed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">model_update, add_volumes_update, remove_volumes_update</p>
</td>
</tr>
</tbody>
</table>
<p>model_update is a dictionary that the driver wants the manager
to update upon a successful return. If None is returned, the manager
will set the status to &#8216;available&#8217;.</p>
<p>add_volumes_update and remove_volumes_update are lists of dictionaries
that the driver wants the manager to update upon a successful return.
Note that each entry requires a {&#8216;id&#8217;: xxx} so that the correct
volume entry can be updated. If None is returned, the volume will
remain its original status. Also note that you cannot directly
assign add_volumes to add_volumes_update as add_volumes is a list of
cinder.db.sqlalchemy.models.Volume objects and cannot be used for
db update directly. Same with remove_volumes.</p>
<p>If the driver throws an exception, the status of the group as well as
those of the volumes to be added/removed will be set to &#8216;error&#8217;.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-cinder-tests-unit-volume-module">
<h3>The <code class="xref py py-mod docutils literal"><span class="pre">cinder.tests.unit.volume</span></code> Module<a class="headerlink" href="#the-cinder-tests-unit-volume-module" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><code class="descname">BaseVolumeTestCase</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="../api/cinder.test.html#cinder.test.TestCase" title="cinder.test.TestCase"><code class="xref py py-class docutils literal"><span class="pre">cinder.test.TestCase</span></code></a></p>
<p>Test Case for volumes.</p>
<dl class="attribute">
<dt>
<code class="descname">FAKE_UUID</code><em class="property"> = 'e79161cd-5f9d-4007-8823-81a807a64332'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">fake_get_all_volume_groups</code><span class="sig-paren">(</span><em>obj</em>, <em>vg_name=None</em>, <em>no_suffix=True</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">setUp</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="old-docs">
<h2>Old Docs<a class="headerlink" href="#old-docs" title="Permalink to this headline">¶</a></h2>
<p>Cinder uses iSCSI to export storage volumes from multiple storage nodes. These iSCSI exports are attached (using libvirt) directly to running instances.</p>
<p>Cinder volumes are exported over the primary system VLAN (usually VLAN 1), and not over individual VLANs.</p>
<p>The underlying volumes by default are LVM logical volumes, created on demand within a single large volume group.</p>
</div>
</div>


          </div>
        </div>
      </div>
<div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Storage Volumes, Disks</a><ul>
<li><a class="reference internal" href="#the-cinder-volume-manager-module">The <code class="docutils literal"><span class="pre">cinder.volume.manager</span></code> Module</a></li>
<li><a class="reference internal" href="#the-cinder-volume-driver-module">The <code class="docutils literal"><span class="pre">cinder.volume.driver</span></code> Module</a></li>
<li><a class="reference internal" href="#tests">Tests</a><ul>
<li><a class="reference internal" href="#the-cinder-tests-unit-volume-module">The <code class="docutils literal"><span class="pre">cinder.tests.unit.volume</span></code> Module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#old-docs">Old Docs</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="database.html"
                                  title="previous chapter">The Database Layer</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="auth.html"
                                  title="next chapter">Authentication and Authorization</a></p>
            <h3>Project Source</h3>
            <ul class="this-page-menu">
              <li><a href="http://git.openstack.org/cgit/openstack/cinder
"
                     rel="nofollow">Project Source</a></li>
            </ul>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/devref/volume.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
    </div>
</div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="auth.html" title="Authentication and Authorization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="database.html" title="The Database Layer"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">cinder 10.0.0.0rc2.dev77 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Developer Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2010-present, OpenStack Foundation.
      Last updated on Tue Feb 14 19:31:55 2017, commit e7efdb6.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
//Tracking docs.openstack.org/developer/<projectname> only
//The URL is built from the project variable in conf.py
var pageTracker = _gat._getTracker("UA-17511903-1");
pageTracker._setCookiePath("/developer/cinder");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>